<?xml version="1.0" encoding="UTF-8"?><record_update table="sys_metadata_link">
    <sys_metadata_link action="INSERT_OR_UPDATE">
        <directory>update</directory>
        <documentkey>22f87224ff032110468365d7d3b8fee6</documentkey>
        <payload>&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;record_update table="sys_script_include"&gt;
    &lt;sys_script_include action="INSERT_OR_UPDATE"&gt;
        &lt;access&gt;package_private&lt;/access&gt;
        &lt;active&gt;true&lt;/active&gt;
        &lt;api_name&gt;sn_entitlement.MembershipInMemoryCache&lt;/api_name&gt;
        &lt;caller_access/&gt;
        &lt;client_callable&gt;false&lt;/client_callable&gt;
        &lt;description/&gt;
        &lt;name&gt;MembershipInMemoryCache&lt;/name&gt;
        &lt;script&gt;&lt;![CDATA[/**
 * This class is intended to contain membership relationships in a memory efficient manner so that they can be
 * loaded into memory and used without incremental database calls for each request. The initial use case is to
 * store userIds and the associated roleIds that the user has. However, this class is flexible enough to hold
 * other types of data that conform to the same sort of relationship.
 */
var MembershipInMemoryCache = Class.create();
MembershipInMemoryCache.prototype = {
    /**
     * Constructor that takes a data provider and key/value names to load data from and cache in memory.
     * Since this class doesn't need to know where the data is coming from, only how to retrieve it,
     * the key/value names are to provide flexibility for varying data sources.
     *
     * @param glideRecord Glide record object that provides data
     * @param keyName The name of the key for the data (e.g. userId)
     * @param valName The name of the key for the value (e.g. roleId)
     * @param maxValueCount The max number of values expected
     */
    initialize: function(glideRecord, keyName, valName, maxValueCount) {
        this._maxValueCount = maxValueCount;
        this._bitmap = [];
        this._loadData(glideRecord, keyName, valName, maxValueCount);
    },

    /**
     * Retrieves the values associated with the provided id
     *
     * @param id The id to fetch data for. (e.g. userId)
     */
    getValsById: function(id) {
        if (!this._keys.has(id))
            return [];
        const keyIndex = this._keys.get(id);

        let vals = [];
        for (let valueIndex = 0; valueIndex &lt; this._maxValueCount; valueIndex++) {
            if (this._isSet(keyIndex, valueIndex))
                vals.push(this._vals[valueIndex]);
        }

        return vals;
    },

    /**
     * Load data into memory in an memory efficient manner.
     *
     * @param glideRecord Glide record object that provides data
     * @param keyName The name of the key for the data (e.g. userId)
     * @param valName The name of the key for the value (e.g. roleId)
     */
    _loadData: function(glideRecord, keyName, valName) {
        const keys = new Map();
        const values = new Map();

        while (glideRecord.next()) {
            const key = glideRecord.getValue(keyName);
            const val = glideRecord.getValue(valName);

            if (!keys.has(key))
                keys.set(key, keys.size);
            if (!values.has(val))
                values.set(val, values.size);
            const keyIndex = keys.get(key);
            const valueIndex = values.get(val);

            this._ensureSize(keyIndex);
            this._set(keyIndex, valueIndex);
        }

        this._keys = keys;
        this._vals = [...values.keys()];
    },

    /**
     * Ensure that there's enough array slots in this._bitmap which hold 32bit words
     * to accomodate all values at specified keyIndex. 
     * Specifically, that there's enough space to hold (keyIndex+1) * this._maxValueCount bit.
     * If this._bitmap is increased in size, the new array slots are initialized with 0.
     */
    _ensureSize: function(keyIndex) {
        const neededWords = Math.floor((this._maxValueCount * (keyIndex + 1) + 30) / 31);
        if (neededWords &gt; this._bitmap.length) {
            const fillFrom = this._bitmap.length;
            this._bitmap.length = neededWords;
            this._bitmap.fill(0, fillFrom);
        }
    },

    _set: function(keyIndex, valueIndex) {
        const [wordIndex, bitIndex] = this._getIndex(keyIndex, valueIndex);
        this._bitmap[wordIndex] |= 1 &lt;&lt; bitIndex;
    },

    _unset: function(keyIndex, valueIndex) {
        const [wordIndex, bitIndex] = this._getIndex(keyIndex, valueIndex);
        this._bitmap[wordIndex] &amp;= ~(1 &lt;&lt; bitIndex);
    },

    _isSet: function(keyIndex, valueIndex) {
        const [wordIndex, bitIndex] = this._getIndex(keyIndex, valueIndex);
        return (this._bitmap[wordIndex] &amp; 1 &lt;&lt; bitIndex) &gt; 0;
    },

    _getIndex: function(keyIndex, valueIndex) {
        // find the logical index in the sequence of bits laid out in row major format
        // 0 1 2 3 ... maxValueCount-1
        // 0 1 2 3 ... maxValueCount-1
        // ...
        // is laid out as
        // 0 1 2 3 ... maxValueCount-1 0 1 2 3 ... maxValueCount-1 ...

        const logicalIndex = this._maxValueCount * keyIndex + valueIndex;

        // find the 32 bit word where the logical index falls, where only 31 bits in each are used
        const wordIndex = Math.floor(logicalIndex / 31);

        // inside the 32 bit word, map the bit to the bit going from the 
        // order least significant bit to most significant bit
        // so that bitwise operation can be performed using 1 &lt;&lt;&lt; X
        const bitIndex = 30 - logicalIndex % 31; // since only 31 bits are used

        return [wordIndex, bitIndex];
    },

    type: 'MembershipInMemoryCache'
};]]&gt;&lt;/script&gt;
        &lt;sys_class_name&gt;sys_script_include&lt;/sys_class_name&gt;
        &lt;sys_created_by&gt;maint&lt;/sys_created_by&gt;
        &lt;sys_created_on&gt;2023-05-23 18:00:21&lt;/sys_created_on&gt;
        &lt;sys_id&gt;22f87224ff032110468365d7d3b8fee6&lt;/sys_id&gt;
        &lt;sys_mod_count&gt;19&lt;/sys_mod_count&gt;
        &lt;sys_name&gt;MembershipInMemoryCache&lt;/sys_name&gt;
        &lt;sys_package display_value="Licensing Engine" source="sn_entitlement"&gt;bcadabf277f311109c62f5f3cb5a992a&lt;/sys_package&gt;
        &lt;sys_policy/&gt;
        &lt;sys_scope display_value="Licensing Engine"&gt;bcadabf277f311109c62f5f3cb5a992a&lt;/sys_scope&gt;
        &lt;sys_update_name&gt;sys_script_include_22f87224ff032110468365d7d3b8fee6&lt;/sys_update_name&gt;
        &lt;sys_updated_by&gt;maint&lt;/sys_updated_by&gt;
        &lt;sys_updated_on&gt;2023-07-28 16:50:02&lt;/sys_updated_on&gt;
    &lt;/sys_script_include&gt;
&lt;/record_update&gt;
</payload>
        <sys_class_name>sys_metadata_link</sys_class_name>
        <sys_created_by>admin</sys_created_by>
        <sys_created_on>2024-09-21 08:12:09</sys_created_on>
        <sys_id>10f0b05983b01210c6695855eeaad3b4</sys_id>
        <sys_mod_count>0</sys_mod_count>
        <sys_name>MembershipInMemoryCache</sys_name>
        <sys_package display_value="Now Utils" source="x_938076_now_utils">b208a7c083689e50c6695855eeaad3d2</sys_package>
        <sys_policy/>
        <sys_scope display_value="Now Utils">b208a7c083689e50c6695855eeaad3d2</sys_scope>
        <sys_update_name>sys_metadata_link_10f0b05983b01210c6695855eeaad3b4</sys_update_name>
        <sys_updated_by>admin</sys_updated_by>
        <sys_updated_on>2024-09-21 08:12:09</sys_updated_on>
        <tablename>sys_script_include</tablename>
    </sys_metadata_link>
</record_update>
