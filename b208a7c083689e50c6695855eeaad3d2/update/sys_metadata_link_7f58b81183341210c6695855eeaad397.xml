<?xml version="1.0" encoding="UTF-8"?><record_update table="sys_metadata_link">
    <sys_metadata_link action="INSERT_OR_UPDATE">
        <directory>update</directory>
        <documentkey>83186870ff0d6110468365d7d3b8fe0d</documentkey>
        <payload>&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;record_update table="sys_script_include"&gt;
    &lt;sys_script_include action="INSERT_OR_UPDATE"&gt;
        &lt;access&gt;package_private&lt;/access&gt;
        &lt;active&gt;true&lt;/active&gt;
        &lt;api_name&gt;sn_entitlement.SubscriptionEntitlementDao&lt;/api_name&gt;
        &lt;caller_access/&gt;
        &lt;client_callable&gt;false&lt;/client_callable&gt;
        &lt;description&gt;DAO to retrieve data from subscription_entitlement&lt;/description&gt;
        &lt;name&gt;SubscriptionEntitlementDao&lt;/name&gt;
        &lt;script&gt;&lt;![CDATA[var SubscriptionEntitlementDao = Class.create();
SubscriptionEntitlementDao.prototype = {
    METER_TYPE_MODULE: 'module',

    initialize: function() {},

    /**
     * Retrieves all of the active subscriptionIds (subscription_entitlement.sys_id)
     * That are of type Per-User
     *
     * @returns {array} An array of subscription_entitlement.sys_id values
     */
    getSubscriptionIdsByIsPerUser: function() {
        const now = new GlideDate().getValue();

        // Note: start_date &amp; end_date values in the sample data are null. It is unclear if this will be the case
        //    in production, but adding support for it due to the test data.
        const gr = new GlideRecord('subscription_entitlement');
        gr.addQuery('status', 0); // Active
        gr.addQuery('start_date', '&lt;=', now)
            .addOrCondition('start_date', 'NULL');
        gr.addQuery('end_date', '&gt;=', now)
            .addOrCondition('end_date', 'NULL');
        gr.addQuery('subscription_type', 0); // Per-User
        gr.query();

        const ids = [];
        while (gr.next())
            ids.push(gr.getUniqueValue());
        return ids;
    },

    /**
     * Retrieves the subscriptionId associated with the subscription detail record
     *
     * @param {guid} subscriptionDetailId The subscription_detail.sys_id of the record to query
     * @returns {guid} The subscription_entitlement.sys_id related to the record
     */
    getSubscriptionIdBySubscriptionDetailId: function(subscriptionDetailId) {
        const gr = new GlideRecord('subscription_detail');
        return gr.get(subscriptionDetailId) ?
            String(gr.getValue('subscription')) :
            null;
    },

    /**
     * Retrieves the subscriptionIds (subscription_entitlement.sys_id) belonging to a user that are
     * per-user type
     *
     * @param {guid} userId The sys_user.sys_id for the user to retrieve subscription information for
     * @returns {array} An array of subscription_entitlement.sys_id values the user is subscribed to
     */
    getSubscriptionIdsByUserIdAndIsPerUser: function(userId) {
        const now = new GlideDate().getValue();

        // Note: start_date &amp; end_date values in the sample data are null. It is unclear if this will be the case
        //    in production, but adding support for it due to the test data.
        const gr = new GlideRecord('user_has_subscription');
        gr.addQuery('subscription.status', 0); // Active
        gr.addQuery('subscription.start_date', '&lt;=', now)
            .addOrCondition('subscription.start_date', 'NULL');
        gr.addQuery('subscription.end_date', '&gt;=', now)
            .addOrCondition('subscription.end_date', 'NULL');
        gr.addQuery('user.sys_id', userId); // sys_user.sys_id
        gr.addQuery('subscription.subscription_type', 0); // Per-User
        gr.addActiveQuery();
        gr.query();

        const ids = new Set();
        while (gr.next())
            ids.add(String(gr.subscription.sys_id));
        return Array.from(ids);
    },

    /**
     * Retrieves the subscription_entitlement.sys_id belonging to the group
     * and are per-user
     *
     * @param {guid} groupId The sys_user_group.sys_id for the group to retrieve subscription information for
     * @returns {array} An array of subscription_entitlement.sys_id values the group is subscribed to
     */
    getSubscriptionIdsByGroupIdAndIsPerUser: function(groupId) {
        const now = new GlideDate().getValue();

        // Note: start_date &amp; end_date values in the sample data are null. It is unclear if this will be the case
        //    in production, but adding support for it due to the test data.
        const gr = new GlideRecord('group_has_subscription');
        gr.addQuery('group.sys_id', groupId);
        gr.addQuery('subscription.status', 0); // Active
        gr.addQuery('subscription.start_date', '&lt;=', now)
            .addOrCondition('subscription.start_date', 'NULL');
        gr.addQuery('subscription.end_date', '&gt;=', now)
            .addOrCondition('subscription.end_date', 'NULL');
        gr.addQuery('subscription.subscription_type', 0); // Per-User
        gr.query();

        const ids = new Set();
        while (gr.next())
            ids.add(String(gr.subscription.sys_id));
        return Array.from(ids);
    },

    /**
     * Retrieves the subscriptionIds (subscription_entitlement.sys_id) belonging all active modules
     * that do not have a meter
     *
     * @returns {array} An array of subscription_entitlement.sys_id values the user is subscribed to
     */
    getSubscriptionIdsByIsModuleWithoutCapacityMeter: function() {
        const now = new GlideDate().getValue();

        // Note: start_date &amp; end_date values in the sample data are null. It is unclear if this will be the case
        //    in production, but adding support for it due to the test data.
        const gr = new GlideRecord('subscription_entitlement');
        gr.addQuery('status', 0); // Active
        gr.addQuery('start_date', '&lt;=', now)
            .addOrCondition('start_date', 'NULL');
        gr.addQuery('end_date', '&gt;=', now)
            .addOrCondition('end_date', 'NULL');
        gr.addQuery('meter_type', this.METER_TYPE_MODULE);
        gr.addNullQuery('definition_id')
            .addOrCondition('definition_id', '');
        gr.query();

        const ids = new Set();
        while (gr.next())
            ids.add(gr.getUniqueValue());
        return Array.from(ids);
    },

    /**
     * Retrieves all of the active subscription ids that have a subscription type 
     * of unrestricted user.
     *
     * @returns {array} An array of subscription IDs
     */
    getSubscriptionIdsByActiveAndIsUnrestrictedUser: function() {
        const now = new GlideDate().getValue();

        const gr = new GlideRecord('subscription_entitlement');
        gr.addQuery('status', 0); // Active
        gr.addQuery('start_date', '&lt;=', now)
            .addOrCondition('start_date', 'NULL');
        gr.addQuery('end_date', '&gt;=', now)
            .addOrCondition('end_date', 'NULL');
        gr.addQuery('subscription_type', 2); // 2 = Unrestricted User
        gr.query();

        const ids = [];
        while (gr.next())
            ids.push(gr.getUniqueValue());
        return ids;
    },

    /**
     * Return information about active subscriptions which contain specified app bundles
     * @param {array} appBundles names of app bundles
     * @return {array} an array of SubscriptionEntitlementData
     */
    getSubscriptionEntitlementsByContainsAppBundles: function(appBundles) {
        const gr = new GlideRecord('sku_metadata');
        gr.addQuery('subscription.status', 0);
        // look for app_bundle in column names
        gr.addQuery('schema.column_names', 'CONTAINS', 'app_bundle');

        // and look for app bundle values in column_values
        // note that a simple contains is used instead of matching a value at specific position
        // but this should be good enough given the columns are pretty different (VALIDATE)
        const condition = gr.addQuery('column_values', 'CONTAINS', appBundles[0]);
        for (let i = 1; i &lt; appBundles.length; ++i) {
            condition.addOrCondition('column_values', 'CONTAINS', appBundles[i]);
        }
        gr.query();
        return this._distinct(this._collectRecords(gr, 'subscription'));
    },

    /**
     * Return information about id of ALL app bundles
     * @return {array} an array of ids of ALL app bundles 
     */
    getAppBundles: function() {
        const gr = new GlideRecord('sku_metadata');
        gr.addQuery('subscription.status', 0);
        // look for app_bundle in column names
        gr.addQuery('schema.column_names', 'CONTAINS', 'app_bundle');
        gr.query();

        var result = {};
        while (gr.next()) {
            // the last value in "column_values" column
            const column_schema = gr.getDisplayValue("schema");
            const column_values = gr.getValue("column_values");
            const columnSchemaArray = column_schema.split(",");
            const columnValueArray = column_values.split(",");
            if (columnSchemaArray.length &gt; 0) {
                for (var i = 0; i &lt; columnSchemaArray.length; i++) {
                    if (columnSchemaArray[i] == "app_bundle") {
                        result[columnValueArray[i]] = '1';
                    }
                }
            }
        }
        return Object.keys(result);
    },

    getSubscriptionRatiosByContainsAppBundles: function(appBundles, entitlementSysId) {
        const gr = new GlideRecord('sku_metadata');
        gr.addQuery('subscription.sys_id', entitlementSysId);
        const condition = gr.addQuery('column_values', 'CONTAINS', appBundles[0]);
        for (let i = 1; i &lt; appBundles.length; ++i) {
            condition.addOrCondition('column_values', 'CONTAINS', appBundles[i]);
        }
        gr.query();


        var valueObjectArray = [];
        while (gr.next()) {
            const column_schema = gr.getDisplayValue("schema");
            const column_values = gr.getValue("column_values");
            const columnSchemaArray = column_schema.split(",");
            const columnValueArray = column_values.split(",");

            var valueObject = {};
            for (var i = 0; i &lt; columnSchemaArray.length; i++) {
                valueObject[columnSchemaArray[i]] = columnValueArray[i];
            }
            valueObjectArray.push(valueObject);
        }
        return valueObjectArray;
    },

    _collectRecords: function(gr, columnName) {
        var result = [];
        while (gr.next()) {
            const record = columnName ? gr[columnName].getRefRecord() : gr;
            result.push(this._mapToObject(record));
        }
        return result;
    },

    _mapToObject: function(record) {
        var allocation_count = null;
        const detailsGr = new GlideRecord("subscription_detail");
        detailsGr.addQuery('subscription', record.getUniqueValue());
        detailsGr.addQuery('is_latest', 'true');
        detailsGr.query();
        if (detailsGr.next()) {
            allocation_count = detailsGr.allocated_quota_count.toString();
        }
        return SubscriptionEntitlementData.fromRecord(
            record.getUniqueValue(),
            record.name.toString(),
            record.start_date.toString(),
            record.end_date.toString(),
            record.purchased_count.toString(),
            allocation_count
        );
    },

    _distinct: function(licenseDetails) {
        const map = new Map();
        licenseDetails.forEach(obj =&gt; map.set(obj.id, obj));
        return Array.from(map.values());
    },

    /**
     * Retrieves all of the subscriptionIds (subscription_entitlement.sys_id) for list of products
     *
     * @returns {map} map of product and subscription_entitlement.sys_id
     */
    getProductCodeToEmsSubscriptionSysIdMap: function(productCodes) {
        const productCodeToEmsSubscriptionSysIdMap = {};

        if (global.JSUtil.nil(productCodes))
            return productCodeToEmsSubscriptionSysIdMap;

        const gr = new GlideRecord('subscription_entitlement');
        gr.query();

        while (gr.next()) {
            const smv2ProductCode = gr.getValue('product_code');
            const smv2SubscriptionSysID = gr.getUniqueValue();

            for (let i = 0; i &lt; productCodes.length; i++) {
                const smv1ProductCode = productCodes[i];
                if (this.isSubsetOf(smv1ProductCode, smv2ProductCode))
                    productCodeToEmsSubscriptionSysIdMap[smv1ProductCode] = smv2SubscriptionSysID;
            }
        }

        return productCodeToEmsSubscriptionSysIdMap;
    },

    /**
     * For the given SubscriptionId we return the ParentEntitlementId
     *
     * @param {guid} subscriptionId The subscription_entitlement.sys_id to retrieve subscription information
     * @returns {number} null or parentEntitlementId
     *
     * Note: Expectation is Customer will be mapping a Custom Table to a Primary Subscription and not the Secondary Meter
     */
    getParentEntitlementIdForCTSecondaryMeter: function(subscriptionId) {
        const entGR = new GlideRecord(LicensingEngineDBConstants.SUBSCRIPTION_ENTITLEMENT);
        entGR.addQuery(LicensingEngineDBConstants.SYS_ID, subscriptionId);
        entGR.addQuery(LicensingEngineDBConstants.SUBCLASS_TYPE, LicensingEngineConstants.CUSTOM_TABLES); // 'Custom Tables', filter only these we dont want to calculate counts for other secondary meters eg: Customer Portal Visits
        entGR.addQuery(LicensingEngineDBConstants.STATUS, LicensingEngineConstants.ACTIVE_STATUS); // 0 - Active
        entGR.query();

        // If an entry is found return the parentEntitlementId, which is used to get the custom table count, since we are mapping tables at the Primary Subscription level
        return entGR.next() ?
            entGR.getValue(LicensingEngineDBConstants.PARENT_ENTITLEMENT_ID) :
            null;
    },

    /**
     * For the given ParentEntitlementId return the list of all Secondary Meter (SubClassType: Custom Tables) to calculate
     * allocation count
     *
     * @param {guid} subscription_entitlement.parent_entitlement_id
     * @returns {GlideRecord} gr
     */
    getCTSecondaryMetersByParentEntitlementId: function(parentEntitlementId) {
        const entGR = new GlideRecord(LicensingEngineDBConstants.SUBSCRIPTION_ENTITLEMENT);
        entGR.addQuery(LicensingEngineDBConstants.PARENT_ENTITLEMENT_ID, parentEntitlementId);
        entGR.addQuery(LicensingEngineDBConstants.ENTITLEMENT_TYPE, LicensingEngineDBConstants.ENTITLEMENT_TYPE_VALUE.SECONDARY_METER);
        entGR.addQuery(LicensingEngineDBConstants.SUBCLASS_TYPE, LicensingEngineConstants.CUSTOM_TABLES); // 'Custom Tables' filter only these we dont want to calculate counts for other secondary meters eg: Customer Portal Visits
        entGR.addQuery(LicensingEngineDBConstants.STATUS, LicensingEngineConstants.ACTIVE_STATUS); // 0 - Active
        entGR.orderBy(LicensingEngineDBConstants.SYS_ID);
        entGR.query();

        return entGR;
    },

    /**
     * The method evaluates if product code(s) from SMV1 are subset of product code(s) from SMV2 product code(s) for a given license
     * 
     * @param {smv1ProductCode} of type string can be comma seperated to include multiple product code(s) from SMV1
     * @param {smv2ProductCode} of type string can be comma seperated to include multiple product code(s) from SMV2 
     * @returns {boolean} true if subset found else false
     * 
     * 
     * Example 1
     * var smv1ProductCode = "PROD12042,PROD120TEST,PROD1204";
     * var smv2ProductCode = "PROD12042,PROD12041";
     * isSubsetOf(smv1ProductCode, smv2ProductCode)  will return false
     * 
     * Example 2
     * var smv1ProductCode = "PROD12042,PROD45672";
     * var smv2ProductCode = "PROD120TEST,PROD12042,PROD45672";
     * isSubsetOf(smv1ProductCode, smv2ProductCode)  will return true
     * 
     * Example 3
     * var smv1ProductCode = "";
     * var smv2ProductCode = "PROD12042,PROD12041";
     * isSubsetOf(smv1ProductCode, smv2ProductCode)  will return false
     * 
     * Example 4
     * var smv1ProductCode = "PROD12042,PROD12041";
     * var smv2ProductCode = "";
     * isSubsetOf(smv1ProductCode, smv2ProductCode)  will return false
     * 
     * Example 5
     * var smv1ProductCode = "PROD12042,PROD12041";
     * var smv2ProductCode = "PROD12042,PROD12042,PROD12042";
     * isSubsetOf(smv1ProductCode, smv2ProductCode)  will return false
     * 
     */

    isSubsetOf: function(smv1ProductCode, smv2ProductCode) {
        if (global.JSUtil.nil(smv1ProductCode) || global.JSUtil.nil(smv2ProductCode))
            return false;

        const smv1ProductCodeList = smv1ProductCode.split(',').map(code =&gt; code.trim());
        const smv2ProductCodeList = smv2ProductCode.split(',').map(code =&gt; code.trim());

        if (smv1ProductCodeList.length &gt; smv2ProductCodeList.length)
            return false;

        for (var i = 0; i &lt; smv1ProductCodeList.length; i++) {
            if (!smv2ProductCodeList.includes(smv1ProductCodeList[i])) {
                return false;
            }

        }

        return true;
    },

    /**
     * Retrieves the capacity definition ID associated with a given subscription sys_id.
     * @param {string} subscriptionId - The sys_id of the subscription.
     * @returns {string|null} - The capacity definition ID if found, otherwise null.
     */
    getCapacityDefinitionIdBySubscriptionId: function(subscriptionId) {
        const entleGr = new GlideRecord(LicensingEngineDBConstants.SUBSCRIPTION_ENTITLEMENT);
        if (entleGr.get(subscriptionId))
            return entleGr.getValue(LicensingEngineDBConstants.DEFINITION_ID);
        return null;
    },

    /**
     * Retrieves the array of active subscription entitlements created more than {daysAgo} days ago
     * @param {daysAgo} the number of daysold the record must be
     * @returns {array} - the array of found subscription entitlement sys_ids.
     */
    getActiveSubscriptionEntitlementsOlderThanDays: function(daysAgo = 2) {
        const se = new GlideRecord(LicensingEngineDBConstants.SUBSCRIPTION_ENTITLEMENT);
        se.addQuery("sys_created_on", "&lt;", gs.daysAgo(daysAgo));

        se.addQuery("status", LicensingEngineConstants.ACTIVE_STATUS);
        se.query();
        const subscriptionEntitlements = [];
        while (se.next())
            subscriptionEntitlements.push(se.getUniqueValue());

        return subscriptionEntitlements;
    },

    /**
     * Return information about all active subscriptions for ITOM team to identify legacy itom licenses.
     * @return {array} an array of Subscription entitlement data
     */
    getSubscriptionEntitlementsITOM: function() {
        const subscriptionEntitlementObjList = [];
        const now = new GlideDate().getValue();
        const gr = new GlideRecord('subscription_entitlement');
        gr.addQuery('status', 0); // Active
        gr.addQuery('start_date', '&lt;=', now);
        gr.addQuery('end_date', '&gt;=', now);
        gr.addQuery('entitlement_type', 0); //process primary subscription only
        gr.query();
        while (gr.next()) {
            var subscriptionEntitlementObj = {
                'license': gr.getValue('name'),
                'product_code': gr.getValue('product_code'),
                'purchased_count': gr.getValue('purchased_count'),
                'details_url': "subscription_entitlement?sys_id=" + gr.sys_id
            };
            subscriptionEntitlementObjList.push(subscriptionEntitlementObj);
        }
        return subscriptionEntitlementObjList;
    },

    type: 'SubscriptionEntitlementDao'
};]]&gt;&lt;/script&gt;
        &lt;sys_class_name&gt;sys_script_include&lt;/sys_class_name&gt;
        &lt;sys_created_by&gt;maint&lt;/sys_created_by&gt;
        &lt;sys_created_on&gt;2023-02-13 15:59:25&lt;/sys_created_on&gt;
        &lt;sys_id&gt;83186870ff0d6110468365d7d3b8fe0d&lt;/sys_id&gt;
        &lt;sys_mod_count&gt;87&lt;/sys_mod_count&gt;
        &lt;sys_name&gt;SubscriptionEntitlementDao&lt;/sys_name&gt;
        &lt;sys_package display_value="Licensing Engine" source="sn_entitlement"&gt;bcadabf277f311109c62f5f3cb5a992a&lt;/sys_package&gt;
        &lt;sys_policy&gt;read&lt;/sys_policy&gt;
        &lt;sys_scope display_value="Licensing Engine"&gt;bcadabf277f311109c62f5f3cb5a992a&lt;/sys_scope&gt;
        &lt;sys_update_name&gt;sys_script_include_83186870ff0d6110468365d7d3b8fe0d&lt;/sys_update_name&gt;
        &lt;sys_updated_by&gt;maint&lt;/sys_updated_by&gt;
        &lt;sys_updated_on&gt;2023-09-12 05:44:32&lt;/sys_updated_on&gt;
    &lt;/sys_script_include&gt;
&lt;/record_update&gt;
</payload>
        <sys_class_name>sys_metadata_link</sys_class_name>
        <sys_created_by>admin</sys_created_by>
        <sys_created_on>2024-09-21 08:44:37</sys_created_on>
        <sys_id>7f58b81183341210c6695855eeaad397</sys_id>
        <sys_mod_count>0</sys_mod_count>
        <sys_name>SubscriptionEntitlementDao</sys_name>
        <sys_package display_value="Now Utils" source="x_938076_now_utils">b208a7c083689e50c6695855eeaad3d2</sys_package>
        <sys_policy/>
        <sys_scope display_value="Now Utils">b208a7c083689e50c6695855eeaad3d2</sys_scope>
        <sys_update_name>sys_metadata_link_7f58b81183341210c6695855eeaad397</sys_update_name>
        <sys_updated_by>admin</sys_updated_by>
        <sys_updated_on>2024-09-21 08:44:37</sys_updated_on>
        <tablename>sys_script_include</tablename>
    </sys_metadata_link>
</record_update>
