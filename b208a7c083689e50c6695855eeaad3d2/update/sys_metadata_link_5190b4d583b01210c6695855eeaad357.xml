<?xml version="1.0" encoding="UTF-8"?><record_update table="sys_metadata_link">
    <sys_metadata_link action="INSERT_OR_UPDATE">
        <directory>update</directory>
        <documentkey>1408353d53421010200bddeeff7b12ce</documentkey>
        <payload>&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;record_update table="sys_script_include"&gt;
    &lt;sys_script_include action="INSERT_OR_UPDATE"&gt;
        &lt;access&gt;public&lt;/access&gt;
        &lt;active&gt;true&lt;/active&gt;
        &lt;api_name&gt;global.LFTaskUtils&lt;/api_name&gt;
        &lt;caller_access/&gt;
        &lt;client_callable&gt;false&lt;/client_callable&gt;
        &lt;description&gt;Utility class to handle localization tasks. Customers are not expected to override these core functions &lt;/description&gt;
        &lt;name&gt;LFTaskUtils&lt;/name&gt;
        &lt;script&gt;&lt;![CDATA[var LFTaskUtils = Class.create();
LFTaskUtils.prototype = {
    tableName: 'sn_lf_task',

    initialize: function(grOrIdOrNumber) {
        this.lfConstants = new LFConstants();
        this.logger = new LFLogger("LFTaskUtils");
        this.utils = new LFUtils();
        this.luaUtils = new LFLUAUtils();
        this.settingUtils = new LFSettingUtils();
        this.states = this.lfConstants.TASK_STATES;

        if (grOrIdOrNumber &amp;&amp; grOrIdOrNumber.sys_class_name == this.tableName) {
            this.currentRecord = grOrIdOrNumber;
        } else if (grOrIdOrNumber) {
            var taskGr = new GlideRecord(this.tableName);
            taskGr.addQuery('sys_id', grOrIdOrNumber).addOrCondition('number', grOrIdOrNumber);
            taskGr.query();
            if (taskGr.next()) {
                this.currentRecord = taskGr;
            }
        }
    },

    hasValidRecord: function() {
        return this.currentRecord &amp;&amp; this.currentRecord.sys_class_name == this.tableName;
    },

    update: function() {
        if (!this.hasValidRecord()) {
            throw new Error('Update requested on invalid LF Task Record');
        }
        this.currentRecord.update();
    },

    getSysId: function() {
        return this.currentRecord.getValue('sys_id');
    },

    getArtifactSysId: function() {
        return this.currentRecord.getValue('document');
    },

    setArtifactSysId: function(sysId) {
        this.currentRecord.setValue('document', sysId);
    },

    getAdditionalInfo: function() {
        var additionalInfo = this.currentRecord.getValue("additional_info");
        return (additionalInfo) ? JSON.parse(additionalInfo) : {};
    },

    setAdditionalInfo: function(additionalInfo) {
        this.currentRecord.setValue("additional_info", JSON.stringify(additionalInfo));
    },

    getLFSettings: function() {
        return JSON.parse(this.currentRecord.getValue("settings"));
    },

    getDocumentContent: function() {
        return JSON.parse(this.currentRecord.getValue("document_content"));
    },

    setDocumentContent: function(documentContent) {
        this.currentRecord.setValue("document_content", JSON.stringify(documentContent));
    },

    getTaskNumber: function() {
        return this.currentRecord.getValue("number");
    },

    getTableName: function() {
        return this.currentRecord.getValue("table_name");
    },

    setTableName: function(tableName) {
        this.currentRecord.setValue('table_name', tableName);
    },

    getArtifactConfig: function() {
        return this.currentRecord.artifact_config;
    },

    setArtifactConfig: function(artifactId) {
        this.currentRecord.setValue('artifact_config', artifactId);
    },

    getArtifactInternalName: function() {
        var artifact = this.getArtifactConfig();
        var internalName;
        if (artifact) {
            internalName = artifact.internal_name.getValue();
        } else {
            var tableUtils = new TableUtils(this.getTableName());
            var baseTable = tableUtils.getAbsoluteBase();
            var artifactUtils = new LFArtifactUtils().initFromTableName(baseTable);
            internalName = artifactUtils.getInternalName();
        }
        return internalName;
    },

    getArtifactName: function() {
        return this.currentRecord.document.getRefRecord().getDisplayValue();
    },

    getConfiguredWorkFlow: function() {
        return this.getLFSettings().workflow;
    },

    getAutoTranslateMode: function() {
        return this.getLFSettings().auto_translation_mode;
    },

    setPublishSourceForLUA: function(sourceOfRequest) {
        var additionalInfo = this.getAdditionalInfo();
        additionalInfo.publishSourceForLUA = sourceOfRequest;
        return this.setAdditionalInfo(additionalInfo);
    },

    getPublishSourceForLUA: function() {
        return this.getAdditionalInfo().publishSourceForLUA;
    },

    // Added workflowName for backward compatibility of Q to R/S
    hasTranslationApprovalStep: function(workflowName) {
        var workflow = workflowName || this.getConfiguredWorkFlow();
        var allWorkflows = this.lfConstants.WORKFLOWS;
        switch (workflow) {
            case allWorkflows.Translation_ApprovalOfTranslations_AutoPublish:
            case allWorkflows.AutoTranslation_ApprovalOfTranslations_AutoPublish:
            case allWorkflows.BusinessApproval_Translation_ApprovalOfTranslations_AutoPublish:
            case allWorkflows.BusinessApproval_AutoTranslation_ApprovalOfTranslations_AutoPublish:
                return true;
            default:
                return false;
        }
    },

    getSourceLanguageCode: function() {
        return this.currentRecord.source_language.id.getValue();
    },

    setSourceLanguageCode: function(id) {
        this.currentRecord.setValue("source_language", id);
    },

    getSourceLanguageName: function() {
        return gs.getMessage(this.currentRecord.source_language.name.getValue());
    },

    getTargetLanguageCode: function() {
        return this.currentRecord.target_language.id.getValue();
    },

    setTargetLanguageCode: function(id) {
        this.currentRecord.setValue("target_language", id);
    },

    getTargetLanguageName: function() {
        return gs.getMessage(this.currentRecord.target_language.name.getValue());
    },

    getCurrentStateNumber: function() {
        return parseInt(this.getCurrentState());
    },

    getCurrentState: function() {
        return this.currentRecord.getValue('state');
    },

    getCurrentStateName: function() {
        return this.currentRecord.getDisplayValue('state');
    },

    getClosedTime: function() {
        return this.currentRecord.getValue('closed_at');
    },

    isInStates: function() {
        var currentState = this.getCurrentState();
        for (var idx = 0; idx &lt; arguments.length; idx++) {
            if (arguments[idx] == currentState) {
                return true;
            }
        }
        return false;
    },

    isTaskCompleted: function() {
        return this.isInStates(this.states.Closed_Complete, this.states.Error_In_Publishing_Translations, this.states.Closed_Incomplete);
    },

    isInFulfillment: function() {
        return this.isInStates(this.states.Awaiting_Translation, this.states.Translation_In_Progress, this.states.Error_In_Translation, this.states.Open, this.states.Ready_For_Translation, this.states.In_Progress);
    },

    isUnderReview: function() {
        return this.isInStates(this.states.Awaiting_Translation_Approval, this.states.Under_Review);
    },

    isAutoTranslated: function() {
        // This function is used to check if task should be moved to next state once auto translation is completed
        var workflow = this.getConfiguredWorkFlow();
        var allWorkflows = this.lfConstants.WORKFLOWS;
        switch (workflow) {
            case allWorkflows.AutoTranslation_ApprovalOfTranslations_AutoPublish:
            case allWorkflows.AutoTranslation_AutoPublish:
            case allWorkflows.BusinessApproval_AutoTranslation_ApprovalOfTranslations_AutoPublish:
            case allWorkflows.BusinessApproval_AutoTranslation_AutoPublish:
                return true;
            default:
                return false;
        }
    },

    moveToAwaitingBusinessApproval: function() {
        this.currentRecord.setValue('state', this.states.Awaiting_Business_Approval);
    },

    moveToAwaitingTranslation: function() {
        this.currentRecord.setValue('state', this.states.Awaiting_Translation);
    },

    moveToTranslationInProgress: function() {
        this.moveToInProgress();
    },

    moveToInProgress: function() {
        if (this.hasBulkTranslations()) {
            this.currentRecord.setValue('state', this.states.In_Progress);
        } else {
            // For backward compatibility of flow contexts post upgrades
            this.currentRecord.setValue('state', this.states.Translation_In_Progress);
        }
    },

    moveToErrorInTranslation: function() {
        this.currentRecord.setValue('state', this.states.Error_In_Translation);
    },

    moveToTranslationApproved: function() {
        this.currentRecord.setValue('state', this.states.Translations_Approved);
    },

    moveToAwaitingTranslationApproval: function() {
        this.moveToUnderReview();
    },

    moveToUnderReview: function() {
        var hasBulkTranslations = this.hasBulkTranslations();
        if (hasBulkTranslations) {
            this.currentRecord.setValue('state', this.states.Under_Review);
        } else {
            // For backward compatibility of flow contexts post upgrades
            this.currentRecord.setValue('state', this.states.Awaiting_Translation_Approval);
        }
        if (this.hasTranslationApprovalStep()) {
            var content = gs.getMessage("Submitted the translations for approval");
            this.addWorkNotes(content);
            if (hasBulkTranslations) {
                LFRequestedItemUtils.updateLocalizationRequestedItemsWithJournalFields(this.getRelatedRequestedItemIdsFilterOutByState(), {
                    "work_notes": gs.getMessage("Translations are sent for approval.")
                });
            }
        }
    },

    moveToClosedComplete: function() {
        this.currentRecord.setValue('state', this.states.Closed_Complete);
    },

    moveToErrorInPublishTranslation: function() {
        this.currentRecord.setValue('state', this.states.Error_In_Publishing_Translations);
    },

    moveToClosedIncomplete: function() {
        this.currentRecord.setValue('state', this.states.Closed_Incomplete);
    },

    moveToReadyForTranslation: function() {
        this.currentRecord.setValue('state', this.states.Ready_For_Translation);
    },

    assignToFulfillers: function() {
        this.currentRecord.assignment_group = this.getLFSettings().localization_fulfiller_group;
    },

    assignToTranslationApprovers: function() {
        this.currentRecord.assignment_group = this.getLFSettings().translation_approver_group;
    },

    saveTranslatedFileContent: function(translatedXLIFF, fileNumber, tmsSourceLanguageCode, tmsTargetLanguageCode) {
        var documentContent = this.getDocumentContent();
        var content = documentContent["content"];
        var isError = false;
        try {
            this.utils.updateContentFromXLIFF(translatedXLIFF, content, tmsSourceLanguageCode, tmsTargetLanguageCode, fileNumber);
            documentContent["content"] = content;
            this.setDocumentContent(documentContent);
        } catch (e) {
            isError = true;
        }
        var additionalInfo = this.getAdditionalInfo();
        var hasConflicts = this.utils.hasConflicts(content);
        additionalInfo["conflict"] = hasConflicts;
        if (hasConflicts) {
            this.luaUtils.sendConflictEvent("TMS", "task");
        }
        additionalInfo["errorDetails"] = {
            "error": isError
        };
        this.setAdditionalInfo(additionalInfo);
        this.update();
        return {
            "isError": isError,
            "fileId": this.getSysId()
        };
    },

    getEmailSubFlowName: function() {
        return this.getLFSettings().email_subflow_name;
    },

    addWorkNotes: function(workNotes) {
        this.currentRecord.work_notes = workNotes;
    },

    updateLastPerformedAction: function(content, status) {
        var type;
        if (status === this.lfConstants.SUCCESS) {
            type = this.lfConstants.INFO_TYPE;
        } else if (status === this.lfConstants.ERROR) {
            type = this.lfConstants.ERROR_TYPE;
        }
        var additionalInfo = this.getAdditionalInfo();
        additionalInfo["lastActionPerformed"] = {
            "content": content,
            "type": type
        };
        if (!this.hasBulkTranslations()) {
            additionalInfo['errorDetails'] = {
                "error": status === this.lfConstants.ERROR
            };
        }
        this.addWorkNotes(content);
        this.setAdditionalInfo(additionalInfo);
        this.update();
    },

    setReadOnly: function(readOnly) {
        var additionalInfo = this.getAdditionalInfo();
        additionalInfo['readOnly'] = readOnly;
        this.setAdditionalInfo(additionalInfo);
    },

    setContextID: function(contextID) {
        var additionalInfo = this.getAdditionalInfo();
        additionalInfo['contextID'] = contextID;
        this.setAdditionalInfo(additionalInfo);
    },

    setTranslationAction: function(translationAction) {
        var additionalInfo = this.getAdditionalInfo();
        additionalInfo['translationAction'] = translationAction;
        this.setAdditionalInfo(additionalInfo);
    },

    checkIfAutoPublishEnabled: function() {
        var configuredWorkflow = this.getConfiguredWorkFlow();
        var workflows = this.lfConstants.WORKFLOWS;
        return (configuredWorkflow === workflows['AutoTranslation_AutoPublish'] || configuredWorkflow === workflows['BusinessApproval_AutoTranslation_AutoPublish']);
    },

    // For backward compatibility of Q to R
    showUIAction: function(internalName) {
        return this.utils.showUIAction(internalName);
    },

    createLocalizationTask: function(requestedItemIds, settings, isProjectEnabled) {
        try {
            var settingsJSON = JSON.parse(settings);
            new LFValidationUtils().validateCreateLFTaskParameters(requestedItemIds, settingsJSON, isProjectEnabled);
            var localizationProject = new LFRequestedItemUtils(requestedItemIds[0]).getLocalizationProjectSysId();
            var assignmentGroup = settingsJSON[this.lfConstants.SETTING_KEYS.LocalizationFulfillerGroup];
            var taskGr = new GlideRecord(this.tableName);
            taskGr.initialize();
            taskGr.setValue('project', localizationProject);
            taskGr.setValue('assignment_group', assignmentGroup);
            var groupGr = new GlideRecord('sys_user_group');
            groupGr.get(assignmentGroup);
            taskGr.setValue('assigned_to', groupGr.getValue("manager"));
            taskGr.setValue('settings', settings);
            taskGr.setValue('state', this.states.Open);
            taskGr.insert();

            var taskSysID = taskGr.getValue('sys_id');

            LFRequestedItemUtils.updateLocalizationRequestedItems(requestedItemIds, {
                localization_task: taskSysID
            });

            var taskUtils = new LFTaskUtils(taskSysID);
            taskUtils.moveToReadyForTranslation();
            taskUtils.update();

            return {
                "isSuccess": true,
                "sysId": taskSysID,
                "number": taskGr.getValue('number')
            };
        } catch (e) {
            this.logger.logError("Error Occurred while creating LF Task" + e);
        }

        var requestedItemNumbers = [];

        for (var idx = 0; idx &lt; requestedItemIds.length; idx++) {
            var requestedItemId = requestedItemIds[idx];
            var requestedItemUtils = new LFRequestedItemUtils(requestedItemId);
            if (requestedItemUtils.hasValidRecord()) {
                requestedItemNumbers.push(requestedItemUtils.getNumber());
                requestedItemUtils.moveToClosedIncomplete();
                var workNotes = gs.getMessage('Error while requesting translations.');
                requestedItemUtils.addWorkNotes(workNotes);
                requestedItemUtils.update();
            } else {
                requestedItemNumbers.push(requestedItemId);
            }
        }

        var errorMessage = gs.getMessage("Error occurred while creating task for {0} requested items.", requestedItemNumbers.join(","));
        return {
            "isSuccess": false,
            "errorMessage": errorMessage
        };
    },

    publishTranslations: function() {
        var isSuccess = true;
        try {
            if (this.hasBulkTranslations()) {
                var isPublishSuccessful = this._publishRelatedRequestedItems();
                if (isPublishSuccessful) {
                    this.addWorkNotes(gs.getMessage("Successfully published the translations."));
                    this.moveToClosedComplete();
                } else {
                    this.addWorkNotes(gs.getMessage("Error in publishing the translations."));
                    this.moveToClosedIncomplete();
                    isSuccess = false;
                }
            }
        } catch (error) {
            this.logger.logError("Error occurred while publishing translations in task " + this.currentRecord.getTaskNumber() + ". " + error);
            this.addWorkNotes(gs.getMessage("Error in publishing the translations."));
            this.moveToClosedIncomplete();
            isSuccess = false;
        }
        this.update();
        return isSuccess;
    },

    generateUrlForTaskNumbers: function(taskNumbers) {
        if (taskNumbers.length == 0) {
            return;
        }
        var tableName = this.tableName;
        var queryType = (taskNumbers.length == 1) ? '=' : 'IN';
        var url = "/" + tableName + '_list.do?sysparm_query=number' + queryType;
        for (var taskIdx = 0; taskIdx &lt; taskNumbers.length - 1; taskIdx++) {
            var taskNumber = taskNumbers[taskIdx];
            url += taskNumber + ",";
        }
        url += taskNumbers[taskIdx];
        return url;
    },

    getRelatedRequestedItemIdsFilterOutByState: function(state) {
        var requestedItemIds = [];
        var requestedItemGR = new GlideRecord("sn_lf_requested_item");
        requestedItemGR.addQuery("localization_task", this.getSysId());
        if (state) {
            requestedItemGR.addQuery("state", "!=", state);
        }
        requestedItemGR.query();
        while (requestedItemGR.next()) {
            var requestedItemId = requestedItemGR.getValue("sys_id");
            requestedItemIds.push(requestedItemId);
        }
        return requestedItemIds;
    },

    getTaskDetailsForTranslation: function() {
        if (this.hasBulkTranslations()) return;
        var status = new LFGenerateLocalizationInsights().getTranslationStatus(this.getDocumentContent());
        var statusLabel = this.lfConstants.TRANSLATION_STATUS[status];

        var taskAdditionalInfo = this.getAdditionalInfo();
        var error = false;
        var errorMessageDetails = {};
        if (taskAdditionalInfo.errorDetails) {
            error = taskAdditionalInfo.errorDetails.error;
            errorMessageDetails = taskAdditionalInfo.errorDetails.fieldLevelMessages;
        }
        return {
            "sysId": this.getSysId(),
            "state": this.getCurrentState(),
            "internalName": this.getArtifactInternalName(),
            "documentContent": this.getDocumentContent(),
            "sourceLanguage": this.getSourceLanguageCode(),
            "sourceLanguageLabel": this.getSourceLanguageName(),
            "targetLanguage": this.getTargetLanguageCode(),
            "targetLanguageLabel": this.getTargetLanguageName(),
            "artifactName": this.getArtifactName(),
            "statusLabel": statusLabel,
            "status": status,
            "error": error,
            "additionalInfo": errorMessageDetails
        };
    },

    getRelatedRequestedItemDetailsWithPagination: function(firstRow, lastRow) {
        var requestedItemDetails = {};
        var lfValidationUtils = new LFValidationUtils();
        var requestedItemGR = new GlideRecord("sn_lf_requested_item");
        requestedItemGR.addQuery("localization_task", this.getSysId());
        requestedItemGR.orderBy('number');
        if (lfValidationUtils.isFieldTypeNumber(firstRow) &amp;&amp; lfValidationUtils.isFieldTypeNumber(lastRow)) {
            requestedItemGR.chooseWindow(firstRow, lastRow);
        }
        requestedItemGR.query();
        while (requestedItemGR.next()) {
            var requestedItemUtils = new LFRequestedItemUtils(requestedItemGR);
            requestedItemDetails[requestedItemUtils.getNumber()] = {
                "sysId": requestedItemUtils.getSysId(),
                "state": requestedItemUtils.getCurrentState(),
                "internalName": requestedItemUtils.getArtifactConfigInternalName(),
                "documentContent": requestedItemUtils.getDocumentContent(),
                "sourceLanguage": requestedItemUtils.getSourceLanguageCode(),
                "sourceLanguageLabel": requestedItemUtils.getSourceLanguageName(),
                "targetLanguage": requestedItemUtils.getTargetLanguageCode(),
                "targetLanguageLabel": requestedItemUtils.getTargetLanguageName(),
                "artifactName": requestedItemUtils.getArtifactName(),
                "statusLabel": requestedItemUtils.getCurrentStatusName(),
                "status": requestedItemUtils.getCurrentStatus(),
                "additionalInfo": requestedItemUtils.getAdditionalInfo(),
                "error": requestedItemUtils.isError()
            };
        }
        return requestedItemDetails;
    },

    getRelatedRequestedItemDetailsCountByConflict: function() {
        var conflictItemsCount = 0;
        var requestedItemGA = new GlideAggregate("sn_lf_requested_item");
        requestedItemGA.addAggregate('COUNT', 'conflict');
        requestedItemGA.groupBy('conflict');
        requestedItemGA.addQuery('localization_task', this.getSysId());
        requestedItemGA.addQuery('conflict', true);
        requestedItemGA.query();
        if (requestedItemGA.next()) {
            conflictItemsCount = requestedItemGA.getAggregate('COUNT', 'conflict');
        }
        return conflictItemsCount;
    },

    getRelatedRequestedItemDetailsCountByStatus: function() {
        var requestedItemsCount = {};
        var requestedItemGA = new GlideAggregate("sn_lf_requested_item");
        requestedItemGA.addAggregate('COUNT', 'status');
        requestedItemGA.groupBy('status');
        requestedItemGA.addQuery("localization_task", this.getSysId());
        requestedItemGA.query();
        while (requestedItemGA.next()) {
            var translationStatus = requestedItemGA.getValue("status");
            requestedItemsCount[translationStatus] = requestedItemGA.getAggregate('COUNT', 'status');
        }
        return requestedItemsCount;
    },

    getRelatedRequestedItemCount: function() {
        var requestedItemsCount = 0;
        var requestedItemGA = new GlideAggregate("sn_lf_requested_item");
        requestedItemGA.addAggregate('COUNT', 'count');
        requestedItemGA.addQuery("localization_task", this.getSysId());
        requestedItemGA.query();
        if (requestedItemGA.next()) {
            requestedItemsCount = requestedItemGA.getAggregate('COUNT', 'count');
        }
        return requestedItemsCount;
    },

    getTMSProjectInfo: function() {
        var additionalInfo = this.getAdditionalInfo();
        return additionalInfo["TMS"] || {};
    },

    saveTMSProjectInfo: function(projectInfo) {
        var additionalInfo = this.getAdditionalInfo();
        additionalInfo["TMS"] = projectInfo;
        this.setAdditionalInfo(additionalInfo);
        this.update();
    },

    getTMSAdditionalInfo: function() {
        var lfSettings = this.getLFSettings();
        return (Object.keys(lfSettings).length &gt; 0) ? lfSettings.tms_additional_info : {};
    },

    hasBulkTranslations: function() {
        return this.getArtifactSysId() ? false : true;
    },

    hasLargeContentToTranslate: function() {
        if (this.hasBulkTranslations()) {
            return this.getRelatedRequestedItemCount() &gt; parseInt(gs.getProperty("com.glide.sn_lf.async.task_size", 1));
        }
        return false;
    },

    processTranslationsInAsyncMode: function(action, mode, additionalInfo) {
        var supportedTranslationModes = [this.lfConstants.AUTO, this.lfConstants.MANUAL];
        var supportedTranslationActions = ["machine_translate", "send_via_email", "send_to_tms", "retrieve_translations"];
        if (supportedTranslationActions.indexOf(action) == -1) {
            new LFExceptionMapper("UNSUPPORTED_TRANSLATION_ACTION").throwException();
        }
        if (supportedTranslationModes.indexOf(mode) == -1) {
            new LFExceptionMapper("UNSUPPORTED_TRANSLATION_MODE").throwException();
        }
        var inputs = this._getInputs(action, mode, additionalInfo);
        try {
            var flowResult = sn_fd.FlowAPI.getRunner().subflow('global.translate_requested_items').inBackground().withInputs(inputs).run();
            this.setContextID(flowResult.getContextId());
            this.setTranslationAction(action);
            var isError = false;
            this.moveToInProgress();
        } catch (e) {
            isError = true;
            this.moveToErrorInTranslation();
        }
        this.setReadOnly(!isError);
        var message = this.getTranslationMessage(action, isError);
        this.updateLastPerformedAction(message, isError ? this.lfConstants.ERROR : this.lfConstants.SUCCESS);
        return {
            "isError": isError,
            "message": message
        };
    },

    _getInputs: function(action, mode, additionalInfo) {
        return {
            'task_id': this.getSysId(),
            'action': action,
            'mode': mode,
            'additional_info': additionalInfo
        };
    },

    getTranslationMessage: function(action, isError) {
        var lfSettings = this.getLFSettings();
        switch (action) {
            case "machine_translate":
                var translator = lfSettings.translator_name;
                return isError ? gs.getMessage("Translation request using the {0} translator has failed.", translator) : gs.getMessage("Translation request using the {0} translator is in progress.", translator);
            case "send_via_email":
                return isError ? gs.getMessage("Translation request using the email has failed.") : gs.getMessage("Translation request using the email is in progress.");
            case "send_to_tms":
                var tmsName = lfSettings.tms_name;
                return isError ? gs.getMessage("Translation request using the {0} TMS has failed.", tmsName) : gs.getMessage("Translation request using the {0} TMS is in progress.", tmsName);
            case "retrieve_translations":
                tmsName = lfSettings.tms_name;
                return isError ? gs.getMessage("Retrieval of translations using the {0} TMS has failed.", tmsName) : gs.getMessage("Retrieval of translations using the {0} TMS is in progress.", tmsName);
        }
    },

    getRelatedRequestedItemDetails: function() {
        var requestedItemDetails = [];
        var requestedItemGR = new GlideRecord("sn_lf_requested_item");
        requestedItemGR.addQuery("localization_task", this.getSysId());
        requestedItemGR.query();
        while (requestedItemGR.next()) {
            var requestedItemUtils = new LFRequestedItemUtils(requestedItemGR);
            requestedItemDetails.push({
                "sysId": requestedItemUtils.getSysId(),
                "targetLanguageCode": requestedItemUtils.getTargetLanguageCode()
            });
        }
        return requestedItemDetails;
    },

    getLocalizationProject: function() {
        return this.currentRecord.getValue('project');
    },

    hasLocalizationProject: function() {
        var localizationProject = this.getLocalizationProject();
        return (localizationProject &amp;&amp; localizationProject != "") ? true : false;
    },

    getLUADetails: function() {
        var artifacts = {};
        var targetLanguages = {};
        var sourceLanguages = {};
        var response = {};
        if (this.hasBulkTranslations()) {
            var gr = new GlideAggregate('sn_lf_requested_item');
            gr.addAggregate('count');
            gr.groupBy('artifact_config');
            gr.groupBy('target_language');
            gr.groupBy('source_language');
            gr.addQuery('localization_task', this.getSysId());
            gr.query();
            while (gr.next()) {
                var artifactId = gr.getValue('artifact_config');
                if (!artifacts.hasOwnProperty(artifactId)) {
                    var artifact = gr.artifact_config.getRefRecord().getValue('internal_name');
                    artifacts[artifactId] = artifact;
                }
                var targetLanguageId = gr.getValue('target_language');
                if (!targetLanguages.hasOwnProperty(targetLanguageId)) {
                    var targetLanguage = gr.target_language.getRefRecord().getValue('id');
                    targetLanguages[targetLanguageId] = targetLanguage;
                }
                var sourceLanguageId = gr.getValue('source_language');
                if (!sourceLanguages.hasOwnProperty(sourceLanguageId)) {
                    var sourceLanguage = gr.source_language.getRefRecord().getValue('id');
                    sourceLanguages[sourceLanguageId] = sourceLanguage;
                }
            }
        } else {
            artifacts['artifactSysId'] = this.getArtifactInternalName();
            targetLanguages['targetLanguage'] = this.getTargetLanguageCode();
            sourceLanguages['sourceLanguage'] = this.getSourceLanguageCode();
        }

        var artifactNames = [];
        var artifactKeys = Object.keys(artifacts);
        for (var idx = 0; idx &lt; artifactKeys.length; idx++) {
            artifactNames.push(artifacts[artifactKeys[idx]]);
        }
        var targetLanguageCodes = [];
        var targetLanguageKeys = Object.keys(targetLanguages);
        for (idx = 0; idx &lt; targetLanguageKeys.length; idx++) {
            targetLanguageCodes.push(targetLanguages[targetLanguageKeys[idx]]);
        }
        var sourceLanguageCodes = [];
        var sourceLanguageKeys = Object.keys(sourceLanguages);
        for (idx = 0; idx &lt; sourceLanguageKeys.length; idx++) {
            sourceLanguageCodes.push(sourceLanguages[sourceLanguageKeys[idx]]);
        }
        response['artifacts'] = artifactNames.join(',');
        response['targetLanguages'] = targetLanguageCodes.join(',');
        response['sourceLanguages'] = sourceLanguageCodes.join(',');

        return response;
    },

    _publishRelatedRequestedItems: function() {
        var isPublishSuccessful = true;
        var updateSetManager = null;
        var isUpdateSetRequired = this._isUpdateSetRequired();
        if (isUpdateSetRequired) {
            updateSetManager = new LFUpdateSetManager(this.lfConstants.TASK, this.getTaskNumber());
        }
        var requestedItemDetailsList = this.getRelatedRequestedItemDetails();

        for (var idx = 0; idx &lt; requestedItemDetailsList.length; idx++) {
            var requestedItemDetails = requestedItemDetailsList[idx];
            try {
                var requestedItemUtils = new LFRequestedItemUtils(requestedItemDetails.sysId);
                if (updateSetManager != null) {
                    var additionalParameters = requestedItemUtils.getDocumentContent()["additionalParameters"];
                    var currentArtifactScope = (additionalParameters &amp;&amp; additionalParameters.scope) ? additionalParameters.scope : "global";
                    // Create dedicated update set in current artifact scope to save translations
                    updateSetManager.switchToUpdateSetInScope(currentArtifactScope);
                }
                // Publish related localization requested items
                var sourceOfRequest = this.getPublishSourceForLUA() || this.lfConstants.MANUAL;
                var isSuccess = requestedItemUtils.publishLocalizationRequestedItem(sourceOfRequest, this.getTaskNumber());
                if (!isSuccess) {
                    isPublishSuccessful = false;
                }
            } catch (e) {
                this.logger.logError("Error Occurred while publishing Localization Requested Item: " + requestedItemDetails.sysId + ". " + e);
                isPublishSuccessful = false;
            }
        }
        if (isUpdateSetRequired) {
            // Mark update set as complete
            updateSetManager.markUpdateSetsAsComplete();
            // Add previous update set as default in session
            updateSetManager.switchToPreviousUpdateSet();
        }
        return isPublishSuccessful;
    },

    _isUpdateSetRequired: function() {
        // Checking if current LF Task has LRITMs other than KB articles as they do not get persisted in update set
        var filterCriteria = "localization_task=" + this.getSysId() + "^artifact_config.internal_name!=knowledge";
        return LFRequestedItemUtils.getRequestedItemsCountByEncodedQuery(filterCriteria) &gt; 0;
    },

    // Below methods are for backward compatibility of Q/R to R/S
    sendTranslationEvent: function(mode, translationInfo, translationType) {
        this.luaUtils.sendTranslationEvent(mode, translationInfo, translationType);
    },

    publishLocalizationTasks: function(tableName, taskSysId) {
        //retaining tableName as an argument to honor the Q signature
        var isSuccess = new LFTaskUtils(taskSysId).publishLocalizationTask();
        if (!isSuccess) {
            new LFExceptionMapper("PUBLISH_TASK_FAILED").throwException();
        }
    },

    publishLocalizationTask: function() {
        var isPublishSuccessful = true;
        var updateSetManager = new LFUpdateSetManager(this.lfConstants.TASK, this.getTaskNumber());
        // Switch to dedicated update set in current scope (global) to save translations
        updateSetManager.switchToUpdateSetInScope('global');

        try {
            var internalName = this.getArtifactInternalName();
            var parms = {};
            var readSaveScriptUtils = new LFReadSaveScriptUtils(this.lfConstants.TASK, this.getTaskNumber());
            parms[readSaveScriptUtils.SAVE_SCRIPT_INPUTS.documentContent] = this.getDocumentContent();
            parms[readSaveScriptUtils.SAVE_SCRIPT_INPUTS.language] = this.getTargetLanguageCode();
            parms[readSaveScriptUtils.SAVE_SCRIPT_INPUTS.taskId] = this.getSysId();
            parms[readSaveScriptUtils.SAVE_SCRIPT_INPUTS.sysId] = this.getArtifactSysId();
            parms["sourceOfRequest"] = this.getPublishSourceForLUA() || this.lfConstants.MANUAL;
            parms["hasProject"] = this.hasLocalizationProject();
            readSaveScriptUtils.publishTranslations(internalName, parms);
        } catch (e) {
            this.logger.logError("Error Occurred while publishing LF task " + this.currentRecord.getTaskNumber() + "for table " + this.getTableName() + ". " + e);
            this.addWorkNotes(gs.getMessage("Error in publishing the translations."));
            this.update();
            isPublishSuccessful = false;
        }

        // Mark update set as complete
        updateSetManager.markUpdateSetsAsComplete();
        // Add previous update set as default in session
        updateSetManager.switchToPreviousUpdateSet();
        return isPublishSuccessful;
    },

    type: 'LFTaskUtils'
};]]&gt;&lt;/script&gt;
        &lt;sys_class_name&gt;sys_script_include&lt;/sys_class_name&gt;
        &lt;sys_created_by&gt;admin&lt;/sys_created_by&gt;
        &lt;sys_created_on&gt;2020-07-17 12:30:21&lt;/sys_created_on&gt;
        &lt;sys_id&gt;1408353d53421010200bddeeff7b12ce&lt;/sys_id&gt;
        &lt;sys_mod_count&gt;55&lt;/sys_mod_count&gt;
        &lt;sys_name&gt;LFTaskUtils&lt;/sys_name&gt;
        &lt;sys_package display_value="Localization Framework" source="com.glide.localization_framework"&gt;a4dd193447720210cd4e1ce4316d4312&lt;/sys_package&gt;
        &lt;sys_policy/&gt;
        &lt;sys_scope display_value="Global"&gt;global&lt;/sys_scope&gt;
        &lt;sys_update_name&gt;sys_script_include_1408353d53421010200bddeeff7b12ce&lt;/sys_update_name&gt;
        &lt;sys_updated_by&gt;admin&lt;/sys_updated_by&gt;
        &lt;sys_updated_on&gt;2023-09-04 18:37:39&lt;/sys_updated_on&gt;
    &lt;/sys_script_include&gt;
&lt;/record_update&gt;
</payload>
        <sys_class_name>sys_metadata_link</sys_class_name>
        <sys_created_by>admin</sys_created_by>
        <sys_created_on>2024-09-21 08:10:35</sys_created_on>
        <sys_id>5190b4d583b01210c6695855eeaad357</sys_id>
        <sys_mod_count>0</sys_mod_count>
        <sys_name>LFTaskUtils</sys_name>
        <sys_package display_value="Now Utils" source="x_938076_now_utils">b208a7c083689e50c6695855eeaad3d2</sys_package>
        <sys_policy/>
        <sys_scope display_value="Now Utils">b208a7c083689e50c6695855eeaad3d2</sys_scope>
        <sys_update_name>sys_metadata_link_5190b4d583b01210c6695855eeaad357</sys_update_name>
        <sys_updated_by>admin</sys_updated_by>
        <sys_updated_on>2024-09-21 08:10:35</sys_updated_on>
        <tablename>sys_script_include</tablename>
    </sys_metadata_link>
</record_update>
