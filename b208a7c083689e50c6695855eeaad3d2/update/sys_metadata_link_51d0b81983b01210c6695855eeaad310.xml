<?xml version="1.0" encoding="UTF-8"?><record_update table="sys_metadata_link">
    <sys_metadata_link action="INSERT_OR_UPDATE">
        <directory>update</directory>
        <documentkey>1eb28630d733210092610eca5e61034c</documentkey>
        <payload>&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;record_update table="sys_script_include"&gt;
    &lt;sys_script_include action="INSERT_OR_UPDATE"&gt;
        &lt;access&gt;public&lt;/access&gt;
        &lt;active&gt;true&lt;/active&gt;
        &lt;api_name&gt;sn_appauthor.ScopedAppDependencyChecker&lt;/api_name&gt;
        &lt;caller_access/&gt;
        &lt;client_callable&gt;false&lt;/client_callable&gt;
        &lt;description/&gt;
        &lt;name&gt;ScopedAppDependencyChecker&lt;/name&gt;
        &lt;script&gt;&lt;![CDATA[var ScopedAppDependencyChecker = Class.create();
ScopedAppDependencyChecker.prototype = {
    initialize: function() {
    },

	/**
	 * Returns comma-separated string of inaccessible apps (pairs of *app scope*:*version*) if any
	 */
	checkInaccessibleDeps: /*String*/ function(appId) {
		// create comma-separated list of appScope:appVer dependency pairs to be sent to server for validation
		var depGR = new GlideRecord("sys_package_dependency_m2m");
		depGR.addQuery("sys_package", appId);
		depGR.addQuery("dependency.sys_class_name", "sys_app"); // custom apps only
		depGR.query();
		var depsToCheck = [];
		while (depGR.next()) {
			if (!this._isInstalledByPlugin(depGR)) {
				var depAppScope = depGR.dependency.scope;
				var minReqVersion = depGR.min_version;
				var depAppId = depGR.dependency;
				if (depAppScope == 'global') {
					// put the sys_id into the check string for identifying the app for global app
					depsToCheck.push(depAppScope + ":" + minReqVersion + ":" + depAppId);
				} else
					depsToCheck.push(depAppScope + ":" + minReqVersion);
			}
		}

		if (depsToCheck.length == 0) {
			gs.info("No dependencies found for app {0}", appId);
			return ""; // no dependencies found
		}
		
		// comma-separated list of appScope:appVer pairs of inaccessible dependency apps		
		var inaccessibleAppsStr = "";
		var depsToCheckStr = depsToCheck.join(",");
		gs.info("Checking app {0} accessibility of dependencies: {1}", appId, depsToCheckStr);
		try {
			var inaccessibleApps = [];
			// sending request to server
			var result = new ScopedAppRepoRequest("checkaccess")
				.setParameter("sysparm_apps", depsToCheckStr)
				.getJSON();			
			if (result &amp;&amp; result.inaccessible) {
				for (var i = 0; i &lt; result.inaccessible.length; i++) {
					var appScope = result.inaccessible[i].app_scope;
					var minReqVer = result.inaccessible[i].min_req_version;
					var inAccessAppId = null;
					if (result.inaccessible[i].hasOwnProperty("app_id"));
						inAccessAppId = result.inaccessible[i].app_id;

					// check if we can find the app's name on the local author instance, if we can print out the app name instead of scope
					if (inAccessAppId) {
						var appGR = new GlideRecord("sys_package");
						appGR.addQuery("sys_id", inAccessAppId);
						appGR.query();
						if (appGR.next())
							inaccessibleApps.push(appGR.name + " v" + minReqVer + " id: " + inAccessAppId);
					} else
						inaccessibleApps.push(appScope + " v" + minReqVer + (inAccessAppId != null ? " " + inAccessAppId : ""));
				}
			}
			if (inaccessibleApps)
				inaccessibleAppsStr = inaccessibleApps.join(",");
			gs.info("Inaccessible dependencies: " + inaccessibleAppsStr);
		} catch (e) {
			gs.error("Can't check accessibility of dependencies " + ": " + e);
		}
		return inaccessibleAppsStr;
	},
	
	_isInstalledByPlugin /*boolean*/: function(/*GlideRecord*/ depGR) {
		var scope =  depGR.dependency.scope.toString();
		if (scope == "global") // sys_app installed by plugin can't have global scope
			return false;

		var vPlugin = new GlideRecord("v_plugin");
		vPlugin.addQuery("scope", scope);
		vPlugin.query();
		
		return vPlugin.hasNext();
	},
	
    type: 'ScopedAppDependencyChecker'
};]]&gt;&lt;/script&gt;
        &lt;sys_class_name&gt;sys_script_include&lt;/sys_class_name&gt;
        &lt;sys_created_by&gt;admin&lt;/sys_created_by&gt;
        &lt;sys_created_on&gt;2014-10-14 04:29:21&lt;/sys_created_on&gt;
        &lt;sys_id&gt;1eb28630d733210092610eca5e61034c&lt;/sys_id&gt;
        &lt;sys_mod_count&gt;10&lt;/sys_mod_count&gt;
        &lt;sys_name&gt;ScopedAppDependencyChecker&lt;/sys_name&gt;
        &lt;sys_package display_value="Scoped App Author" source="sn_appauthor"&gt;893ea311d71321004f6a0eca5e6103e6&lt;/sys_package&gt;
        &lt;sys_policy&gt;protected&lt;/sys_policy&gt;
        &lt;sys_scope display_value="Scoped App Author"&gt;893ea311d71321004f6a0eca5e6103e6&lt;/sys_scope&gt;
        &lt;sys_update_name&gt;sys_script_include_1eb28630d733210092610eca5e61034c&lt;/sys_update_name&gt;
        &lt;sys_updated_by&gt;admin&lt;/sys_updated_by&gt;
        &lt;sys_updated_on&gt;2017-02-03 20:56:17&lt;/sys_updated_on&gt;
    &lt;/sys_script_include&gt;
&lt;/record_update&gt;
</payload>
        <sys_class_name>sys_metadata_link</sys_class_name>
        <sys_created_by>admin</sys_created_by>
        <sys_created_on>2024-09-21 08:11:41</sys_created_on>
        <sys_id>51d0b81983b01210c6695855eeaad310</sys_id>
        <sys_mod_count>0</sys_mod_count>
        <sys_name>ScopedAppDependencyChecker</sys_name>
        <sys_package display_value="Now Utils" source="x_938076_now_utils">b208a7c083689e50c6695855eeaad3d2</sys_package>
        <sys_policy/>
        <sys_scope display_value="Now Utils">b208a7c083689e50c6695855eeaad3d2</sys_scope>
        <sys_update_name>sys_metadata_link_51d0b81983b01210c6695855eeaad310</sys_update_name>
        <sys_updated_by>admin</sys_updated_by>
        <sys_updated_on>2024-09-21 08:11:41</sys_updated_on>
        <tablename>sys_script_include</tablename>
    </sys_metadata_link>
</record_update>
