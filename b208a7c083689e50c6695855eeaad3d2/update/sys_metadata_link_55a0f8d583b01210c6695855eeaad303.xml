<?xml version="1.0" encoding="UTF-8"?><record_update table="sys_metadata_link">
    <sys_metadata_link action="INSERT_OR_UPDATE">
        <directory>update</directory>
        <documentkey>16fdcb2637101200455726877e41f188</documentkey>
        <payload>&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;record_update table="sys_script_include"&gt;
    &lt;sys_script_include action="INSERT_OR_UPDATE"&gt;
        &lt;access&gt;package_private&lt;/access&gt;
        &lt;active&gt;true&lt;/active&gt;
        &lt;api_name&gt;global.PPMCostManager&lt;/api_name&gt;
        &lt;caller_access/&gt;
        &lt;client_callable&gt;false&lt;/client_callable&gt;
        &lt;description/&gt;
        &lt;name&gt;PPMCostManager&lt;/name&gt;
        &lt;script&gt;&lt;![CDATA[var PPMCostManager = Class.create();

PPMCostManager.getTotalEstimated = function(entityRecords) {
    var cost = 0.0;
    var capexCost = 0.0;
    var opexCost = 0.0;
	var costProject = 0.0;
	var capexProjectCurrency = 0.0;
	var opexProjectCurrency = 0.0;
	var costDemand = 0.0;
	var capexDemandCurrency = 0.0;
	var opexDemandCurrency = 0.0;
    var cpb;
    var hasNegativeCapex = false,
        hasNegativeOpex = false;
    while ( entityRecords.next() ) {
        cpb = new CostPlanBreakdown(entityRecords);
        cost += cpb.cost();
        costProject += cpb.costProjectCurrency();
        costDemand  += cpb.costDemandCurrency();
        if ( cpb.expenseType() === 'capex' ) {
            capexCost += cpb.cost();
            if (cpb.cost() &lt; 0) hasNegativeCapex = true;
            capexProjectCurrency += cpb.costProjectCurrency();
            capexDemandCurrency  += cpb.costDemandCurrency();
        } else {
            opexCost += cpb.cost();
            if (cpb.cost() &lt; 0) hasNegativeOpex = true;
            opexProjectCurrency += cpb.costProjectCurrency();
            opexDemandCurrency  += cpb.costDemandCurrency();
        }
    }
    var costs = {};
    costs.total = cost;
    costs.capex = capexCost;
    costs.opex = opexCost;
    costs.totalProjectCurrency = costProject;
    costs.capexProjectCurrency = capexProjectCurrency;
    costs.opexProjectCurrency = opexProjectCurrency;
    costs.totalDemandCurrency = costDemand;
    costs.capexDemandCurrency = capexDemandCurrency;
    costs.opexDemandCurrency = opexDemandCurrency;
    costs.hasNegativeCapex = hasNegativeCapex;
    costs.hasNegativeOpex = hasNegativeOpex;
    return costs;
};

PPMCostManager.getBudgetTarget = function(entityRecords) {
    var target = 0.0;
    var capexTarget = 0.0;
    var opexTarget  = 0.0;
    var cbp;
    while ( entityRecords.next() ) {
        cbp = new CostPlanBreakdown(entityRecords);      
        target += cbp.budget();
        if(cbp.expenseType() == "capex")
            capexTarget += cbp.budget();
        else
            opexTarget += cbp.budget();
    }
    var response = { target: target, capex_target: capexTarget, opex_target: opexTarget};
    //gs.info("getBudgetTarget: " + (new JSON()).encode(response));
    return response;
};

PPMCostManager.getTotalTarget = function(entityRecords) {
    var target = 0.0;
    var capexTarget = 0.0;
    var opexTarget  = 0.0;
    var cbp;
    while ( entityRecords.next() ) {
        cbp = new CostPlanBreakdown(entityRecords);      
        target += cbp.target();
        if(cbp.expenseType() == "capex")
            capexTarget += cbp.target();
        else
            opexTarget += cbp.target();
    }
    var response = { total: target, capex: capexTarget, opex: opexTarget};
    //gs.info("getTarget: " + (new JSON()).encode(response));
    return response;
};

PPMCostManager.findTotalEstimatedCostOfPortfolio = function(portfolioId, fiscalYear) {
    var portfolioRecords = PPMRollupRecordFinder.findEntityRollupRecordsForYear('portfolio', portfolioId, fiscalYear);
    gs.log('&gt;&gt;&gt;&gt;Find Records for '+portfolioId + ' '+fiscalYear);
    return PPMCostManager.getTotalEstimated(portfolioRecords);
};

PPMCostManager.findTotalEstimatedCostOfEntity = function(entity, entityId, fiscalYear) {
    var entityRecords = PPMRollupRecordFinder.findEntityRollupRecordsForYear(entity, entityId, fiscalYear);
    gs.log('&gt;&gt;&gt;&gt;Find Records for '+entityId + ' '+fiscalYear+' '+entityRecords.getRowCount());
    return PPMCostManager.getTotalEstimated(entityRecords);
};

PPMCostManager.findTotalTargetOfEntity = function(entity, entityId, fiscalYear) {
    var entityRecords = PPMRollupRecordFinder.findEntityRollupRecordsForYear(entity, entityId, fiscalYear);
    return PPMCostManager.getTotalTarget(entityRecords);
};

PPMCostManager.findTargetOfEntity = function(entity, entityId, fiscalPeriod) {
    var entityRecord = PPMRollupRecordFinder.findRollupRecordForEntity(entity, entityId, fiscalPeriod);
    return PPMCostManager.getTotalTarget(entityRecord);
};

PPMCostManager.findTotalEstimatedCostForEntity = function(entity, entityId, fiscalPeriod) {
    // Ideally the Estimated Cost should only include the tasks that are included in the budget for that entity
    var projectFunding = new PPMProjectFunding();
    var tasksIncludedInTheBudget = projectFunding.taskListForEntity(entity, entityId, fiscalPeriod, "planned");
    var entityRecords = PPMRollupRecordFinder.findEntityRecordsForFiscalPeriod(entity, entityId, fiscalPeriod, tasksIncludedInTheBudget);
    //gs.info("Count of entityRecords for findTotalEstimatedCostForEntity: " + entityRecords.getRowCount());
    return PPMCostManager.getTotalEstimated(entityRecords);
};

PPMCostManager.findTotalBudgetTargetForEntity = function(entity, entityId, fiscalPeriod) {
    // Ideally the Estimated Cost should only include the tasks that are included in the budget for that entity
    var projectFunding = new PPMProjectFunding();
    var tasksIncludedInTheBudget = projectFunding.taskListForEntity(entity, entityId, fiscalPeriod, "planned");
    var entityRecords = PPMRollupRecordFinder.findEntityRecordsForFiscalPeriod(entity, entityId, fiscalPeriod, tasksIncludedInTheBudget);
    //gs.info("Count of entityRecords for findTotalEstimatedCostForEntity: " + entityRecords.getRowCount());
    return PPMCostManager.getBudgetTarget(entityRecords);
};


PPMCostManager.getTotalAllocated = function(entityRecords) {
    var allocated = 0.0;
    var capexAllocated = 0.0;
    var opexAllocated  = 0.0;
    var cbp;
    while ( entityRecords.next() ) {
        cbp = new CostPlanBreakdown(entityRecords);      
        allocated += cbp.allocated();
        if(cbp.expenseType() == "capex")
            capexAllocated += cbp.allocated();
        else
            opexAllocated += cbp.allocated();
    }
    return { allocated: allocated, capex_allocated: capexAllocated, opex_allocated: opexAllocated};
};

PPMCostManager.getTotalBudget = function(entityRecords) {
    var budget = 0.0;
    var pf;
    while ( entityRecords.next() ) {
        pf = new ProjectFunding(entityRecords);      
        budget += pf.budget();
    }
    return budget;
};

PPMCostManager.findTotalBudgetForEntity = function(entity, entityId, fiscalPeriod) {
    // Ideally the Budget Amount should only include the tasks that are allocated for that entity
    var projectFunding = new PPMProjectFunding();
    var tasksAllocated = projectFunding.taskListForEntity(entity, entityId, fiscalPeriod, "allocated");
    var entityRecords = PPMRollupRecordFinder.findEntityRecordsForFiscalPeriod(entity, entityId, fiscalPeriod, tasksAllocated);
    //gs.info("Count of entityRecords for findTotalBudgetForEntity: " + entityRecords.getRowCount());
    return PPMCostManager.getTotalBudget(entityRecords);
};

PPMCostManager.findTotalActualForEntity = function(entity, entityId, fiscalPeriod) {
    // Ideally the Expense Amount should only include the tasks that are allocated for that entity
    var projectFunding = new PPMProjectFunding();
    var tasksAllocated = projectFunding.taskListForEntity(entity, entityId, fiscalPeriod, "allocated");
    var expenseRecords = PPMRollupRecordFinder.findExpenseRecords(tasksAllocated);
    //gs.info("Count of expenseRecords for findTotalActualForEntity: " + expenseRecords.getRowCount());
    var actual = 0.0;
    while ( expenseRecords.next() ) {
        actual += parseFloat(expenseRecords.getValue('amount'));
    }
    return actual;
};
PPMCostManager.getBudgetOrEstimatedCostForEntity =  function(entity, entityId, fiscalYear){
    var projectFunding = new PPMProjectFunding();
    var entityFundingRecord = projectFunding.fundingRecordForEntity(entity, entityId, fiscalYear);
    var capexBudget = 0.0;
    var opexBudget = 0.0;
    var budget = 0.0;
	var capexBudgetProCurr = 0.0;
    var opexBudgetProCurr = 0.0;
    var budgetProCurr = 0.0;
	var capexBudgetDemCurr = 0.0;
    var opexBudgetDemCurr = 0.0;
    var budgetDemCurr = 0.0;
    if(entityFundingRecord.isValidRecord()){
        budget = entityFundingRecord.budget();
        capexBudget = entityFundingRecord.capexBudget();
        opexBudget = entityFundingRecord.opexBudget();
		budgetProCurr = entityFundingRecord.budgetProjectCurrency();
		capexBudgetProCurr = entityFundingRecord.capexBudgetProjectCurrency();
		opexBudgetProCurr = entityFundingRecord.opexBudgetProjectCurrency();
		capexBudgetDemCurr = entityFundingRecord.capexBudgetDemandCurrency();
		opexBudgetDemCurr = entityFundingRecord.opexBudgetDemandCurrency();
		budgetDemCurr = entityFundingRecord.budgetDemandCurrency();

        return { total: budget, capex: capexBudget, opex: opexBudget, totalProjectCurrency: budgetProCurr, capexProjectCurrency: capexBudgetProCurr, opexProjectCurrency: opexBudgetProCurr, totalDemandCurrency: budgetDemCurr, capexDemandCurrency: capexBudgetDemCurr, opexDemandCurrency: opexBudgetDemCurr};
    }
    return PPMCostManager.findTotalEstimatedCostOfEntity(entity, entityId, fiscalYear);
};

 // APIes for Report Widgets - Budget and Allocated
 PPMCostManager.findBudgetOfEntity = function(entity, entityId, fiscalPeriod) {
    // Get from the Cost Plan Breakdown
    var rollups = PPMRollupRecordFinder.findRollupRecordForEntity(entity, entityId, fiscalPeriod);
    var response = {budget: 0.0, capex_budget: 0.0, opex_budget: 0.0};
    while(rollups.next()) {
        var breakdown = new CostPlanBreakdown(rollups);
        response.budget += breakdown.budget();
        if(breakdown.expenseType() == 'capex')
            response.capex_budget += breakdown.budget();
        if(breakdown.expenseType() == 'opex')
            response.opex_budget += breakdown.budget();
    }
    //gs.info("Return of findBudgetOfEntity: " + (new JSON()).encode(response));
    return response;
 };

 PPMCostManager.findTotalAllocatedOfEntity = function(entity, entityId, fiscalYear) {
    // Get from the Cost Plan Breakdown
    var rollups = PPMRollupRecordFinder.findEntityRollupRecordsForYear(entity, entityId, fiscalYear);
    var response = {allocated: 0.0, capex_allocated: 0.0, opex_allocated: 0.0};
    while(rollups.next()) {
        var breakdown = new CostPlanBreakdown(rollups);
        response.allocated += breakdown.allocated();
        if(breakdown.expenseType() == 'capex')
            response.capex_allocated += breakdown.allocated();
        if(breakdown.expenseType() == 'opex')
            response.opex_allocated += breakdown.allocated();
    }
    //gs.info("Return of findTotalAllocatedOfEntity: " + (new JSON()).encode(response));
    return response;
 };

 PPMCostManager.findAllocatedOfEntity = function(entity, entityId, fiscalPeriod) {
    // Get from the Cost Plan Breakdown
    var rollups = PPMRollupRecordFinder.findRollupRecordForEntity(entity, entityId, fiscalPeriod);
    var response = {allocated: 0.0, capex_allocated: 0.0, opex_allocated: 0.0};
    while(rollups.next()) {
        var breakdown = new CostPlanBreakdown(rollups);
        response.allocated += breakdown.allocated();
        if(breakdown.expenseType() == 'capex')
            response.capex_allocated += breakdown.allocated();
        if(breakdown.expenseType() == 'opex')
            response.opex_allocated += breakdown.allocated();
    }
    //gs.info("Return of findAllocatedOfEntity: " + (new JSON()).encode(response));
    return response;
 };

 PPMCostManager.findTotalActualOfEntity = function(entity, entityId, fiscalYear) {
    var rollups = PPMRollupRecordFinder.findEntityRollupRecordsForYear(entity, entityId, fiscalYear);
    var response = {actual: 0.0, capex_actual: 0.0, opex_actual: 0.0};
    while(rollups.next()) {
        var breakdown = new CostPlanBreakdown(rollups);
        response.actual += breakdown.actual();
        if(breakdown.expenseType() == 'capex')
            response.capex_actual += breakdown.actual();
        if(breakdown.expenseType() == 'opex')
            response.opex_actual += breakdown.actual();
    }
    //gs.info("Return of findTotalActualOfEntity: " + (new JSON()).encode(response));
    return response;
     
 };

 PPMCostManager.findActualOfEntity = function(entity, entityId, fiscalPeriod) {
    var rollups = PPMRollupRecordFinder.findRollupRecordForEntity(entity, entityId, fiscalPeriod);
    var response = {actual: 0.0, capex_actual: 0.0, opex_actual: 0.0};
    while(rollups.next()) {
        var breakdown = new CostPlanBreakdown(rollups);
        response.actual += breakdown.actual();
        if(breakdown.expenseType() == 'capex')
            response.capex_actual += breakdown.actual();
        if(breakdown.expenseType() == 'opex')
            response.opex_actual += breakdown.actual();
    }
    //gs.info("Return of findActualOfEntity: " + (new JSON()).encode(response));
    return response;
 };

PPMCostManager.findTotalEstimatedCostOfTasks = function(taskIds, fiscalPeriodIds){
	var metrics = { total: 0, capex: 0, opex: 0};
	var agg = GlideAggregate('cost_plan_breakdown');
    agg.addAggregate('SUM', 'cost_default_currency');
    agg.addQuery('task', 'IN', taskIds.join(','));
    agg.addQuery('expense_type', 'capex');
    agg.addQuery('fiscal_period', 'IN' ,fiscalPeriodIds.join(','));
    agg.addQuery('breakdown_type', 'task');
    agg.groupBy('fiscal_period');
    agg.query();
    while(agg.next()) {
        var capex = agg.getAggregate('SUM', 'cost_default_currency');
        if (JSUtil.notNil(capex))
            metrics.capex += parseFloat(capex);
    }
    agg = GlideAggregate('cost_plan_breakdown');
    agg.addAggregate('SUM', 'cost_default_currency');
    agg.addQuery('task', 'IN', taskIds.join(','));
    agg.addQuery('expense_type', 'opex');
    agg.addQuery('fiscal_period', 'IN' ,fiscalPeriodIds.join(','));
    agg.addQuery('breakdown_type', 'task');
    agg.groupBy('fiscal_period');
    agg.query();
    while(agg.next()) {
        var opex = agg.getAggregate('SUM', 'cost_default_currency');
        if (JSUtil.notNil(opex))
            metrics.opex += parseFloat(opex);
    }
    metrics.total = metrics.capex + metrics.opex;
	return metrics;
};
]]&gt;&lt;/script&gt;
        &lt;sys_class_name&gt;sys_script_include&lt;/sys_class_name&gt;
        &lt;sys_created_by&gt;admin&lt;/sys_created_by&gt;
        &lt;sys_created_on&gt;2015-12-16 09:23:30&lt;/sys_created_on&gt;
        &lt;sys_id&gt;16fdcb2637101200455726877e41f188&lt;/sys_id&gt;
        &lt;sys_mod_count&gt;58&lt;/sys_mod_count&gt;
        &lt;sys_name&gt;PPMCostManager&lt;/sys_name&gt;
        &lt;sys_package display_value="PPM Standard" source="com.snc.financial_planning_pmo"&gt;92ef82e747e64210cd4e1ce4316d43e3&lt;/sys_package&gt;
        &lt;sys_policy/&gt;
        &lt;sys_scope display_value="Global"&gt;global&lt;/sys_scope&gt;
        &lt;sys_update_name&gt;sys_script_include_16fdcb2637101200455726877e41f188&lt;/sys_update_name&gt;
        &lt;sys_updated_by&gt;admin&lt;/sys_updated_by&gt;
        &lt;sys_updated_on&gt;2023-06-13 04:19:16&lt;/sys_updated_on&gt;
    &lt;/sys_script_include&gt;
&lt;/record_update&gt;
</payload>
        <sys_class_name>sys_metadata_link</sys_class_name>
        <sys_created_by>admin</sys_created_by>
        <sys_created_on>2024-09-21 08:10:52</sys_created_on>
        <sys_id>55a0f8d583b01210c6695855eeaad303</sys_id>
        <sys_mod_count>0</sys_mod_count>
        <sys_name>PPMCostManager</sys_name>
        <sys_package display_value="Now Utils" source="x_938076_now_utils">b208a7c083689e50c6695855eeaad3d2</sys_package>
        <sys_policy/>
        <sys_scope display_value="Now Utils">b208a7c083689e50c6695855eeaad3d2</sys_scope>
        <sys_update_name>sys_metadata_link_55a0f8d583b01210c6695855eeaad303</sys_update_name>
        <sys_updated_by>admin</sys_updated_by>
        <sys_updated_on>2024-09-21 08:10:52</sys_updated_on>
        <tablename>sys_script_include</tablename>
    </sys_metadata_link>
</record_update>
