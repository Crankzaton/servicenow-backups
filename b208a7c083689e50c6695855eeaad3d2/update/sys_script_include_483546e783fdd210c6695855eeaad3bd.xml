<?xml version="1.0" encoding="UTF-8"?><record_update table="sys_script_include">
    <sys_script_include action="INSERT_OR_UPDATE">
        <access>public</access>
        <active>true</active>
        <api_name>x_938076_now_utils.getIpConfigResponse</api_name>
        <caller_access/>
        <client_callable>true</client_callable>
        <description/>
        <name>getIpConfigResponse</name>
        <script><![CDATA[var getIpConfigResponse = Class.create();
getIpConfigResponse.prototype = Object.extendsObject(global.AbstractAjaxProcessor, {



    getGeoDetails: function(ip) { //Step 1 - get the geo Data from the IP API


        try {

            var endPoint = gs.getProperty('x_938076_now_utils.geoAPIBaseUrl');
            var geoToken = gs.getProperty('x_938076_now_utils.geoAPITokenKey');
            var requestSent = endPoint + '/' + ip;


            var r = new sn_ws.RESTMessageV2('IPLookup', 'Get Geo Location Details');
            r.setStringParameterNoEscape('geoAPIToken', geoToken); //geoAPIToken
            r.setStringParameterNoEscape('base_url', endPoint); //base_url
            r.setStringParameterNoEscape('ipAddress', ip); //inputIP from client call
            var requestBodyContent = r.getRequestBody();
            var response = r.execute();
            var responseBody = response.getBody();
            var httpStatus = response.getStatusCode();
            var errorMessage = response.getErrorMessage();
            var errorCode = response.getErrorCode();


            var outBoundRecord = this.insertOutBoundLogRecord(ip, endPoint, responseBody, requestSent, httpStatus, errorCode, errorMessage);

        } catch (ex) {

            var message = ex.message;
            gs.info('Please provide a valid IP Address ' + message + ' ' + ip);


        }

    },



    getGeoDetailsRefresh: function() { //Step 1 - get the geo Data from Client
        var clientIPRefereh = this.getParameter('sysparm_ipInput');
        this.getGeoDetails(clientIPRefereh);
        var getTime = new GlideDateTime();
        var message = 'Last refereshed at <span style="color: red; font-weight: bold;">' + getTime + '</span>';
        return message;

    },

    insertOutBoundLogRecord: function(ip, endPoint, responseBody, requestSent, httpStatus, errorCode, errorMessage) { //Step 2 - create outbound Log record with the JSON received from Step 1

        gs.info('Request Updated ' + ip);

        var exitingOutBoundRec = false; // flag to decide if there is already a record with the IP

        var recInsert = false;
        var recUpdate = false;

        var outBoundLog = new GlideRecord('x_938076_now_utils_outbound_rest_message_logs');
        outBoundLog.addEncodedQuery('request_bodyLIKE' + ip);
        outBoundLog.query();
        if (outBoundLog.next()) {
            exitingOutBoundRec = true; // if there is exiting record flag will be true and the record is updated
        } else { //if ther is no exiting record
            outBoundLog.initialize();
        }
        outBoundLog.end_point = endPoint;
        outBoundLog.request_body = requestSent;
        outBoundLog.http_status = httpStatus;
        outBoundLog.response_body = responseBody;
        outBoundLog.response_code = httpStatus;
        if (httpStatus != '200') {

            outBoundLog.error_code = errorCode;
            outBoundLog.error_message = errorMessage;
        }
        if (exitingOutBoundRec) {
            //retry count logic
            if ((outBoundLog.retry_count < 3)) {
                outBoundLog.retry_count = outBoundLog.retry_count + 1;
            }
            //retry count logic
            outBoundLog.update(); //if there is  exiting record update it
            recUpdate = true;
        } else {
            outBoundLog.retry_count = 0;
            outBoundLog.insert(); //if there is no exiting record insert it
            recInsert = true;

        }
        if ((recInsert) || (recUpdate)) {
            this.parseGeoDetails(responseBody);

        }

    },




    parseGeoDetails: function(respoBody) { //Step 3 - update or insert the  IP record in Table

        var exitingRec = false; // flag to decide if there is already a record with the IP
        var ipParsedData = JSON.parse(respoBody);

        //Checking if already there is a record and update else create a new Record

        var ipConfigData = new GlideRecord('x_938076_now_utils_ip_configuration_data');
        ipConfigData.addEncodedQuery('ip_address=' + ipParsedData.ip);
        ipConfigData.query();
        if (ipConfigData.next()) {
            exitingRec = true; // if there is exiting record flag will be true and the record is updated
        } else { //if ther is no exiting record
            ipConfigData.initialize();
        }

        ipConfigData.ip_address = ipParsedData.ip;
        ipConfigData.continent_code = ipParsedData.continent_code;
        ipConfigData.continent_name = ipParsedData.continent_name;
        ipConfigData.country_code = ipParsedData.country_code3;
        ipConfigData.country_name = ipParsedData.country_name;
        ipConfigData.country_name_official = ipParsedData.country_name_official;
        ipConfigData.country_capital = ipParsedData.country_capital;
        ipConfigData.state_province = ipParsedData.state_prov;
        ipConfigData.state_code = ipParsedData.state_code;
        ipConfigData.district = ipParsedData.district;
        ipConfigData.city = ipParsedData.city;
        ipConfigData.zipcode = ipParsedData.zipcode;
        ipConfigData.latitude = ipParsedData.latitude;
        ipConfigData.longitude = ipParsedData.longitude;
        ipConfigData.is_memeber_of_european_union = ipParsedData.is_eu.toString();
        ipConfigData.calling_code = ipParsedData.calling_code;
        ipConfigData.languages = ipParsedData.languages;
        ipConfigData.country_flag = ipParsedData.country_flag;
        ipConfigData.geoname_id = ipParsedData.geoname_id;
        ipConfigData.isp = ipParsedData.isp;
        ipConfigData.connection_type = ipParsedData.connection_type;
        ipConfigData.organization = ipParsedData.organization;
        ipConfigData.currency_code = ipParsedData.currency.code;
        ipConfigData.currency_name = ipParsedData.currency.name;
        ipConfigData.currency_symbol = ipParsedData.currency.symbol;
        ipConfigData.timezone = ipParsedData.time_zone.name;
        ipConfigData.time_zone_offset = ipParsedData.time_zone.offset;
        ipConfigData.time_zone_offset_dst = ipParsedData.time_zone.offset_with_dst;
        ipConfigData.current_time = ipParsedData.time_zone.current_time;
        ipConfigData.current_time_unix = ipParsedData.time_zone.current_time_unix;
        ipConfigData.is_dst = ipParsedData.time_zone.is_dst;
        ipConfigData.dst_savings = ipParsedData.time_zone.dst_savings;
        ipConfigData.dst_exists = ipParsedData.time_zone.dst_exists;
        ipConfigData.dst_start = ipParsedData.time_zone.dst_start;
        ipConfigData.dst_end = ipParsedData.time_zone.dst_end.toString();

        if (exitingRec) { //if there is exiting record update it
            ipConfigData.update();
        } else {
            ipConfigData.insert(); //if there is no exiting record insert it

        }

    },

    type: 'getIpConfigResponse'
});]]></script>
        <sys_class_name>sys_script_include</sys_class_name>
        <sys_created_by>admin</sys_created_by>
        <sys_created_on>2024-11-17 07:26:27</sys_created_on>
        <sys_id>483546e783fdd210c6695855eeaad3bd</sys_id>
        <sys_mod_count>123</sys_mod_count>
        <sys_name>getIpConfigResponse</sys_name>
        <sys_package display_value="Now Utils" source="x_938076_now_utils">b208a7c083689e50c6695855eeaad3d2</sys_package>
        <sys_policy>read</sys_policy>
        <sys_scope display_value="Now Utils">b208a7c083689e50c6695855eeaad3d2</sys_scope>
        <sys_update_name>sys_script_include_483546e783fdd210c6695855eeaad3bd</sys_update_name>
        <sys_updated_by>admin</sys_updated_by>
        <sys_updated_on>2024-12-13 09:08:17</sys_updated_on>
    </sys_script_include>
</record_update>
