<?xml version="1.0" encoding="UTF-8"?><record_update table="sys_metadata_link">
    <sys_metadata_link action="INSERT_OR_UPDATE">
        <directory>update</directory>
        <documentkey>27188a5a53f9e110abeaddeeff7b12a4</documentkey>
        <payload>&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;record_update table="sys_script_include"&gt;
    &lt;sys_script_include action="INSERT_OR_UPDATE"&gt;
        &lt;access&gt;public&lt;/access&gt;
        &lt;active&gt;true&lt;/active&gt;
        &lt;api_name&gt;sn_entitlement.SubscriptionEntitlementsService&lt;/api_name&gt;
        &lt;caller_access/&gt;
        &lt;client_callable&gt;false&lt;/client_callable&gt;
        &lt;description&gt;Provides information about subscriptions&lt;/description&gt;
        &lt;name&gt;SubscriptionEntitlementsService&lt;/name&gt;
        &lt;script&gt;&lt;![CDATA[var SubscriptionEntitlementsService = Class.create();
SubscriptionEntitlementsService.prototype = {
    initialize: function() {
        this._cacheManager = new LicensingCacheManager();
        this._APIColumnList = [
            LicensingEngineDBConstants.NAME,
            LicensingEngineDBConstants.START_DATE,
            LicensingEngineDBConstants.END_DATE,
            LicensingEngineDBConstants.SUBSCRIPTION_TYPE,
            LicensingEngineDBConstants.MEASURED_ROLE_TYPES,
            LicensingEngineDBConstants.PRODUCT_CODE,
            LicensingEngineDBConstants.DEFINITION_ID,
            LicensingEngineDBConstants.PURCHASED_COUNT
        ];
    },
    
    /**
     * Return information about all active subscriptions
     * @return {array} an array of SubscriptionEntitlementData
     */
    getActiveSubscriptions: function() {
        return this._decorateWithURL(new LicenseDetailDaoV1().getLicenseDetailsByAllActive());
    },

    /**
     * Return information about active subscriptions which contain specified app bundles
     * @param {array} appBundles names of app bundles
     * @return {array} an array of SubscriptionEntitlementData
     */
    getSubscriptionsWithAppBundles: function(appBundles) {
        if (this._shouldUseNewSchema()) {
            const seDao = new SubscriptionEntitlementDao();
            if (global.JSUtil.nil(appBundles) || appBundles.length == 0) {
                appBundles = seDao.getAppBundles();
            }
            return this._decorateWithURL(seDao.getSubscriptionEntitlementsByContainsAppBundles(appBundles), "subscription_entitlement", appBundles, seDao);
        } else {
            const ldDao = new LicenseDetailDaoV1();
            if (global.JSUtil.nil(appBundles) || appBundles.length == 0) {
                appBundles = ldDao.getAppBundles();
            }
            return this._decorateWithURL(ldDao.getLicenseDetailsByContainsAppBundles(appBundles), "license_details", appBundles, ldDao);
        }
    },

	/**
	 * Return information about all active subscriptions
	 * @return {array} an array of SubscriptionEntitlementData
	 */
	getActiveSubscriptions: function() {
		return this._decorateWithURL(new LicenseDetailDaoV1().getLicenseDetailsByAllActive());
	},

	/**
	 * Return information about active subscriptions which contain specified app bundles
	 * @param {array} appBundles names of app bundles
	 * @return {array} an array of SubscriptionEntitlementData
	 */
	getSubscriptionsWithAppBundles: function(appBundles) {
		if (this._shouldUseNewSchema()) {
			const seDao = new SubscriptionEntitlementDao();
			if (global.JSUtil.nil(appBundles) || appBundles.length == 0) {
				appBundles = seDao.getAppBundles();
			}
			return this._decorateWithURL(seDao.getSubscriptionEntitlementsByContainsAppBundles(appBundles), "subscription_entitlement", appBundles, seDao);
		}
		else {
			const ldDao = new LicenseDetailDaoV1();
			if (global.JSUtil.nil(appBundles) || appBundles.length == 0) {
				appBundles = ldDao.getAppBundles();
			}
			return this._decorateWithURL(ldDao.getLicenseDetailsByContainsAppBundles(appBundles), "license_details", appBundles, ldDao);
		}
	},
    /**
     * Return information about all active subscriptions for ITOM team to identify legacy itom licenses.
     * @return {array} an array of Subscription data
     */
    getSubscriptionDetail: function() {
        if (this._shouldUseNewSchema()) {
            const seDao = new SubscriptionEntitlementDao();
            return seDao.getSubscriptionEntitlementsITOM();
        } else {
            const ldDao = new LicenseDetailDaoV1();
            return ldDao.getLicenseDetailsITOM();
        }
    },

    /**
     * Return GenAI metadata info of active subscriptions
     * @param {string} featureID
     * @return {string} string value of list of json objects with GenAI metadata details
     * example: [{ "feature_id": "Feature Id 8", "license_name": "Now Assist for ITSM", "feature": "Text to Code", "license_line_item_name": "Now Assist for ITSM", "assist": 2, "license_sys_id": "b4bfeabea8993110f877dbf9e380dafe" }, { "feature_id": "Feature Id 8", "license_name": "Now Assist for CSM", "feature": "Text to Code", "license_line_item_name": "Now Assist for CSM", "assist": 3, "license_sys_id": "d6ff6abea8993110f877dbf9e380da72" }]
     */
    getEntitledGenAIMetadataForFeature: function(featureID) {
        var response = '[]';

        if (global.JSUtil.nil(featureID))
            return response;

        if (this._shouldUseNewSchema()) {
            var genAIMetadataObjList = [];

            var genAIMetadataFromCache = this.getMetadataFromCache(LicensingEngineDBConstants.GENAI_METADATA);
            if (global.JSUtil.notNil(genAIMetadataFromCache) &amp;&amp; !global.JSUtil.isEmpty(genAIMetadataFromCache)) {
                for (var cacheMetadataObj of genAIMetadataFromCache) {
                    if (!cacheMetadataObj[LicensingEngineDBConstants.COLUMN_VALUES].includes(featureID))
                        continue;

                    var genAIMetadataObj = this._getFormattedMetadataObj(cacheMetadataObj);
                    if (global.JSUtil.notNil(genAIMetadataObj) &amp;&amp; genAIMetadataObj[LicensingEngineConstants.FEATURE_ID] == featureID) {
                        //assist value has to be int to keep the API response same for both SMv1 and SMv2 model
                        genAIMetadataObj[LicensingEngineConstants.ASSIST] = parseInt(genAIMetadataObj[LicensingEngineConstants.ASSIST]);
                        genAIMetadataObjList.push(genAIMetadataObj);
                    }
                }
            }
            response = JSON.stringify(genAIMetadataObjList);
        } else
            response = sn_lef.GlideEntitlement.getEntitledGenAIMetadataInfo(featureID);

        return response;
    },

    getMetadataFromCache: function(metadataType) {
        var metadataFromCache = [];

        var metadataTypeToObj = new Map();
        metadataTypeToObj = this._cacheManager.getDataFromCache(LicensingEngineConstants.LICENSING_CACHE_CATALOG, LicensingEngineConstants.SKU_METADATA_CACHE);

        if (global.JSUtil.nil(metadataTypeToObj)) {
            new SkuMetadataDAO().loadSKUMetadataIntoCache();
            metadataTypeToObj = this._cacheManager.getDataFromCache(LicensingEngineConstants.LICENSING_CACHE_CATALOG, LicensingEngineConstants.SKU_METADATA_CACHE);
        }

        metadataTypeToObj.forEach(function(metadataObjList, columnKey) {
            if (columnKey == metadataType) {
                metadataObjList.forEach(function(metadataObj) {
                    metadataFromCache.push(metadataObj);
                });
            }
        });

        return metadataFromCache;
    },

    /**
     * Return information about the routing to EMS or SURF APIs based on glide properties.
     */
	canRouteToEMS: function(){
		return this._shouldUseNewSchema();
	},

    /**
     * This is a helper function to change the format of metadata obj in cache to be suitable for licensing API
     * param cacheMetadataObj format = {"column_values":"Feature Id 8,Text to Code,2","subscription.name":"Now Assist for ITSM","subscription.sys_id":"b4bfeabea8993110f877dbf9e380dafe","schema.column_names":"feature_id,feature,assist"}
     * example returns (genai) metadata object in format = { "feature_id": "Feature Id 8", "license_name": "Now Assist for ITSM", "feature": "Text to Code", "license_line_item_name": "Now Assist for ITSM", "assist": "2", "license_sys_id": "b4bfeabea8993110f877dbf9e380dafe" }
     * applicable of any metadata type
     */
    _getFormattedMetadataObj: function(cacheMetadataObj) {

        if (global.JSUtil.nil(cacheMetadataObj))
            return null;

        var metadataColumnValuesList = cacheMetadataObj[LicensingEngineDBConstants.COLUMN_VALUES].split(LicensingEngineConstants.COMMA);
        var metadataColumnNamesList = cacheMetadataObj[LicensingEngineDBConstants.SCHEMA_COLUMN_NAMES].split(LicensingEngineConstants.COMMA);
        var subscriptionName = cacheMetadataObj[LicensingEngineDBConstants.SUBSCRIPTION_NAME];

        if (metadataColumnNamesList.length &gt; 0 &amp;&amp; metadataColumnValuesList.length &gt; 0 &amp;&amp; metadataColumnNamesList.length == metadataColumnValuesList.length) {
            var metadataObj = {};
            for (var i = 0; i &lt; metadataColumnNamesList.length; i++)
                metadataObj[metadataColumnNamesList[i]] = metadataColumnValuesList[i];

            metadataObj[LicensingEngineConstants.LICENSE_NAME] = subscriptionName;
            //since we don't have support for mapping between sku_metadata table and subscription line item, license_line_item_name will be same as name of subscription entitlement.
            metadataObj[LicensingEngineConstants.LICENSE_LINE_ITEM_NAME] = subscriptionName;
            metadataObj[LicensingEngineConstants.LICENSE_SYS_ID] = cacheMetadataObj[LicensingEngineDBConstants.SUBSCRIPTION_SYS_ID];

            return metadataObj;
        }

        return null;
    },

    _decorateWithURL: function(subscriptions, entitlementTableName, appBundles, entitlementDao) {
        subscriptions.forEach(record =&gt; record.details_url = entitlementTableName + '?sys_id=' + record.id);
        subscriptions.forEach(record =&gt; record.su_ratio = entitlementDao.getSubscriptionRatiosByContainsAppBundles(appBundles, record.id));
        subscriptions.forEach(record =&gt; record.app_bundle = record.su_ratio.length &gt; 0 ? record.su_ratio[0].app_bundle : null);
        return subscriptions;
    },

    _shouldUseNewSchema: function() {
        const surfRouting = gs.getProperty('glide.entitlement.surf.routing', true).toLowerCase() === 'true';
        const emsDataAvailable = gs.getProperty('glide.entitlement.ems.data.available', false).toLowerCase() === 'true';
        return !surfRouting &amp;&amp; emsDataAvailable;
    },

    getPoolLicense: function(accrualPeriod, mode) {
        if (global.JSUtil.nil(mode))
            mode = LicensingEngineConstants.GRACE_MODE; //default mode is GRACE
        if (mode === LicensingEngineConstants.STRICT_MODE &amp;&amp; global.JSUtil.nil(accrualPeriod))
            return null;

        const subscriptionList = this.getEntitlementDetails(LicensingEngineConstants.INTEGRATIONHUBPOOL);
        if (subscriptionList.length &lt; 1)
            return null;

        for (let subscription of subscriptionList) {
            if (mode === LicensingEngineConstants.GRACE_MODE)
                return LicensingEngineConstants.INTEGRATIONHUBPOOL;

            if (mode === LicensingEngineConstants.STRICT_MODE &amp;&amp; this.isValidForAccrualPeriod(subscription.start_date, subscription.end_date, accrualPeriod))
                return LicensingEngineConstants.INTEGRATIONHUBPOOL;
        }
        return null;
    },

    isValidForAccrualPeriod: function(startDate, endDate, accrualPeriod) {
        if (global.JSUtil.nil(accrualPeriod))
            return false;

        startDate = new GlideDateTime(startDate);
		endDate = new GlideDateTime(endDate);
        accrualPeriod = new GlideDateTime(accrualPeriod);
		endDate.addDaysLocalTime(LicensingEngineConstants.GRACE_PERIOD_DAYS);

        if (accrualPeriod &gt;= startDate &amp;&amp; accrualPeriod &lt;= endDate)
            return true;
        return false;
    },

    getEntitlementDetails: function(subscriptionIdentifier) {
        let subscriptionList = [];
        let entitlmentIdToSubscriptionObj = this._loadSubscriptionEntitlementFromCache();
        for (let [entitlementId, subscriptionObjectList] of entitlmentIdToSubscriptionObj) {
            for (let subscriptionObject of subscriptionObjectList) {
                const subscriptionID = subscriptionObject[LicensingEngineDBConstants.SUBSCRIPTION_IDENTIFIER];
                if (global.JSUtil.notNil(subscriptionID) &amp;&amp; subscriptionID === subscriptionIdentifier)
                    subscriptionList.push(subscriptionObject);
            }
        }
        return subscriptionList;
    },

    /**
     * Return information about all active subscriptions
     * @return {string} string value of list of JSON objects. Each JSON object has the following keys:
     * name, start_date, end_date, subscription_type, measured_role_types, product_code, purchased_count, definition_id
     */
    getAllActiveEntitlements: function() {
        let entitlements = [];
        let entitlmentIdToSubscriptionObj = this._loadSubscriptionEntitlementFromCache();
        for (let [entitlementId, subscriptionObjectList] of entitlmentIdToSubscriptionObj) {
            if (gs.nil(entitlementId))
                continue;

            for (let subscriptionObject of subscriptionObjectList) {
                const entitlementObj = {};
                this._APIColumnList.forEach(col =&gt; entitlementObj[col] = subscriptionObject[col]);
                entitlements.push(entitlementObj);
            }
        }
        return JSON.stringify(entitlements);
    },

    _loadSubscriptionEntitlementFromCache: function() {
        let entitlementIdToSubscription = new Map();
        entitlementIdToSubscription = this._cacheManager.getDataFromCache(LicensingEngineConstants.LICENSING_CACHE_CATALOG, LicensingEngineConstants.SUBSCRIPTION_ENTITLEMENT_CACHE);
        if (global.JSUtil.nil(entitlementIdToSubscription) || entitlementIdToSubscription.size === 0) {
            new SubscriptionEntitlementDAO().loadSubscriptionEntitlementIntoCache();
            entitlementIdToSubscription = this._cacheManager.getDataFromCache(LicensingEngineConstants.LICENSING_CACHE_CATALOG, LicensingEngineConstants.SUBSCRIPTION_ENTITLEMENT_CACHE);
        }
        return entitlementIdToSubscription;
    },
    type: 'SubscriptionEntitlementsService'
};]]&gt;&lt;/script&gt;
        &lt;sys_class_name&gt;sys_script_include&lt;/sys_class_name&gt;
        &lt;sys_created_by&gt;admin&lt;/sys_created_by&gt;
        &lt;sys_created_on&gt;2023-03-27 23:29:53&lt;/sys_created_on&gt;
        &lt;sys_id&gt;27188a5a53f9e110abeaddeeff7b12a4&lt;/sys_id&gt;
        &lt;sys_mod_count&gt;39&lt;/sys_mod_count&gt;
        &lt;sys_name&gt;SubscriptionEntitlementsService&lt;/sys_name&gt;
        &lt;sys_package display_value="Licensing Engine" source="sn_entitlement"&gt;bcadabf277f311109c62f5f3cb5a992a&lt;/sys_package&gt;
        &lt;sys_policy&gt;read&lt;/sys_policy&gt;
        &lt;sys_scope display_value="Licensing Engine"&gt;bcadabf277f311109c62f5f3cb5a992a&lt;/sys_scope&gt;
        &lt;sys_update_name&gt;sys_script_include_27188a5a53f9e110abeaddeeff7b12a4&lt;/sys_update_name&gt;
        &lt;sys_updated_by&gt;maint&lt;/sys_updated_by&gt;
        &lt;sys_updated_on&gt;2023-11-14 23:47:12&lt;/sys_updated_on&gt;
    &lt;/sys_script_include&gt;
&lt;/record_update&gt;
</payload>
        <sys_class_name>sys_metadata_link</sys_class_name>
        <sys_created_by>admin</sys_created_by>
        <sys_created_on>2024-09-21 08:12:36</sys_created_on>
        <sys_id>6201785983b01210c6695855eeaad348</sys_id>
        <sys_mod_count>0</sys_mod_count>
        <sys_name>SubscriptionEntitlementsService</sys_name>
        <sys_package display_value="Now Utils" source="x_938076_now_utils">b208a7c083689e50c6695855eeaad3d2</sys_package>
        <sys_policy/>
        <sys_scope display_value="Now Utils">b208a7c083689e50c6695855eeaad3d2</sys_scope>
        <sys_update_name>sys_metadata_link_6201785983b01210c6695855eeaad348</sys_update_name>
        <sys_updated_by>admin</sys_updated_by>
        <sys_updated_on>2024-09-21 08:12:36</sys_updated_on>
        <tablename>sys_script_include</tablename>
    </sys_metadata_link>
</record_update>
