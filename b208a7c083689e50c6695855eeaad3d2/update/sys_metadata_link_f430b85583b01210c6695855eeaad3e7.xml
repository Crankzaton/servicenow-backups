<?xml version="1.0" encoding="UTF-8"?><record_update table="sys_metadata_link">
    <sys_metadata_link action="INSERT_OR_UPDATE">
        <directory>update</directory>
        <documentkey>01528a057ff303009da45ac47dfa9190</documentkey>
        <payload>&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;record_update table="sys_script_include"&gt;
    &lt;sys_script_include action="INSERT_OR_UPDATE"&gt;
        &lt;access&gt;package_private&lt;/access&gt;
        &lt;active&gt;true&lt;/active&gt;
        &lt;api_name&gt;global.MLSolutionDefinitionUtils&lt;/api_name&gt;
        &lt;caller_access/&gt;
        &lt;client_callable&gt;false&lt;/client_callable&gt;
        &lt;description&gt;This Script Include contains utility functions related to Solution Definition.
&lt;/description&gt;
        &lt;name&gt;MLSolutionDefinitionUtils&lt;/name&gt;
        &lt;script&gt;&lt;![CDATA[var MLSolutionDefinitionUtils = Class.create();
MLSolutionDefinitionUtils.prototype = {
    ML_SOLUTION_DEFINITION_DEFAULT_COPY_ATTR_ARRAY: ['trainer', 'table', 'input_filter', 'dataset_language', 'input_fields', 'output_field', 'training_frequency', 'active', 'prediction_input_fields', 'lookup_window_size', 'similarity_window_filter', 'update_frequency', 'clustering_fields', 'clustering_window', 'clustering_window_filters', 'recluster_frequency', 'minimum_similarity_threshold', 'minimum_records_in_a_cluster', 'maximum_number_of_clusters', 'use_segmentation', 'segmentation_field', 'threshold', 'min_records', 'max_count', 'word_vector_corpus', 'table_to_compare', 'fields_to_compare'],
    ML_SOLUTION_DEFINITION: 'ml_solution_definition',
    ALWAYS_IGNORE_ATTRS_ARRAY: [],
    ML_CAPABILITY_SOL_DEFINITION_ATTR_ARRAY: ['table', 'filter', 'dataset_language', 'fields', 'output_field', 'training_frequency', 'active', 'update_frequency', 'capability', 'threshold', 'use_segmentation', 'segmentation_field', 'min_records', 'word_vector_corpus', 'test_table', 'test_fields', 'sys_domain', 'solution_parameters', 'stopwords', 'purity_fields', 'cal_purity', 'create_ci_table'],
    ML_CAPABILITY_DEF_TABLES: [global.MLBaseConstants.ML_CAPABILITY_DEF_BASE, global.MLBaseConstants.ML_CAPABILITY_DEF_CLASSIFICATION, global.MLBaseConstants.ML_CAPABILITY_DEF_SIMILARITY, global.MLBaseConstants.ML_CAPABILITY_DEF_CLUSTERING, MLBaseConstants.ML_CAPABILITY_DEF_REGRESSION],
    USE_NEW_SCHEMA: gs.getProperty('glide.platform_ml.use_new_schema', false),

    initialize: function() {
        this.arrayUtil = new ArrayUtil();
        this.log = new GSLog('com.snc.ml.solution.definition.copy.log', 'MLSolutionDefinitionUtils');
        this.log.disableDatabaseLogs();
        this.similarity_capability = "15ab7f3c53873300d1dcddeeff7b12ce";
    },

    /**
     * Process the list of copy attributes and get attribute values of current solution definition
     * in the form of encoded query string
     */
    getMLSolutionDefinitionQueryParams: function(current) {
        try {
            if (JSUtil.nil(current)) {
                this.log.logErr('Invalid record passed');
                return false;
            }

            var attributesList = this._getAttributeList();

            if (!attributesList)
                return false;
            var validTable = current.getTableName() == this.ML_SOLUTION_DEFINITION;

            if (this.USE_NEW_SCHEMA == 'true') {
                var au = new ArrayUtil();
                validTable = au.contains(this.ML_CAPABILITY_DEF_TABLES, current.getTableName());
            }

            if (validTable &amp;&amp; current.isValidRecord())
                return this._getRecordValuesAsEncodedQuery(current, attributesList);
            else
                this.log.logErr('Invalid record passed. A valid ml_solution_definition record is required');

        } catch (e) {
            this.log.logErr('Exception caught: ' + e);
        }

    },

    /**
     * _getAttributeList method 
     * 1. Gets list of attributes to be copied
     * 2. Removes extra white spaces, sanitizes the string values and constructs fieldList array - array of values (field names) to be copied
     * 3. Removes ALWAYS_IGNORE_ATTRS values from fieldList array and returns the resultant array
     */

    _getAttributeList: function() {
        if (this.USE_NEW_SCHEMA == 'true') {
            return this.arrayUtil.diff(this.ML_CAPABILITY_SOL_DEFINITION_ATTR_ARRAY, this.ALWAYS_IGNORE_ATTRS_ARRAY);
        }
        return this.arrayUtil.diff(this.ML_SOLUTION_DEFINITION_DEFAULT_COPY_ATTR_ARRAY, this.ALWAYS_IGNORE_ATTRS_ARRAY);
    },

    /**
     * Gets Solution Definition attributes in the form of encoded query string
     */

    _getRecordValuesAsEncodedQuery: function( /*GlideRecord object*/ record, /*Array*/ attributesList) {
        var table = record.getTableName();
        var gr = new GlideRecord(table);
        var activeAttrsToCopy = [];

        for (var i = 0; i &lt; attributesList.length; ++i) {
            var name = attributesList[i];
            if (record.isValidField(name)) {
                if (record.getValue(name)) {
                    // We have to use the display value if it's a date based field for form filter
                    if (record.getElement(name).getED().getInternalType() == "glide_date_time") {
                        gr.addQuery(name, record.getDisplayValue(name));
                    } else {
                        gr.addQuery(name, record.getValue(name));
                    }
                }
            } else
                this.log.logWarning("Invalid field '" + name + "' provided for table '" + table + "'.");
        }

        //Prefix 'Copy Of' to Label and Name of Current Solution Definition
        gr.addQuery('solution_label', 'Copy of ' + record.getValue('solution_label'));
        gr.addQuery('solution_name', 'copy_of_' + record.getValue('solution_name'));
        return gr.getEncodedQuery();

    },

    getDefaultOOBSolutionDefinitions: function(trainer) {
        var oobSolutionDefinitions = {};

        var gr = new GlideRecord("ml_autotrain_solution");
        if (trainer != 'all')
            gr.addQuery("solution_definition.capability", trainer);
        gr.query();
        while (gr.next()) {
            var solution_definition = gr.solution_definition;
            var trainer1 = gr.solution_definition.capability;
            oobSolutionDefinitions[solution_definition] = {
                "plugin_id": gr.plugin_id,
                "trainer": trainer1
            };
        }
        return oobSolutionDefinitions;

    },

    trainCapabilitySolDef: function(current) {
        new MLRequestSchedule().deleteExistingCapabilityTrainingRequestSchedule(current.sys_id);
        new MLRequestSchedule().insertCapabilityTrainingRequestSchedule(current.sys_id, current.solution_label, current.training_frequency.toString());
    },

    /*
     * function to get the reference qualifier for the advanced solution setting table
     */
    getSolutionParameter: function(current) {
        var capability = current.ml_capability_definition.capability;
        var capability_name = capability.getRefRecord().getValue("value");
        if (capability_name == "classification_trainer" &amp;&amp; gs.getProperty("glide.platform_ml.api.enable_workflow_classification") == "true") {
            if (capability_name == "classification_trainer")
                capability = "877599b3770111107d80204bcd5a994c";
        }
        return "capabilityLIKE" + capability + "^active=true";
    },

    getStopwordLanguage: function(current) {
        return "language=" + current.dataset_language;
    },

    /**
     * Conditions to be met for Word Corpus column reference qualifier
     * on ml_capability_definition_base:
     * 1. If ml_word_vector_corpus records are created via API,
     * check if it is trained and has model artifacts
     * 2. If ml_word_vector_corpus records' request_source is UI 
     * OR request_source is empty (GloVe)
     */
    getValidWordCorpusRecords: function(current) {
        var validAPIWordcorpusIds = [];
        var gr = new GlideRecord(MLBaseConstants.ML_MODEL_ARTIFACT);
        gr.addQuery('word_corpus.word_vector_corpus.request_source', 'api');
        gr.query();
        while (gr.next()) {
            var wvcVersion = new GlideRecord(MLBaseConstants.ML_WORD_VECTOR_CORPUS_VERSIONS);
            wvcVersion.get(gr.getValue('word_corpus'));
            validAPIWordcorpusIds.push(wvcVersion.getValue('word_vector_corpus'));
        }
        var wvcGR = new GlideRecord(MLBaseConstants.ML_WORD_VECTOR_CORPUS);
        var qc = wvcGR.addQuery('sys_id', 'IN', validAPIWordcorpusIds.join());
        qc.addOrCondition('request_source', 'ui');
        qc.addOrCondition('request_source', '');
        //Glove word corpus for paris can only be used for Similarity Capability.
        if (current.capability != this.similarity_capability) {
            var glove_wvc_sys_id = '7244d5a753220010d1dcddeeff7b12d5';
            wvcGR.addQuery('sys_id', '!=', glove_wvc_sys_id);
        }
        wvcGR.query();
        return wvcGR.getEncodedQuery();
    },

    isSolutionDefinitionPresent: function(solutionName) {
        if (!solutionName)
            return false;
        var gr = new GlideRecord('ml_capability_definition_base');
        gr.addQuery('solution_name', solutionName);
        gr.query();
        if (gr.hasNext()) {
            return true;
        }
        return false;
    },

    isMLWorkflowMigrationEnabled: function(capability) {
        if ((capability == "classification_trainer" || capability == "workflow_classification_trainer") &amp;&amp; gs.getProperty("glide.platform_ml.api.enable_workflow_classification") == "true") {
            return true;
        } else if ((capability == "regression_trainer" || capability == "workflow_regression_trainer") &amp;&amp; gs.getProperty("glide.platform_ml.api.enable_workflow_regression") == "true") {
            return true;
        } else if ((capability == "clustering_trainer" || capability == "workflow_clustering_trainer") &amp;&amp; gs.getProperty("glide.platform_ml.api.enable_workflow_clustering") == "true") {
            return true;
        } else if ((capability == "similarity_trainer" || capability == "workflow_similarity_trainer") &amp;&amp; gs.getProperty("glide.platform_ml.api.enable_workflow_similarity") == "true") {
            return true;
        }
        return false;
    },

    getCapability: function(capability) {
        var gr = new GlideRecord('ml_capability');
        gr.addQuery('value', capability);
        gr.query();
        if (gr.next()) {
            return gr.getUniqueValue();
        }
        return -1;
    },

    type: 'MLSolutionDefinitionUtils'
};]]&gt;&lt;/script&gt;
        &lt;sys_class_name&gt;sys_script_include&lt;/sys_class_name&gt;
        &lt;sys_created_by&gt;admin&lt;/sys_created_by&gt;
        &lt;sys_created_on&gt;2018-01-20 00:13:36&lt;/sys_created_on&gt;
        &lt;sys_id&gt;01528a057ff303009da45ac47dfa9190&lt;/sys_id&gt;
        &lt;sys_mod_count&gt;130&lt;/sys_mod_count&gt;
        &lt;sys_name&gt;MLSolutionDefinitionUtils&lt;/sys_name&gt;
        &lt;sys_package display_value="Predictive Intelligence" source="com.glide.platform_ml"&gt;c41430683c31311068bcf327dfe37f28&lt;/sys_package&gt;
        &lt;sys_policy/&gt;
        &lt;sys_scope display_value="Global"&gt;global&lt;/sys_scope&gt;
        &lt;sys_update_name&gt;sys_script_include_01528a057ff303009da45ac47dfa9190&lt;/sys_update_name&gt;
        &lt;sys_updated_by&gt;admin&lt;/sys_updated_by&gt;
        &lt;sys_updated_on&gt;2023-05-03 09:40:05&lt;/sys_updated_on&gt;
    &lt;/sys_script_include&gt;
&lt;/record_update&gt;
</payload>
        <sys_class_name>sys_metadata_link</sys_class_name>
        <sys_created_by>admin</sys_created_by>
        <sys_created_on>2024-09-21 08:08:56</sys_created_on>
        <sys_id>f430b85583b01210c6695855eeaad3e7</sys_id>
        <sys_mod_count>0</sys_mod_count>
        <sys_name>MLSolutionDefinitionUtils</sys_name>
        <sys_package display_value="Now Utils" source="x_938076_now_utils">b208a7c083689e50c6695855eeaad3d2</sys_package>
        <sys_policy/>
        <sys_scope display_value="Now Utils">b208a7c083689e50c6695855eeaad3d2</sys_scope>
        <sys_update_name>sys_metadata_link_f430b85583b01210c6695855eeaad3e7</sys_update_name>
        <sys_updated_by>admin</sys_updated_by>
        <sys_updated_on>2024-09-21 08:08:56</sys_updated_on>
        <tablename>sys_script_include</tablename>
    </sys_metadata_link>
</record_update>
