<?xml version="1.0" encoding="UTF-8"?><record_update table="sys_metadata_link">
    <sys_metadata_link action="INSERT_OR_UPDATE">
        <directory>update</directory>
        <documentkey>65ee0f7553192110aa63ddeeff7b125c</documentkey>
        <payload>&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;record_update table="sys_script_include"&gt;
    &lt;sys_script_include action="INSERT_OR_UPDATE"&gt;
        &lt;access&gt;public&lt;/access&gt;
        &lt;active&gt;true&lt;/active&gt;
        &lt;api_name&gt;global.OptimalMatchingAlgorithm&lt;/api_name&gt;
        &lt;caller_access/&gt;
        &lt;client_callable&gt;false&lt;/client_callable&gt;
        &lt;description/&gt;
        &lt;name&gt;OptimalMatchingAlgorithm&lt;/name&gt;
        &lt;script&gt;&lt;![CDATA[var OptimalMatchingAlgorithm = Class.create();
OptimalMatchingAlgorithm.prototype = {
    initialize: function() {

        this.MAX_SIZE = Number.MAX_VALUE;
        this.DEFAULT_PAD_VALUE = 0; //A default value to pad the cost matrix with if it is not quadratic.
        this.C = null;
        this.rowCovered = [];
        this.colCovered = [];
        this.n = 0;
        this.Z0_r = 0;
        this.Z0_c = 0;
        this.marked = null;
        this.path = null;
    },

    /**
     * Pad a possibly non-square matrix to make it square.
     *
     * @param {Array} matrix An array of arrays containing the cost matrix cells
     * @param {Number} [padValue] The value used to pad a rectangular matrix
     *
     * @return {Array} An array of arrays representing the padded matrix
     */
    padMatrix: function(matrix, padValue) {
        padValue = padValue || this.DEFAULT_PAD_VALUE;

        var maxColumns = 0;
        var totalRows = matrix.length;
        var i;

        for (i = 0; i &lt; totalRows; ++i)
            if (matrix[i].length &gt; maxColumns)
                maxColumns = matrix[i].length;

        totalRows = maxColumns &gt; totalRows ? maxColumns : totalRows;

        var newMatrix = [];

        for (i = 0; i &lt; totalRows; ++i) {
            var row = matrix[i] || [];
            var newRow = row.slice();

            // If this row is too short, pad it
            while (totalRows &gt; newRow.length)
                newRow.push(padValue);

            newMatrix.push(newRow);
        }

        return newMatrix;
    },

    /**
     * Compute the indices for the lowest-cost pairings between rows and columns
     * in the matrix. Returns an object with following information
     * assignmentPossible : Boolean value which represents assignement is possible or not
     * assignments: list of (row, column) tuples that can be used to form optimal assignment
     * optimalCost = Total cost based on the selected assignments
     * 
     * 
     * This code handles square and rectangular matrices.
     * It does NOT handle irregular matrices.
     *
     * @param {Array} costMatrix The cost matrix. If this cost matrix is not square,
     *                            it will be padded with DEFAULT_PAD_VALUE. Optionally,
     *                            the pad value can be specified via options.padValue.
     *                            This method does *not* modify the caller's matrix.
     *                            It operates on a copy of the matrix.
     * @param {Object} [options] Additional options to pass in
     * @param {Number} [options.padValue] The value to use to pad a rectangular costMatrix
     * @param {Boolean} [options.matchAny] 	If not set will need to match all requirements. 
	 * 										If set to true, need not match all requirements
     * @return {Array} An array of ``(row, column)`` arrays that describe the lowest
     *                 cost path through the matrix
     */
    compute: function(costMatrix, options) {
        var p = this.MAX_SIZE;
        options = options || {};
        options.padValue = options.padValue || this.DEFAULT_PAD_VALUE;

        this.C = this.padMatrix(costMatrix, options.padValue);
        this.n = this.C.length;
        this.originalLength = costMatrix.length;
        this.originalWidth = costMatrix[0].length;

        var nfalseArray = []; /* array of n false values */
        while (nfalseArray.length &lt; this.n)
            nfalseArray.push(false);
        this.rowCovered = nfalseArray.slice();
        this.colCovered = nfalseArray.slice();
        this.Z0_r = 0;
        this.Z0_c = 0;
        this.path = this._createMatrix(this.n * 2, 0);
        this.marked = this._createMatrix(this.n, 0);

        var step = 1;

        var steps = {
            1: this.__step1,
            2: this.__step2,
            3: this.__step3,
            4: this.__step4,
            5: this.__step5,
            6: this.__step6
        };

        while (true) {
            var func = steps[step];
            if (!func) // done
                break;

            step = func.apply(this);
        }

        var result = {};

        var assignments = [];
        var optimalCost = 0;
        for (var i = 0; i &lt; this.originalLength; ++i) {
            for (var j = 0; j &lt; this.originalWidth; ++j) {
                if (this.marked[i][j] == 1) {
                    if (!options.matchAny) {
                        if (costMatrix[i][j] == this.MAX_SIZE) {
                            result.assignmentPossible = false;
                            return result;
                        }
                        optimalCost += costMatrix[i][j];
                    }
                    assignments.push([i, j]);
                }
            }
        }

        result.assignmentPossible = true;
        result.assignments = assignments;
        result.optimalCost = optimalCost;
        return result;
    },

    /**
     * Create an n√ón matrix, populating it with the specific value.
     *
     * @param {Number} n Matrix dimensions
     * @param {Number} val Value to populate the matrix with
     *
     * @return {Array} An array of arrays representing the newly created matrix
     */
    _createMatrix: function(n, val) {
        var matrix = [];
        for (var i = 0; i &lt; n; ++i) {
            matrix[i] = [];
            for (var j = 0; j &lt; n; ++j)
                matrix[i][j] = val;
        }

        return matrix;
    },

    /**
     * For each row of the matrix, find the smallest element and
     * subtract it from every element in its row. Go to Step 2.
     */
    __step1: function() {
        for (var i = 0; i &lt; this.n; ++i) {
            var minval = Math.min.apply(Math, this.C[i]);
            for (var j = 0; j &lt; this.n; ++j)
                this.C[i][j] -= minval;
        }

        return 2;
    },

    /**
     * Find a zero (Z) in the resulting matrix. If there is no starred
     * zero in its row or column, star Z. Repeat for each element in the
     * matrix. Go to Step 3.
     */
    __step2: function() {
        for (var i = 0; i &lt; this.n; ++i) {
            for (var j = 0; j &lt; this.n; ++j) {
                if (this.C[i][j] === 0 &amp;&amp; !this.colCovered[j] &amp;&amp; !this.rowCovered[i]) {
                    this.marked[i][j] = 1;
                    this.colCovered[j] = true;
                    this.rowCovered[i] = true;
                    break;
                }
            }
        }

        this._clearCovers();

        return 3;
    },

    /**
     * Cover each column containing a starred zero. If K columns are
     * covered, the starred zeros describe a complete set of unique
     * assignments. In this case, Go to DONE, otherwise, Go to Step 4.
     */
    __step3: function() {
        var count = 0;

        for (var i = 0; i &lt; this.n; ++i) {
            for (var j = 0; j &lt; this.n; ++j) {
                if (this.marked[i][j] == 1 &amp;&amp; this.colCovered[j] == false) {
                    this.colCovered[j] = true;
                    ++count;
                }
            }
        }

        return (count &gt;= this.n) ? 7 : 4;
    },


    /**
     * Find a noncovered zero and prime it. If there is no starred zero
     * in the row containing this primed zero, Go to Step 5. Otherwise,
     * cover this row and uncover the column containing the starred
     * zero. Continue in this manner until there are no uncovered zeros
     * left. Save the smallest uncovered value and Go to Step 6.
     */
    __step4: function() {
        var done = false;
        var row = -1,
            col = -1,
            starredCol = -1;

        while (!done) {
            var z = this._findFirstZero();
            row = z[0];
            col = z[1];

            if (row &lt; 0)
                return 6;

            this.marked[row][col] = 2;
            starredCol = this._findStarredInRow(row);
            if (starredCol &gt;= 0) {
                col = starredCol;
                this.rowCovered[row] = true;
                this.colCovered[col] = false;
            } else {
                this.Z0_r = row;
                this.Z0_c = col;
                return 5;
            }
        }
    },

    /**
     * Construct a series of alternating primed(marked 2) and starred(marked 1) zeros as
     * follows. Let Z0 represent the uncovered primed zero found in Step 4.
     * Let Z1 denote the starred zero in the column of Z0 (if any).
     * Let Z2 denote the primed zero in the row of Z1 (there will always
     * be one). Continue until the series terminates at a primed zero
     * that has no starred zero in its column. Unstar each starred zero
     * of the series, star each primed zero of the series, erase all
     * primes and uncover every line in the matrix. Return to Step 3
     */
    __step5: function() {
        var count = 0;

        this.path[count][0] = this.Z0_r;
        this.path[count][1] = this.Z0_c;
        var done = false;

        while (!done) {
            var row = this._findStarredInColumn(this.path[count][1]);
            if (row &gt;= 0) {
                count++;
                this.path[count][0] = row;
                this.path[count][1] = this.path[count - 1][1];
            } else {
                done = true;
            }

            if (!done) {
                var col = this._findPrimeInRow(this.path[count][0]);
                count++;
                this.path[count][0] = this.path[count - 1][0];
                this.path[count][1] = col;
            }
        }

        this._convertPath(this.path, count);
        this._clearCovers();
        this._erasePrimes();
        return 3;
    },

    /**
     * Add the value found in Step 4 to every element of each covered
     * row, and subtract it from every element of each uncovered column.
     * Return to Step 4 without altering any stars, primes, or covered
     * lines.
     */
    __step6: function() {
        var minval = this._findSmallest();

        for (var i = 0; i &lt; this.n; ++i) {
            for (var j = 0; j &lt; this.n; ++j) {
                if (this.rowCovered[i])
                    this.C[i][j] += minval;
                if (!this.colCovered[j])
                    this.C[i][j] -= minval;
            }
        }

        return 4;
    },

    /**
     * Find the smallest uncovered value in the matrix.
     *
     * @return {Number} The smallest uncovered value, or MAX_SIZE if no value was found
     */
    _findSmallest: function() {
        var minval = this.MAX_SIZE;

        for (var i = 0; i &lt; this.n; ++i)
            for (var j = 0; j &lt; this.n; ++j)
                if (!this.rowCovered[i] &amp;&amp; !this.colCovered[j])
                    if (minval &gt; this.C[i][j])
                        minval = this.C[i][j];

        return minval;
    },

    /**
     * Find the first uncovered element with value 0.
     *
     * @return {Array} The indices of the found element or [-1, -1] if not found
     */
    _findFirstZero: function() {
        for (var i = 0; i &lt; this.n; ++i)
            for (var j = 0; j &lt; this.n; ++j)
                if (this.C[i][j] === 0 &amp;&amp;
                    !this.rowCovered[i] &amp;&amp;
                    !this.colCovered[j])
                    return [i, j];

        return [-1, -1];
    },

    /**
     * Find the first starred element in the specified row. Returns
     * the column index, or -1 if no starred element was found.
     *
     * @param {Number} row The index of the row to search
     * @return {Number}
     */

    _findStarredInRow: function(row) {
        for (var j = 0; j &lt; this.n; ++j)
            if (this.marked[row][j] == 1)
                return j;

        return -1;
    },

    /**
     * Find the first starred(marked==1) element in the specified column.
     *
     * @return {Number} The row index, or -1 if no starred element was found
     */
    _findStarredInColumn: function(col) {
        for (var i = 0; i &lt; this.n; ++i)
            if (this.marked[i][col] == 1)
                return i;

        return -1;
    },

    /**
     * Find the first prime(marked==2) element in the specified row.
     *
     * @return {Number} The column index, or -1 if no prime element was found
     */
    _findPrimeInRow: function(row) {
        for (var j = 0; j &lt; this.n; ++j)
            if (this.marked[row][j] == 2)
                return j;

        return -1;
    },

    /**
     * Convert the path such that all starred elements are cleared and all primed elements are starred
     */
    _convertPath: function(path, count) {
        for (var i = 0; i &lt;= count; ++i)
            this.marked[path[i][0]][path[i][1]] =
            (this.marked[path[i][0]][path[i][1]] == 1) ? 0 : 1;
    },

    /** Clear all covered matrix cells */
    _clearCovers: function() {
        for (var i = 0; i &lt; this.n; ++i) {
            this.rowCovered[i] = false;
            this.colCovered[i] = false;
        }
    },

    /** Erase all prime markings */
    _erasePrimes: function() {
        for (var i = 0; i &lt; this.n; ++i)
            for (var j = 0; j &lt; this.n; ++j)
                if (this.marked[i][j] == 2)
                    this.marked[i][j] = 0;
    },

    // ---------------------------------------------------------------------------
    // Functions to modify the matrix
    // ---------------------------------------------------------------------------

    /**
     * Create a cost matrix from a profit matrix by calling
     * 'inversionFunction' to invert each value. The inversion
     * function must take one numeric argument (of any type) and return
     * another numeric argument which is presumed to be the cost inverse
     * of the original profit.
     *
     * For example:
     *
     *  costMatrix = makeCostMatrix(matrix, function(x) { return MAXIMUM - x; });
     *
     * @param {Array} profitMatrix An array of arrays representing the matrix
     *                              to convert from a profit to a cost matrix
     * @param {Function} [inversionFunction] The function to use to invert each
     *                                       entry in the profit matrix
     *
     * @return {Array} The converted matrix
     */
    makeCostMatrix: function(profitMatrix, inversionFunction) {
        var i, j;
        if (!inversionFunction) {
            var maximum = -1.0 / 0.0;
            for (i = 0; i &lt; profitMatrix.length; ++i)
                for (j = 0; j &lt; profitMatrix[i].length; ++j)
                    if (profitMatrix[i][j] &gt; maximum)
                        maximum = profitMatrix[i][j];

            inversionFunction = function(x) {
                return maximum - x;
            };
        }

        var costMatrix = [];

        for (i = 0; i &lt; profitMatrix.length; ++i) {
            var row = profitMatrix[i];
            costMatrix[i] = [];

            for (j = 0; j &lt; row.length; ++j)
                costMatrix[i][j] = inversionFunction(profitMatrix[i][j]);
        }

        return costMatrix;
    },


    type: 'OptimalMatchingAlgorithm'
};]]&gt;&lt;/script&gt;
        &lt;sys_class_name&gt;sys_script_include&lt;/sys_class_name&gt;
        &lt;sys_created_by&gt;admin&lt;/sys_created_by&gt;
        &lt;sys_created_on&gt;2023-03-01 17:09:02&lt;/sys_created_on&gt;
        &lt;sys_id&gt;65ee0f7553192110aa63ddeeff7b125c&lt;/sys_id&gt;
        &lt;sys_mod_count&gt;1&lt;/sys_mod_count&gt;
        &lt;sys_name&gt;OptimalMatchingAlgorithm&lt;/sys_name&gt;
        &lt;sys_package display_value="Field Service Management" source="com.snc.work_management"&gt;b66bd6bb4722c210cd4e1ce4316d4387&lt;/sys_package&gt;
        &lt;sys_policy/&gt;
        &lt;sys_scope display_value="Global"&gt;global&lt;/sys_scope&gt;
        &lt;sys_update_name&gt;sys_script_include_65ee0f7553192110aa63ddeeff7b125c&lt;/sys_update_name&gt;
        &lt;sys_updated_by&gt;admin&lt;/sys_updated_by&gt;
        &lt;sys_updated_on&gt;2023-04-04 09:26:23&lt;/sys_updated_on&gt;
    &lt;/sys_script_include&gt;
&lt;/record_update&gt;
</payload>
        <sys_class_name>sys_metadata_link</sys_class_name>
        <sys_created_by>admin</sys_created_by>
        <sys_created_on>2024-09-21 08:38:01</sys_created_on>
        <sys_id>c3d6f81d83f01210c6695855eeaad308</sys_id>
        <sys_mod_count>0</sys_mod_count>
        <sys_name>OptimalMatchingAlgorithm</sys_name>
        <sys_package display_value="Now Utils" source="x_938076_now_utils">b208a7c083689e50c6695855eeaad3d2</sys_package>
        <sys_policy/>
        <sys_scope display_value="Now Utils">b208a7c083689e50c6695855eeaad3d2</sys_scope>
        <sys_update_name>sys_metadata_link_c3d6f81d83f01210c6695855eeaad308</sys_update_name>
        <sys_updated_by>admin</sys_updated_by>
        <sys_updated_on>2024-09-21 08:38:01</sys_updated_on>
        <tablename>sys_script_include</tablename>
    </sys_metadata_link>
</record_update>
