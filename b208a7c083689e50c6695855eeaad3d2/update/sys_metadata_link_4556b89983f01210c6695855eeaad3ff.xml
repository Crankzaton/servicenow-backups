<?xml version="1.0" encoding="UTF-8"?><record_update table="sys_metadata_link">
    <sys_metadata_link action="INSERT_OR_UPDATE">
        <directory>update</directory>
        <documentkey>34cf658953223010b69addeeff7b129c</documentkey>
        <payload>&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;record_update table="sys_script_include"&gt;
    &lt;sys_script_include action="INSERT_OR_UPDATE"&gt;
        &lt;access&gt;public&lt;/access&gt;
        &lt;active&gt;true&lt;/active&gt;
        &lt;api_name&gt;global.FSMPotentialAssignmentGroupsUtil&lt;/api_name&gt;
        &lt;caller_access/&gt;
        &lt;client_callable&gt;false&lt;/client_callable&gt;
        &lt;description&gt;Utility to populate and inactivate records in the Work Order Task Potential Assignment Groups table.&lt;/description&gt;
        &lt;name&gt;FSMPotentialAssignmentGroupsUtil&lt;/name&gt;
        &lt;script&gt;&lt;![CDATA[var FSMPotentialAssignmentGroupsUtil = Class.create();
FSMPotentialAssignmentGroupsUtil.prototype = {
    initialize: function() {
    },

    //populate potential assignment groups for the work order task
    populateWorkOrderTaskPotentialAssignmentGroups: function(current, assignmentGroups) {

        var assignGroup = assignmentGroups.substring(8);
        var assignGroupArray = assignGroup.split(",");
        var remove;
        var remCount = 0;
        var groupRecs = new GlideRecord('wm_work_order_task_potential_assignment_groups');
        groupRecs.addQuery("work_order_task", current.sys_id);
        groupRecs.addActiveQuery(); //only query for active records
        groupRecs.query();
		/* At the end of this while, there will be 2 distinct lists: remove that has comma separated record ids to be removed and assignGroupArray a list of assignment groups to be added*/
        while (groupRecs.next()) {
            var group = groupRecs.assignment_group.toString();
            var index = assignGroupArray.indexOf(group);
            if (index &gt; -1) { //this assignment group already exists in the table
                assignGroupArray.splice(index, 1); // remove from to be added list
            } else { //needs to be removed from table
                remCount++;
                if (gs.nil(remove))
                    remove = groupRecs.getValue('sys_id');
                else
                    remove += "," + groupRecs.getValue('sys_id');
            }
        }
       
        i = 0;
        var remRec = new GlideRecord('wm_work_order_task_potential_assignment_groups');
        remRec.addQuery("sys_id", "IN", remove);
        remRec.query();
		// as long as there are both records to be added and removed, replace the assignment group with ones in the added array
        while (remCount &gt; 0 &amp;&amp; i &lt; assignGroupArray.length) {
            remRec.next();
            remRec.assignment_group = assignGroupArray[i];
            remRec.active = true;
            remRec.update();
            remCount--;
            i++;
        }
		//if additional records need to be removed by making inactive.
		while (remCount &gt; 0) {
            remRec.next();
            remRec.active = false;
            remRec.update();
			remCount--;
        }
        //if there are additional records to be inserted.
        var insertGR = new GlideRecord('wm_work_order_task_potential_assignment_groups');
        while (i &lt; assignGroupArray.length) {
			insertGR.initialize();
            insertGR.assignment_group = assignGroupArray[i];
			insertGR.work_order_task = current.sys_id;
			insertGR.insert();
            i++;
        }


    },
   
    //if work order task is cancelled or a single match of assignment group has been found inactivate the corresponding records
    inactivatePotentialAssignmentGroups: function(currentWorkOrderTaskId) {
        var inactivateGR = new GlideRecord('wm_work_order_task_potential_assignment_groups');
        inactivateGR.addQuery("work_order_task", current.sys_id);
        inactivateGR.query();
        while (inactivateGR.next()) {
            inactivateGR.active = false;
            inactivateGR.update();
        }
    },



    type: 'FSMPotentialAssignmentGroupsUtil'
};]]&gt;&lt;/script&gt;
        &lt;sys_class_name&gt;sys_script_include&lt;/sys_class_name&gt;
        &lt;sys_created_by&gt;admin&lt;/sys_created_by&gt;
        &lt;sys_created_on&gt;2021-09-10 16:51:06&lt;/sys_created_on&gt;
        &lt;sys_id&gt;34cf658953223010b69addeeff7b129c&lt;/sys_id&gt;
        &lt;sys_mod_count&gt;1&lt;/sys_mod_count&gt;
        &lt;sys_name&gt;FSMPotentialAssignmentGroupsUtil&lt;/sys_name&gt;
        &lt;sys_package display_value="Field Service Management" source="com.snc.work_management"&gt;b66bd6bb4722c210cd4e1ce4316d4387&lt;/sys_package&gt;
        &lt;sys_policy/&gt;
        &lt;sys_scope display_value="Global"&gt;global&lt;/sys_scope&gt;
        &lt;sys_update_name&gt;sys_script_include_34cf658953223010b69addeeff7b129c&lt;/sys_update_name&gt;
        &lt;sys_updated_by&gt;admin&lt;/sys_updated_by&gt;
        &lt;sys_updated_on&gt;2021-09-10 17:40:30&lt;/sys_updated_on&gt;
    &lt;/sys_script_include&gt;
&lt;/record_update&gt;
</payload>
        <sys_class_name>sys_metadata_link</sys_class_name>
        <sys_created_by>admin</sys_created_by>
        <sys_created_on>2024-09-21 08:35:42</sys_created_on>
        <sys_id>4556b89983f01210c6695855eeaad3ff</sys_id>
        <sys_mod_count>0</sys_mod_count>
        <sys_name>FSMPotentialAssignmentGroupsUtil</sys_name>
        <sys_package display_value="Now Utils" source="x_938076_now_utils">b208a7c083689e50c6695855eeaad3d2</sys_package>
        <sys_policy/>
        <sys_scope display_value="Now Utils">b208a7c083689e50c6695855eeaad3d2</sys_scope>
        <sys_update_name>sys_metadata_link_4556b89983f01210c6695855eeaad3ff</sys_update_name>
        <sys_updated_by>admin</sys_updated_by>
        <sys_updated_on>2024-09-21 08:35:42</sys_updated_on>
        <tablename>sys_script_include</tablename>
    </sys_metadata_link>
</record_update>
