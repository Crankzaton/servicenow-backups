<?xml version="1.0" encoding="UTF-8"?><record_update table="sys_metadata_link">
    <sys_metadata_link action="INSERT_OR_UPDATE">
        <directory>update</directory>
        <documentkey>6510234e77463110411d94b92c5a9926</documentkey>
        <payload>&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;record_update table="sys_script_include"&gt;
    &lt;sys_script_include action="INSERT_OR_UPDATE"&gt;
        &lt;access&gt;public&lt;/access&gt;
        &lt;active&gt;true&lt;/active&gt;
        &lt;api_name&gt;global.SNCACLWidgetUtil&lt;/api_name&gt;
        &lt;caller_access/&gt;
        &lt;client_callable&gt;false&lt;/client_callable&gt;
        &lt;description/&gt;
        &lt;name&gt;SNCACLWidgetUtil&lt;/name&gt;
        &lt;script&gt;&lt;![CDATA[var SNCACLWidgetUtil = Class.create();
SNCACLWidgetUtil.prototype = {
    initialize: function() {
        this.SP_PAGE_PATH = '/api/now/sp/page';
        this.SP_WIDGET_PATH = '/api/now/sp/widget';
        this.SP_RECTANGLE_PATH = '/api/now/sp/rectangle';
        this.DEBUG_ENABLED = gs.getProperty('glide.service_portal.widget.enforce_public_check.debug', false);
    },
    /*
		Call this from public Service Portal widget. This will help provide additional guard rails for public or unauthenticated use cases.
		Will do the following checks
		a. If the session is authenticated we return true.
		b. If glide.service_portal.widget.enforce_public_check property is set to false we revert to old behavior.
		c. If the request is invoking a widget then we check if they are in any of the below properties
		    glide.service_portal.widget.allow_list: Comma seperated widget sys_ids
			glide.service_portal.widget.table_allow_list: Comma seperated table names
		d. Disallow if did not meet above conditions
		Example Invocation: For "Simple List" public SP widget
			if (!new SNCACLWidgetUtil().hasPublicAccess('5b255672cb03020000f8d856634c9c28', options.table, ['t', 'f'], options, input)) {
				data.isValid = false;
				return;
			}
	 */
    hasPublicAccess: function(widgetSysid, tableName, param_array, options, input) {
        // Authentication check
        if (gs.isLoggedIn())
            return true;
        // Global kill switch property for widgets
        if (gs.getProperty('glide.service_portal.widget.enforce_public_check', true) == "false") {
            this.debugLogInfo("glide.service_portal.widget.enforce_public_check: " + false);
            return true; // Revert to old behavior
        }

        var requestedUrlPath = GlideTransaction.get().getURL();

        //log POST calls
        if (requestedUrlPath &amp;&amp; (requestedUrlPath.startsWith(this.SP_RECTANGLE_PATH) || requestedUrlPath.startsWith(this.SP_WIDGET_PATH))) {
            if (gs.getProperty('glide.service_portal.api.post.log', true) == 'true') { //kill switch
                try {
                    var request = GlideTransaction.get().getRequest();
                    if (request &amp;&amp; 'POST'.equals(request.getMethod())) { //Only for POST request
                        var result = {};
                        result.widgetSysid = widgetSysid;
                        result.requestedUrlPath = requestedUrlPath;
                        result.options = options;
                        result.input = input;
                        if (result.options &amp;&amp; result.options.widget_parameters)
                            delete result.options.widget_parameters;
                        if (result.input &amp;&amp; result.input.widget_parameters)
                            delete result.input.widget_parameters;
                        var params = {};
                        var paramNames = request.getParameterNames();
                        while (paramNames.hasMoreElements()) {
                            var param = paramNames.nextElement();
                            params[param + ''] = request.getParameter(param) + '';
                        }
                        result.params = params;

                        if (widgetSysid === '6aa614003b410300d6bf2479b3efc4c1' || widgetSysid === 'f9887149cb103200b2d05ea3434c9c92') {
                            gs.error('SNCACLWidgetUtil log: {0}', JSON.stringify(result));
                        } else {
                            gs.info('SNCACLWidgetUtil log: {0}', JSON.stringify(result));
                        }

                    }
                } catch (err) {
                    this.debugLogInfo('Exception: Logging for POST failed: ' + err);
                }
            }
        }

        // Verify the widget is restricted for rectangle calls or not? if yes, proceed to further validation.
        if (requestedUrlPath &amp;&amp; !requestedUrlPath.startsWith(this.SP_WIDGET_PATH) &amp;&amp;
            (!requestedUrlPath.startsWith(this.SP_RECTANGLE_PATH) || !this.isWidgetRestrictedForRectangleCall(widgetSysid)))
            return true;

        // At this point we are considering SP Widget
        // and default deny unless properties are configured
        if (this.isWidgetInAllowList(widgetSysid)) {
            this.debugLogInfo("isWidgetInAllowList: " + widgetSysid);
            return true;
        }
        if (this.isTableInAllowList(tableName)) {
            this.debugLogInfo("isTableInAllowList: " + tableName);
            return true;
        }
        this.debugLogInfo('Not allowed by Widget or Table allow lists');
        return false;
    },

    isWidgetInAllowList: function(widgetSysid) {
        var widgetSysid_allow_list = GlideStringUtil.split(gs.getProperty('glide.service_portal.widget.allow_list'));
        return widgetSysid_allow_list.indexOf(widgetSysid) &gt; -1;
    },

    isTableInAllowList: function(tableName) {
        var table_allow_list = GlideStringUtil.split(gs.getProperty('glide.service_portal.widget.table_allow_list'));
        return table_allow_list.indexOf(tableName) &gt; -1;
    },

    isWidgetRestrictedForRectangleCall: function(widgetSysid) {
        var widgetSysid_allow_list = GlideStringUtil.split(gs.getProperty('glide.service_portal.restricted.widgets.for_rectangle_calls'));
        return widgetSysid_allow_list.indexOf(widgetSysid) &gt; -1;
    },

    debugLogInfo: function(message) {
        if (this.DEBUG_ENABLED == "true") {
            gs.info("SNCACLWidgetUtil: " + message);
        }
    },
    type: 'SNCACLWidgetUtil'
};]]&gt;&lt;/script&gt;
        &lt;sys_class_name&gt;sys_script_include&lt;/sys_class_name&gt;
        &lt;sys_created_by&gt;admin&lt;/sys_created_by&gt;
        &lt;sys_created_on&gt;2023-11-21 06:21:44&lt;/sys_created_on&gt;
        &lt;sys_id&gt;6510234e77463110411d94b92c5a9926&lt;/sys_id&gt;
        &lt;sys_mod_count&gt;1&lt;/sys_mod_count&gt;
        &lt;sys_name&gt;SNCACLWidgetUtil&lt;/sys_name&gt;
        &lt;sys_package display_value="Schema for contextual security" source="com.glide.security_schema"&gt;1d23f4603c31311068bcf327dfe37f0c&lt;/sys_package&gt;
        &lt;sys_policy&gt;read&lt;/sys_policy&gt;
        &lt;sys_scope display_value="Global"&gt;global&lt;/sys_scope&gt;
        &lt;sys_update_name&gt;sys_script_include_6510234e77463110411d94b92c5a9926&lt;/sys_update_name&gt;
        &lt;sys_updated_by&gt;admin&lt;/sys_updated_by&gt;
        &lt;sys_updated_on&gt;2023-11-21 06:21:44&lt;/sys_updated_on&gt;
    &lt;/sys_script_include&gt;
&lt;/record_update&gt;
</payload>
        <sys_class_name>sys_metadata_link</sys_class_name>
        <sys_created_by>admin</sys_created_by>
        <sys_created_on>2024-09-21 08:37:57</sys_created_on>
        <sys_id>d6d6b81d83f01210c6695855eeaad38a</sys_id>
        <sys_mod_count>0</sys_mod_count>
        <sys_name>SNCACLWidgetUtil</sys_name>
        <sys_package display_value="Now Utils" source="x_938076_now_utils">b208a7c083689e50c6695855eeaad3d2</sys_package>
        <sys_policy/>
        <sys_scope display_value="Now Utils">b208a7c083689e50c6695855eeaad3d2</sys_scope>
        <sys_update_name>sys_metadata_link_d6d6b81d83f01210c6695855eeaad38a</sys_update_name>
        <sys_updated_by>admin</sys_updated_by>
        <sys_updated_on>2024-09-21 08:37:57</sys_updated_on>
        <tablename>sys_script_include</tablename>
    </sys_metadata_link>
</record_update>
