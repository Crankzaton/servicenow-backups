<?xml version="1.0" encoding="UTF-8"?><record_update table="sys_metadata_link">
    <sys_metadata_link action="INSERT_OR_UPDATE">
        <directory>update</directory>
        <documentkey>0081ff73132002003ff3691c2c6a5e0f</documentkey>
        <payload>&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;record_update table="sys_script_include"&gt;
    &lt;sys_script_include action="INSERT_OR_UPDATE"&gt;
        &lt;access&gt;package_private&lt;/access&gt;
        &lt;active&gt;true&lt;/active&gt;
        &lt;api_name&gt;global.ITFM_Budgeting&lt;/api_name&gt;
        &lt;caller_access/&gt;
        &lt;client_callable&gt;true&lt;/client_callable&gt;
        &lt;description/&gt;
        &lt;name&gt;ITFM_Budgeting&lt;/name&gt;
        &lt;script&gt;&lt;![CDATA[var ITFM_Budgeting = Class.create();
var _budgeting = new SNC.BudgetingScriptable();

ITFM_Budgeting.prototype = Object.extendsObject(AbstractAjaxProcessor, {
	calendarType_THIRTEEN_PERIOD : '13 Period',
	calendarType_FOURFOURFIVE : '445',
	calendarType_FOURFIVEFOUR : '454',
	calendarType_FIVEFOURFOUR : '544',
	fiscalType_PERIODIN13PERIOD : 'quadweek',
	fiscalType_PERIODINFOURFOURFIVE : '445period',

	hasBudgetingRoles: function() {
		return gs.hasRole('budget_owner') || gs.hasRole('budget_admin') || gs.hasRole('budget_analyst');
	},

	budgetModelExists: function(modelId) {
		var budgetModel = new GlideRecord('itfm_cost_model');
		budgetModel.addQuery('budgeting', true);
		budgetModel.addQuery('sys_id', modelId);
		budgetModel.query();
		return budgetModel.hasNext();
	},

	generateBudgetKeysForCostModel: function () {
		/* Roles Check */
		if(!this.hasBudgetingRoles()) {
			gs.addErrorMessage(gs.getMessage('Security constraints prevent access to requested page. Cannot proceed with generation of Budget Keys.'));
			return;
		}

		var costModelId = this.getParameter('sysparm_cost_model');

		/* Budget Model Existence Check */
		if(!this.budgetModelExists(costModelId)) {
			gs.addErrorMessage(gs.getMessage('Budget Model is invalid. Cannot proceed with generation of Budget Keys.'));
			return;
		}

		_budgeting.generateBudgetKeys(costModelId);
	},

	generateActuals: function () {
		/* Roles Check */
		if(!this.hasBudgetingRoles()) {
			gs.addErrorMessage(gs.getMessage('Security constraints prevent access to requested page. Cannot proceed with generation of Actuals.'));
			return;
		}

		var costModelId = this.getParameter('sysparm_cost_model');

		/* Budget Model Existence Check */
		if(!this.budgetModelExists(costModelId)) {
			gs.addErrorMessage(gs.getMessage('Budget Model is invalid. Cannot proceed with generation of Actuals.'));
			return;
		}

		var script = "(new SNC.BudgetingScriptable()).generateActualsForAllFiscalPeriods(\'"+costModelId+"\');";
		var sched = new ScheduleOnce();
		sched.script = script;
		sched.setTime(gs.nowNoTZ());
		sched.setLabel("ITFM: Generate Actuals from General Ledger for Cost Model "+costModelId);
		sched.schedule();
		gs.addInfoMessage(gs.getMessage("Scheduled Job to Populate Actuals"));
	},

	getUserIdFromBudgetOwnerSysId: function (budgetOwnerSysId) {
		var grBudgetOwner = new GlideRecord('itfm_budget_owner');
		if (grBudgetOwner.get(budgetOwnerSysId)) {
			return grBudgetOwner.user;
		}
	},

	getBudgetOwnerSysIdFromUserId: function (budgetOwnerUserId) {
		var grBudgetOwner = new GlideRecord('itfm_budget_owner');
		grBudgetOwner.addQuery('user',budgetOwnerUserId);
		grBudgetOwner.setLimit(1);
		grBudgetOwner.query();
		if(grBudgetOwner.next()){
			return grBudgetOwner.getUniqueValue();
		}
		return "";
	},

	isUserPartOfBudgetKeyOwnership: function (userId, budgetKey) {
		if (this.getBudgetKeyOwnershipWithUserId(userId, budgetKey) != "empty") {
			return true;
		}
		return false;
	},

	isUserPartOfBudgetKeyOwnershipWithSysId: function (budgetOwnerSysId, budgetKey) {
		if (this.getBudgetKeyOwnershipWithUserSysId(budgetOwnerSysId, budgetKey) != "empty") {
			return true;
		}
		return false;
	},

	isUserPartOfFullBudgetKeyOwnership: function (userId, budgetKey) {
		if (this.getBudgetKeyOwnershipWithUserId(userId, budgetKey) == "full") {
			return true;
		}
		return false;
	},

	isUserPartOfFullBudgetKeyOwnershipWithSysId: function (budgetOwnerSysId, budgetKey) {
		if (this.getBudgetKeyOwnershipWithUserSysId(budgetOwnerSysId, budgetKey) == "full") {
			return true;
		}
		return false;
	},

	isUserParentOfUserPartOfBudgetKeyOwnership: function(userId, budgetKey, budgetOwnerUserId) {
		var childBudgetOwnerUserIds = this.getChildBudgetOwnerUserIds(userId);
		for(var i = 0; i &lt; childBudgetOwnerUserIds.length; i++) {
			if(this.isUserPartOfBudgetKeyOwnership(childBudgetOwnerUserIds[i], budgetKey)) {
				if(!budgetOwnerUserId || (budgetOwnerUserId &amp;&amp; childBudgetOwnerUserIds[i] == budgetOwnerUserId))
					return true;
			}
		}
		return false;
	},

	isUserParentOfUserPartOfFullBudgetKeyOwnership: function(userId, budgetKey) {
		var childBudgetOwnerUserIds = this.getChildBudgetOwnerUserIds(userId);
		for(var i = 0; i &lt; childBudgetOwnerUserIds.length; i++) {
			if(this.isUserPartOfFullBudgetKeyOwnership(childBudgetOwnerUserIds[i], budgetKey)) {
				return true;
			}
		}
		return false;
	},
	/*
	* return full - when budget owner has full access to budgetKey or parent key of budgetKey
	* return limited - when budget owner has limit access to budget Key or parent key of budgetKey
	*/
	getBudgetKeyOwnershipWithUserSysId : function(budgetOwnerSysId, budgetKey) {
		var that = this;

		//Check if budket key is under any key that the user has full access to
		var bko = new GlideRecord('itfm_budget_key_owner');
		bko.addQuery('budget_owner',budgetOwnerSysId);
		bko.addQuery('access_level','full');
		bko.query();
		while(bko.next()) {
			var tempBudgetKey = bko.budget_key;
			if(that.isChildOfKey(budgetKey,tempBudgetKey)){
				return bko.access_level;
			}
		}

		//if no, check limit access
		bko = new GlideRecord('itfm_budget_key_owner');
		bko.addQuery('budget_owner',budgetOwnerSysId);
		bko.addQuery('access_level','limited');
		bko.query();
		while(bko.next()) {
			var tempBudgetKeyLimit = bko.budget_key;
			if(that.isChildOfKey(budgetKey,tempBudgetKeyLimit)){
				return bko.access_level;
			}
		}

		// no access at all
		return "empty";
	},

	getBudgetKeyOwnershipWithUserId : function (userId, budgetKey) {
		var budgetOwnerSysId = this.getBudgetOwnerSysIdFromUserId(userId);
		return this.getBudgetKeyOwnershipWithUserSysId(budgetOwnerSysId,budgetKey);
	},

	isPromoteVisible: function (current) {
		if (!current.getValue("parent_budget_plan") || 0 === current.getValue("parent_budget_plan").length) {
			var periodTable = (current.getTableName() == 'itfm_budget_plan' ? 'itfm_budget_period' : 'itfm_forecast_period');
			var periodColumn = (current.getTableName() == 'itfm_budget_plan' ? 'budget_period' : 'forecast_period');
			var periodGr = new GlideRecord(periodTable);

			if(periodGr.get(periodColumn, current.fiscal_period)){
				return this.isUserPartOfBudgetKeyOwnershipWithSysId(current.budget_owner, current.budget_key) &amp;&amp; periodGr.open_flag;
			}
		}
		return false;
	},
	compareCurrentIdWithRecordOwnerId: function (recordOwnerID, currentUserID) {
		gs.log('Comparing IDs');
		//find if the currentUserID is recordOwner
		if (recordOwnerID == currentUserID) {
			return true;
		}

		//find if the currentUserID is parent of recordOwner
		else {
			var currentID = "";
			var recordID = "";
			var get1 = new GlideRecord("itfm_budget_owner");
			get1.addQuery("user", currentUserID);
			get1.query();
			if (get1.next()) {
				currentID = get1.getValue("sys_id");
			}
			var get2 = new GlideRecord("itfm_budget_owner");
			get2.addQuery("user", recordOwnerID);
			get2.query();
			if (get2.next()) {
				recordID = get2.getValue("sys_id");
			}
			if (currentID !== "" &amp;&amp; recordID !== "") {
				var gr = new GlideRecord("itfm_budget_owner");
				gr.addQuery("sys_id", recordID);
				gr.query();
				gr.next();

				while (gr.getValue('parent_budget_owner') !== null &amp;&amp; gr.getValue('parent_budget_owner') != currentID) {
					var temp = new GlideRecord("itfm_budget_owner");
					temp.addQuery("sys_id", gr.getValue('parent_budget_owner'));
					temp.query();
					if (temp.next()) {
						gr = temp;
					} else {
						gr.next();
					}
				}
				if (gr.getValue('parent_budget_owner') == currentID) {
					return true;
				}
			}
		}
	},

	validPeriodsForPlan: function () {
		// If current plan has a parent budget plan, then the sub plan can only refer to the fiscal period of parent budget plan
		if (JSUtil.notNil(current.parent_budget_plan))
			return this.buildCondition('sys_id', current.parent_budget_plan.fiscal_period, '');

		// if current is a budget plan, then fiscal periods will be yearly
		if(current.getTableName() == 'itfm_budget_plan')
			return this.buildCondition('fiscal_type', 'year', '');

		// if current is a forecast plan, then forecast periods will be accordingly returned
		if(current.getTableName() == 'itfm_forecast_plan')
			return this.getForecastPeriods(current.itfm_budget_plan.fiscal_period);

		return '';

	},

	getAllForecastPeriods: function() {
		var fiscalYear = null;
		var otherFiscalYears = [];

		var condition = 'sys_id=';

		var budgetPeriodGR = new GlideRecord('itfm_budget_period');
		budgetPeriodGR.query();

		if(budgetPeriodGR.next()) {
			fiscalYear = budgetPeriodGR.getValue('budget_period');
		}
		while(budgetPeriodGR.next()) {
			otherFiscalYears.push(budgetPeriodGR.getValue('budget_period'));
		}

		if(fiscalYear) {
			condition = this.getForecastPeriods(fiscalYear, otherFiscalYears);
		}
		return condition;
	},

	getForecastPeriods: function(fiscalYear, otherFiscalYears) {
		var condition = '';

		if(JSUtil.notNil(fiscalYear)) {
			var breakDownInfo = this.getPeriodBreakdownMethod(fiscalYear);
			var parentPeriod = '';
			condition += this.buildCondition('fiscal_type', breakDownInfo.type, '');

			parentPeriod = (breakDownInfo.type  == this.fiscalType_PERIODIN13PERIOD ? 'parent_period' : 'parent_period.parent_period');
			condition = this.buildCondition('fiscal_type', breakDownInfo.type, '');
			condition += this.buildCondition(parentPeriod, fiscalYear, '^');
			if(otherFiscalYears) {
				for(var fyIdx = 0; fyIdx &lt; otherFiscalYears.length; fyIdx++) {
					condition += this.buildCondition(parentPeriod, otherFiscalYears[fyIdx], '^OR');
				}
			}
		}

		return condition;
	},

	buildCondition: function(key, value, operation){
		return operation + key + '=' + value;
	},

	updateBudgetItemCurrency: function (current) {
		// current is expected to be any glide record object of budget item itself or its heirs
		// this function throws NoFiscalPeriodException and NoBudgetReferenceRateException

		if (!current) return;

		var exchangeRate, exchangeRateID, exchangeRateGlobal, exchangeRateGlobalID;
		var existingBreakdowns = new GlideRecord('itfm_bi_breakdown');

		existingBreakdowns.addQuery('budget_item', current.sys_id);
		existingBreakdowns.query();
		while (existingBreakdowns.next()) {
			exchangeRate = this.defaultExchangeRateOfBudgetItem(existingBreakdowns);
			if (exchangeRate === null || exchangeRate === undefined)
				exchangeRateID = 'NULL';
			else
				exchangeRateID = exchangeRate.getUniqueValue();

			exchangeRateGlobal = this.defaultGlobalExchangeRateOfBudgetItem(existingBreakdowns);
			if (exchangeRateGlobal === null || exchangeRateGlobal === undefined)
				exchangeRateGlobalID = 'NULL';
			else
				exchangeRateGlobalID = exchangeRateGlobal.getUniqueValue();
			existingBreakdowns.setValue("fx_rate_plan", exchangeRateID);
			existingBreakdowns.setValue("fx_rate", exchangeRateGlobalID);
			existingBreakdowns.update();
		}
	},

	getPeriodBreakdownMethod: function (fiscalYearId) {
		var number = 12;
		var type = 'month';
		var divideByWeek = false;
		var calendarType = gs.getProperty('com.glide.fiscal_calendar.fiscal_calendar_type');
		if(calendarType == this.calendarType_THIRTEEN_PERIOD) {
			number = 13;
			type = this.fiscalType_PERIODIN13PERIOD;
		} else if(calendarType == this.calendarType_FOURFOURFIVE ||
				 calendarType == this.calendarType_FOURFIVEFOUR ||
				 calendarType == this.calendarType_FIVEFOURFOUR) {
			type = this.fiscalType_PERIODINFOURFOURFIVE;
			number = new SNC.FiscalCalendar().getWeeksInPeriod(fiscalYearId);
			divideByWeek = true;
		}

		return {number: number, type: type, divideByWeek: divideByWeek};
	},

	defaultBudgetItemBreakdown: function (current) {
		// current is expected to be a glide record object of budget item, labor, external labor, hardware, or software
		// this function throws NoFiscalPeriodException and NoBudgetReferenceRateException
		if (!current)
			return;
		gs.log("defaultBudgetItemBreakdown");

		var currencyService = new SNC.FMCurrency();
		var fiscalCalendar = new SNC.FiscalCalendar();
		var bp = new GlideRecord('itfm_budget_plan');
		bp.get(current.budget_plan);

        var fiscalPeriodSysId = bp.fiscal_period;
        var fiscalPeriodStartDate = bp.fiscal_period.fiscal_start_date_time;
        var fiscalPeriodEndDate = bp.fiscal_period.fiscal_end_date_time;

        var fiscalYearGr = new SNC.FiscalCalendar().getFiscalYearForDate(fiscalPeriodStartDate);
		var fiscalYearSysId = fiscalYearGr.getUniqueValue();
		var fiscalYearStartDate = new SNC.FiscalCalendar().getPeriodStartDate(fiscalYearSysId);
		var fiscalYearEndDate = new SNC.FiscalCalendar().getPeriodEndDate(fiscalYearSysId);

        var divideInfo = this.getPeriodBreakdownMethod(fiscalYearSysId);
		var totalPeriod = divideInfo.number;
		var periodType = divideInfo.type;
		var divideByWeek = divideInfo.divideByWeek;
		var periodLocalCost = 0;
		var itemLocalCost = -1;
		var executionDate = "";
		var executionEndDate = "";

        var numberOfPeriods = 1;
		var isLabor = (current.getValue("sys_class_name") === "itfm_bi_labor" ? true : false);
        var isForecastPlan = (current.getTableName() == 'itfm_budget_plan' ? false : true);
        if(isForecastPlan) {
            numberOfPeriods = this.getNumberOfPeriods(fiscalPeriodStartDate, fiscalYearEndDate, totalPeriod, periodType, divideByWeek);
            totalPeriod = numberOfPeriods;
        }
		//calculate the total for each sub period
		if ((!current.planned_execution_date &amp;&amp; !current.actual_execution_date) &amp;&amp;
			(!current.planned_execution_end_date &amp;&amp; !current.actual_execution_end_date)) {
			if (current.is_monthly) {
				periodLocalCost = (current.unit_cost_local * current.quantity);
			} else {
				periodLocalCost = (current.unit_cost_local * current.quantity) / totalPeriod;
			}
		}
		if (current.planned_execution_date) {
			executionDate = current.planned_execution_date;
		}
		if (current.actual_execution_date) {
			executionDate = current.actual_execution_date;
		}

		if (current.planned_execution_end_date) {
			executionEndDate = current.planned_execution_end_date;
		}
		if (current.actual_execution_end_date) {
			executionEndDate = current.actual_execution_end_date;
		}
		//generate breakdown of the item if none exists
		var totalLocalCost = 0, totalPlanCost = 0, totalGlobalCost = 0, overrideLocalCost;
		var existingBreakdowns = new GlideRecord('itfm_bi_breakdown');
		existingBreakdowns.addQuery('budget_item', current.sys_id);
		existingBreakdowns.query();
		if (existingBreakdowns.getRowCount() === 0) {

			if (periodLocalCost === 0) {
				var fpy = new GlideRecord('fiscal_period');
				fpy.addQuery('sys_id', fiscalYearSysId);
				fpy.query();
				if (fpy.next()) {
					if (executionDate === "") {
						executionDate = (isForecastPlan ? fiscalPeriodStartDate : fiscalYearStartDate);
					}
					if (executionEndDate === "") {
						executionEndDate = fiscalYearEndDate;
					}
// 					if (!this.isExecutionDateInFPRange(fpy, executionDate, executionEndDate)) {
// 						itemLocalCost = 0;
// 					}
//					else {
						itemLocalCost = (current.unit_cost_local * current.quantity);
						numberOfPeriods = this.getNumberOfPeriods(executionDate, executionEndDate, totalPeriod, periodType, divideByWeek);
//					}
				}

			}
			//get all the fiscal months in the year
			var fpm = new GlideRecord('fiscal_period');
			fpm.addQuery('fiscal_year', fiscalYearSysId);
			fpm.addQuery('fiscal_type', periodType);
            if (isForecastPlan)
                fpm.addQuery('fiscal_start_date_time','&gt;=', fiscalPeriodStartDate);
			fpm.orderBy('fiscal_start_date_time');
			fpm.query();
			var exchangeRate, exchangeRateID, exchangeRateGlobal, exchangeRateGlobalID;
			while (fpm.next()) {
				var monthLocalCost = (!current.is_monthly &amp;&amp; divideByWeek) ? periodLocalCost * (fiscalCalendar.getWeeksInPeriod(fpm.sys_id)) : periodLocalCost;
				var newBreakdowns = new GlideRecord('itfm_bi_breakdown');
				newBreakdowns.initialize();
				newBreakdowns.setValue('budget_item', current.sys_id);
				newBreakdowns.setValue('fiscal_period', fpm.sys_id);
				//get currency rate
				exchangeRate = this.defaultExchangeRateOfBudgetItem(newBreakdowns);
				if (exchangeRate === null || exchangeRate === undefined)
					exchangeRateID = 'NULL';
				else
					exchangeRateID = exchangeRate.getUniqueValue();
				exchangeRateGlobal = this.defaultGlobalExchangeRateOfBudgetItem(newBreakdowns);
				if (exchangeRateGlobal === null || exchangeRateGlobal === undefined)
					exchangeRateGlobalID = 'NULL';
				else
					exchangeRateGlobalID = exchangeRateGlobal.getUniqueValue();
				newBreakdowns.setValue('fx_rate_plan', exchangeRateID);
				newBreakdowns.setValue('fx_rate', exchangeRateGlobalID);
				if (itemLocalCost &gt;= 0) {
					monthLocalCost = this.getMonthlyCost(executionDate, executionEndDate, fpm, itemLocalCost, numberOfPeriods, isLabor, current.is_monthly, current.is_prorated, totalPeriod, divideByWeek);
				}
				newBreakdowns.setValue('cost', monthLocalCost);
				newBreakdowns.insert();
				totalLocalCost = totalLocalCost + monthLocalCost;
				totalPlanCost = totalPlanCost + currencyService.calculateAmount(monthLocalCost, exchangeRateID);
				totalGlobalCost = totalGlobalCost + currencyService.calculateAmount(monthLocalCost, exchangeRateGlobalID);
			}
		}
		else {
			var fpmArray = [];
			if (periodLocalCost === 0) {
				var fpy = new GlideRecord('fiscal_period');
				fpy.addQuery('sys_id', fiscalYearSysId);
				fpy.query();
				if (fpy.next()) {
					if (executionDate === "") {
						executionDate = (isForecastPlan ? fiscalPeriodStartDate : fiscalYearStartDate);
					}
					if (executionEndDate === "") {
						executionEndDate = fiscalYearEndDate;
					}
// 					if (!this.isExecutionDateInFPRange(fpy, executionDate, executionEndDate)) {
// 						itemLocalCost = 0;
// 					}
//					else {
						itemLocalCost = (current.unit_cost_local * current.quantity);
						numberOfPeriods = this.getNumberOfPeriods(executionDate, executionEndDate, totalPeriod, periodType, divideByWeek);
//					}
				}
				//get all the fiscal months in the year
				var fpm = new GlideRecord('fiscal_period');
				fpm.addQuery('fiscal_year', fiscalYearSysId);
				fpm.addQuery('fiscal_type', periodType);
                if (isForecastPlan)
                    fpm.addQuery('fiscal_start_date_time','&gt;=', fiscalPeriodStartDate);
				fpm.orderBy('fiscal_start_date_time');
				fpm.query();
				var fiscalPeriodBreakDownIDMap = {};
				while (existingBreakdowns.next()) {
					fiscalPeriodBreakDownIDMap[existingBreakdowns.getValue("fiscal_period")] = existingBreakdowns.getValue("sys_id");
				}
				while (fpm.next()) {
					var existingBreakdown = new GlideRecord('itfm_bi_breakdown');
					existingBreakdown.get(fiscalPeriodBreakDownIDMap[fpm.sys_id]);
					periodLocalCost = this.getMonthlyCost(executionDate, executionEndDate, fpm, itemLocalCost, numberOfPeriods, isLabor, current.is_monthly, current.is_prorated, totalPeriod, divideByWeek);
					existingBreakdown.setValue('cost', periodLocalCost);
					if (existingBreakdown.getValue('override_cost') !== null &amp;&amp; existingBreakdown.getValue('override_cost') !== '') {
						overrideLocalCost = Number(existingBreakdown.getValue('override_cost'));
						totalLocalCost = totalLocalCost + overrideLocalCost;
						totalPlanCost = totalPlanCost +
							currencyService.calculateAmount(overrideLocalCost, existingBreakdown.getValue("fx_rate_plan"));
						totalGlobalCost = totalGlobalCost +
							currencyService.calculateAmount(overrideLocalCost, existingBreakdown.getValue("fx_rate"));
					}
					else {
						totalLocalCost = totalLocalCost + periodLocalCost;
						totalPlanCost = totalPlanCost +
							currencyService.calculateAmount(periodLocalCost, existingBreakdown.getValue("fx_rate_plan"));
						totalGlobalCost = totalGlobalCost +
							currencyService.calculateAmount(periodLocalCost, existingBreakdown.getValue("fx_rate"));
					}
					existingBreakdown.setWorkflow(false);
					existingBreakdown.update();
				}
			}
			//update the existing breakdowns
			else {
				while (existingBreakdowns.next()) {
					var monthLocalCost = (!current.is_monthly &amp;&amp; divideByWeek) ? periodLocalCost * (fiscalCalendar.getWeeksInPeriod(existingBreakdowns.fiscal_period)) : periodLocalCost;
					existingBreakdowns.setValue('cost', monthLocalCost);
					if (existingBreakdowns.getValue('override_cost') !== null &amp;&amp; existingBreakdowns.getValue('override_cost') !== '') {
						overrideLocalCost = Number(existingBreakdowns.getValue('override_cost'));
						totalLocalCost = totalLocalCost + overrideLocalCost;
						totalPlanCost = totalPlanCost +
							currencyService.calculateAmount(overrideLocalCost, existingBreakdowns.getValue("fx_rate_plan"));
						totalGlobalCost = totalGlobalCost +
							currencyService.calculateAmount(overrideLocalCost, existingBreakdowns.getValue("fx_rate"));
					}
					else {
						totalLocalCost = totalLocalCost + monthLocalCost;
						totalPlanCost = totalPlanCost +
							currencyService.calculateAmount(monthLocalCost, existingBreakdowns.getValue("fx_rate_plan"));
						totalGlobalCost = totalGlobalCost +
							currencyService.calculateAmount(monthLocalCost, existingBreakdowns.getValue("fx_rate"));
					}
					existingBreakdowns.setWorkflow(false);
					existingBreakdowns.update();
				}
			}
		}

		current.setValue("item_cost_local", totalLocalCost + '');
		current.setValue('item_cost_plan', totalPlanCost + '');
		current.setValue('item_cost', totalGlobalCost + '');
		current.setValue('unit_cost_plan', totalPlanCost / current.quantity + '');
		current.setValue('unit_cost', totalGlobalCost / current.quantity + '');
		current.setWorkflow(false);
		current.update();
	},

	isExecutionDateInFPRange: function (fpy, executionDate, executionEndDate) {
		var fc = new SNC.FiscalCalendar();
		var startDate = fc.getPeriodStartDate(fpy.sys_id);
		var endDate = fc.getPeriodEndDate(fpy.sys_id);

		if (executionEndDate === "") {
			executionEndDate = endDate;
		} else {
			endDate = executionEndDate;
		}

		if(startDate &lt;= executionDate &amp;&amp; endDate &gt; executionDate &amp;&amp; startDate &lt;= executionEndDate)
			return true;

		return false;
	},

	getNumberOfPeriods: function (executionDate, executionEndDate, totalPeriod, periodType, divideByWeek) {
		if (executionDate === "" &amp;&amp; executionEndDate === "") {
			return totalPeriod;
		}

		var startScheduleString = this.dateToScheduleString(executionDate);
		var endScheduleString = this.dateToScheduleString(executionEndDate);
		var queryString = 'start_date_time&gt;=' + startScheduleString + '^start_date_time&lt;=' + endScheduleString + '^fiscal_type=' + periodType
			+'^NQend_date_time&gt;=' + startScheduleString + '^end_date_time&lt;=' + endScheduleString + '^fiscal_type=' + periodType;
		var gr = new GlideRecord('fiscal_period');
		gr.addEncodedQuery(queryString);
		gr.query();
		if(!divideByWeek)
			return gr.getRowCount();

		var totalWeek = 0;
		while(gr.next()) {
			totalWeek += new SNC.FiscalCalendar().getWeeksInPeriod(gr.getUniqueValue());
		}
		return totalWeek;
	},

	getMonthlyCost: function (executionDate, executionEndDate, fpm, localCost, numberOfPeriods, isLabor, isMonthly, isProrated, totalPeriod, divideByWeek) {
		var fc = new SNC.FiscalCalendar();
		var startDate = fc.getPeriodStartDate(fpm.sys_id);
		var endDate = fc.getPeriodEndDate(fpm.sys_id);
		var glideExecutionDate = new GlideDateTime(executionDate);
		var glideExecutionEndDate = new GlideDateTime(executionEndDate);
		var glideStartDate = new GlideDateTime(startDate);
		var glideEndDate = new GlideDateTime(endDate);
		var totaldays = 0;
		var totaldaysInPeriod = 0;
		var weeksInRange = fc.getWeeksInPeriod(fpm.sys_id);

		//if this period is out of execution date range
		if(glideEndDate.compareTo(glideExecutionDate) &lt; 0 || glideStartDate.compareTo(glideExecutionEndDate) &gt; 0)
			return 0;
		//if this period is in execution date range, do not need to porate
		else if(glideStartDate.compareTo(glideExecutionDate) &gt;= 0 &amp;&amp; glideEndDate.compareTo(glideExecutionEndDate) &lt;= 0) {
			if(isLabor)
				return divideByWeek ? localCost / totalPeriod * weeksInRange : localCost / totalPeriod;

			if(isMonthly)
				return localCost;

			return divideByWeek ? localCost / numberOfPeriods * weeksInRange: localCost / numberOfPeriods;
		}
		//if this period has overlap with execution date range, cover porate case
		else if(isProrated){
			if (isLabor) {
				localCost = divideByWeek ? localCost / totalPeriod * weeksInRange : localCost / totalPeriod;
			}
			totaldaysInPeriod = GlideDateTime.subtract(glideStartDate, glideEndDate).getDayPart() + 1;
			totaldays = GlideDateTime.subtract(glideExecutionDate.compareTo(glideStartDate) &gt; 0 ? glideExecutionDate : glideStartDate,
											   glideExecutionEndDate.compareTo(glideEndDate) &lt; 0 ? glideExecutionEndDate : glideEndDate).getDayPart() + 1;
			localCost = localCost * (totaldays / totaldaysInPeriod);

			return localCost;
		} else if(isMonthly) {
			return localCost;
		}
		return divideByWeek ? localCost / numberOfPeriods * weeksInRange: localCost / numberOfPeriods;
	},

	updateBudgetTarget: function (budgetPlanGr) {
		var gr = new GlideRecord('itfm_budget_target');
		gr.addQuery('budget_key', budgetPlanGr.budget_key);
		gr.addQuery('fiscal_period', budgetPlanGr.fiscal_period);
		gr.query();

		if (gr.next()) {
			if (budgetPlanGr.target != gr.sys_id) {
				budgetPlanGr.target = gr.sys_id;
				budgetPlanGr.update();
			}
		}
	},

	triggerUpdateOfFiscalPeriodForBudgetPlan: function (budgetPlanGr) {
		gs.log('update budget plan target');
		this.updateBudgetTarget(budgetPlanGr);
		gs.log('trigger cascade budget items');
		//get all budget items
		var gr = new GlideRecord('itfm_budget_item');
		gr.addQuery('budget_plan', budgetPlanGr.sys_id);
		gr.query();
		while (gr.next()) {
			//delete all the breakdowns for this budget item
			var bibd = new GlideRecord('itfm_bi_breakdown');
			bibd.addQuery('budget_item', gr.getValue('sys_id'));
			bibd.setWorkflow(false);
			bibd.deleteMultiple();
			//trigger the recalc business rule
			this.defaultBudgetItemBreakdown(gr);
		}

		var grx = new GlideRecord('itfm_budget_plan');
		grx.addQuery('parent_budget_plan', budgetPlanGr.sys_id);
		grx.query();
		while (grx.next()) {
			grx.fiscal_period = budgetPlanGr.fiscal_period;
			grx.update();
			this.triggerUpdateOfFiscalPeriodForBudgetPlan(grx);
		}
	},

	updateGlAccounts: function () {
		gs.log('script inc');
		_budgeting.updateGlAccounts();

	},

	childKeysOfKey: function (budget_key) {
		var jArr = JSON.parse(_budgeting.getAllChildKeys(budget_key));
		if(budget_key) {
			jArr.push(budget_key);
		}

		var condition = "";
		for (var i = 0; i &lt; jArr.length; ++i)
			condition = condition + 'sys_id=' + jArr[i] + '^OR';
		return condition;
	},

	budgetKeysOfPlanCondition: function (parent_budget_plan, budgetPlanSysId) {
		var condition = '';
		var gr;
		var budget_key;
		var child_keys_json;

		var budgetPlan = new GlideRecord('itfm_budget_plan');
		if(!budgetPlan.get(budgetPlanSysId)) {
			//new budget plan
			parent_budget_plan = this._getSelectedParentPlan();
		}

		if(parent_budget_plan){
			gr = new GlideRecord("itfm_budget_plan");
			gr.get(parent_budget_plan);
			budget_key = gr.getValue("budget_key");
		}
		if(budget_key){
			var childKeys = _budgeting.getAllChildKeys(budget_key);
			child_keys_json = JSON.parse(childKeys);
			child_keys_json.push(budget_key);
			for(var i=0; i &lt; child_keys_json.length; i++){
				condition = condition + 'sys_id=' + child_keys_json[i]+ '^OR';
			}
		}

		return condition;
	},

	budgetPlanConditionForForecastPlan: function(forecastPeriod, budgetKey) {
		var condition = 'sys_class_name=itfm_budget_plan^shadow_copy=false^EQ';
		if(forecastPeriod) {
			var forecastPeriodGR = new GlideRecord('fiscal_period');
			forecastPeriodGR.get(forecastPeriod);
			condition += '^fiscal_period=' + forecastPeriodGR.getValue('fiscal_year');
		}
		if(budgetKey)
			condition += '^budget_key=' + budgetKey;
		return condition;
	},

	budgetKeyConditionForForecastPlan: function(budgetKey) {
		var condition = '';
		if(budgetKey){
			var childKeys = JSON.parse(_budgeting.getAllChildKeys(budgetKey));
			condition =  'sys_id=' + budgetKey;
			for(var i=0; i &lt; childKeys.length; i++){
				condition += '^ORsys_id=' + childKeys[i];
			}
		}
		return condition;
	},

	isChildOfKey: function (budget_key_child, budget_key) {
		if(budget_key_child == budget_key){
			return true;
		}
		var isParentChild = _budgeting.isParentAndChild(budget_key, budget_key_child);

		return isParentChild;
	},

	isLeafBudgetKey: function(budget_key){

		return j2js(_budgeting.isLeafBudgetKey(budget_key));
	},

	relatedExchangeRatesOfBudgetItem: function (current) {
		// current is a glide record object of itfm_bi_breakdown table
		var budgetItem = new GlideRecord("itfm_budget_item");
		if (!budgetItem.get(current.budget_item))
			return;

		var fromCurrency = budgetItem.currency.toString();
		var toCurrency = budgetItem.budget_plan.currency.toString();
		var fp = current.fiscal_period;

		var condition = '';
		var exchangeRates = new SNC.FMCurrency().getExchangeRateOfFiscalPeriod(fp, fromCurrency, toCurrency);
		if (exchangeRates.hasNext()) {
			while (exchangeRates.next()) {
				condition = condition + 'sys_id=' + exchangeRates.getValue('sys_id') + '^OR';
			}
		} else {
			condition = "sys_id=-1";
		}
		return condition;
	},

	relatedGlobalExchangeRatesOfBudgetItem: function (current) {
		// current is a glide record object of itfm_bi_breakdown table
		var budgetItem = new GlideRecord("itfm_budget_item");
		if (!budgetItem.get(current.budget_item))
			return;

		var fromCurrency = budgetItem.currency.toString();
		var toCurrency = new SNC.FMCurrency().getGlobalCurrencyCode();
		var fp = current.fiscal_period;

		var condition = '';
		var exchangeRates = new SNC.FMCurrency().getExchangeRateOfFiscalPeriod(fp, fromCurrency, toCurrency);
		if (exchangeRates.hasNext()) {
			while (exchangeRates.next()) {
				condition = condition + 'sys_id=' + exchangeRates.getValue('sys_id') + '^OR';
			}
		} else {
			condition = "sys_id=-1";
		}
		return condition;
	},

	defaultExchangeRateOfBudgetItem: function (current) {
		// current is a glide record object of itfm_bi_breakdown table
		// this function throws NoFiscalPeriodException and NoBudgetReferenceRateException
		var budgetItem = new GlideRecord("itfm_budget_item");
		if (!budgetItem.get(current.budget_item))
			return;

		var fromCurrency = budgetItem.currency.toString();
		var toCurrency = budgetItem.budget_plan.currency.toString();
		var fp = current.fiscal_period;

		var exchangeRate = new SNC.FMCurrency().getDefaultExchangeRate(fp, fromCurrency, toCurrency);
		return exchangeRate;
	},

	defaultGlobalExchangeRateOfBudgetItem: function (current) {
		// current is a glide record object of itfm_bi_breakdown table
		// this function throws NoFiscalPeriodException and NoBudgetReferenceRateException
		var budgetItem = new GlideRecord("itfm_budget_item");
		if (!budgetItem.get(current.budget_item))
			return;

		var fromCurrency = budgetItem.currency.toString();
		var toCurrency = new SNC.FMCurrency().getGlobalCurrencyCode();
		var fp = current.fiscal_period;

		var exchangeRate = new SNC.FMCurrency().getDefaultExchangeRate(fp, fromCurrency, toCurrency);
		return exchangeRate;
	},

	getAllSubPlanIdsForBudgetPlan: function (subPlanId) {
		var result = [];
		var subPlans = new GlideRecord('itfm_budget_plan');
		subPlans.addQuery('parent_budget_plan', subPlanId);
		subPlans.query();
		while (subPlans.next()) {
			result.push(subPlans.getValue('sys_id'));
			var subs = this.getAllSubPlanIdsForBudgetPlan(subPlans.getValue('sys_id'));
			result = result.concat(subs);
		}

		return result;
	},

	ownersOfBudgetKeyCondition: function (budgetKey, parentBudgetPlan,budgetPlanSysId) {
		var condition = '';
		var that = this;
		var relatedKeys = [];
		var domain = "";
		var bKey = new GlideRecord("itfm_budget_key");
		bKey.get(budgetKey);
		var budgetPlan = new GlideRecord('itfm_budget_plan');
		if(budgetPlanSysId &amp;&amp; !budgetPlan.get(budgetPlanSysId)) {
			//new budget plan
			budgetKey = this._getSelectedBudgetKey();
			parentBudgetPlan = this._getSelectedParentPlan();
		}

		if(budgetKey){
				relatedKeys =  JSON.parse(_budgeting.getAllParentKeys(budgetKey));
				relatedKeys.push(budgetKey);
			    domain = bKey.getValue("sys_domain");
			}
			else if(!budgetKey &amp;&amp; parentBudgetPlan) {
				while(parentBudgetPlan){
					gr = new GlideRecord("itfm_budget_plan");
					gr.addQuery("sys_id", parentBudgetPlan);
					gr.query();
					if(gr.next()) {
						budgetKey = gr.getValue('budget_key');
						parentBudgetPlan = gr.getValue('parent_budget_plan');
						domain = gr.getValue("sys_domain");

					}
					var keys = JSON.parse(_budgeting.getAllChildKeys(budgetKey));
					for(var i=0; i&lt; keys.length; i++){
						relatedKeys.push(keys[i]);
					}
					relatedKeys.push(budgetKey);
				}

			}
			if (relatedKeys) {
				if(domain != "global")domain += ",global";
				var gr = new GlideRecord('itfm_budget_key_owner');
				gr.addQuery("budget_key", "IN", relatedKeys.toString());
				gr.addQuery("sys_domain", "IN", domain);
				gr.query();
				while (gr.next()) {
						condition = condition + 'sys_id=' + gr.budget_owner + '^OR';
				}

				if (condition == '') {
					condition = 'sys_id=NIL';
				}
			}
		return condition;
	},

	putBudgetKeyInSession: function () {
		var sysId = this.getParameter('sysparm_budgetKey');
		var name = 'budget_key_in_budget_plan';
		gs.getSession().putClientData(name, sysId);
	},

	putParentPlanInSession: function () {
		var sysId = this.getParameter('sysparm_parentPlan');
		var name = 'parent_plan_in_budget_plan';
		gs.getSession().putClientData(name, sysId);
	},

	_getSelectedBudgetKey: function() {
		return gs.getSession().getClientData('budget_key_in_budget_plan');
	},

	_getSelectedParentPlan: function() {
		return gs.getSession().getClientData('parent_plan_in_budget_plan');
	},

	dateToScheduleString: function(date) {
		return date.substring(0, 4) + date.substring(5, 7) + date.substring(8) + "T000000";
	},

	budgetTargetFiscalPeriodCondition: function () {
		var condition = '';
		condition = 'fiscal_type=year^ORfiscal_type=quarter^ORfiscal_type=month';
		return condition;
	},

	getProductModelInfo: function() {
		var prodcutModelId = this.getParameter('sysparm_product_model_id');
		var budgetPlanId = this.getParameter('sysparm_budget_plan');
		var localCurrency = this.getParameter('sysparm_currency');
		var gr = new GlideRecord('cmdb_model');
		gr.get(prodcutModelId);
		var currency = gr.cost.getReferenceCurrencyCode();
		var amount = parseFloat(gr.cost.getReferenceValue());
		if(currency !== localCurrency) {
			var grPlan = new GlideRecord('itfm_budget_plan');
			grPlan.get(budgetPlanId);
			var exchangeRate = new SNC.FMCurrency().getDefaultExchangeRate(grPlan.fiscal_period, currency, localCurrency);
			if(exchangeRate)
				amount = new SNC.FMCurrency().calculateAmount(amount, exchangeRate.getUniqueValue());
		}
		amount = parseFloat(amount.toFixed(2));
		var result = this.newItem("result");
		result.setAttribute("name", gr.getDisplayValue());
		result.setAttribute("amount", amount);
	},

	getExistingFieldMaps: function(fieldMap, usageField) {
		var existingFieldMaps = new GlideRecord(fieldMap.getTableName());
		existingFieldMaps.addQuery('itfm_data_source', fieldMap.itfm_data_source);
		existingFieldMaps.addQuery(usageField, 'true');
		if(fieldMap.operation() == 'update') existingFieldMaps.addQuery('sys_id', '!=', fieldMap.sys_id);
		return existingFieldMaps;
	},

	listClashedFieldMaps: function(fieldMap, clashedFieldMaps) {
		var dsTable = new GlideRecord(fieldMap.itfm_data_source.table);
		dsTable.initialize();
		while(clashedFieldMaps.next())
			gs.addErrorMessage(
				gs.getMessage('Segment "{0}" is mapped to field "{1}" of Data Source "{2}".',
				[ clashedFieldMaps.segment_name.getDisplayValue(),
				  dsTable[clashedFieldMaps.field_name].getLabel(),
				  clashedFieldMaps.itfm_data_source.getDisplayValue()
				])
			);
	},

	getCatalogItemPrice: function() {
		var price = {};
		var catalogItem = new GlideRecord('sc_cat_item');
		catalogItem.get(this.getParameter('sysparm_catalog_item_id'));
		price.code = catalogItem.price.getCurrencyCode();
		price.value = catalogItem.price.getCurrencyValue();
		return JSON.stringify(price);
	},

	getChildBudgetOwnerUserIds: function(parentBudgetOwnerUserId) {
		var childBudgetOwnerUserIds = [];

		var budgetOwnerGR = new GlideRecord("itfm_budget_owner");
		budgetOwnerGR.addQuery('parent_budget_owner.user', parentBudgetOwnerUserId);
		budgetOwnerGR.query();

		while(budgetOwnerGR.next()) {
			childBudgetOwnerUserIds.push(budgetOwnerGR.getValue('user'));
		}

		return childBudgetOwnerUserIds;
	},

	type: 'ITFM_Budgeting'
});]]&gt;&lt;/script&gt;
        &lt;sys_class_name&gt;sys_script_include&lt;/sys_class_name&gt;
        &lt;sys_created_by&gt;admin&lt;/sys_created_by&gt;
        &lt;sys_created_on&gt;2015-06-16 23:13:43&lt;/sys_created_on&gt;
        &lt;sys_id&gt;0081ff73132002003ff3691c2c6a5e0f&lt;/sys_id&gt;
        &lt;sys_mod_count&gt;404&lt;/sys_mod_count&gt;
        &lt;sys_name&gt;ITFM_Budgeting&lt;/sys_name&gt;
        &lt;sys_package display_value="Core Plugin For ITFM and Financial Planning" source="com.snc.itfm_core"&gt;8210166b47e64210cd4e1ce4316d4327&lt;/sys_package&gt;
        &lt;sys_policy/&gt;
        &lt;sys_scope display_value="Global"&gt;global&lt;/sys_scope&gt;
        &lt;sys_update_name&gt;sys_script_include_0081ff73132002003ff3691c2c6a5e0f&lt;/sys_update_name&gt;
        &lt;sys_updated_by&gt;admin&lt;/sys_updated_by&gt;
        &lt;sys_updated_on&gt;2017-09-07 06:47:31&lt;/sys_updated_on&gt;
    &lt;/sys_script_include&gt;
&lt;/record_update&gt;
</payload>
        <sys_class_name>sys_metadata_link</sys_class_name>
        <sys_created_by>admin</sys_created_by>
        <sys_created_on>2024-09-21 08:08:53</sys_created_on>
        <sys_id>1c30b85583b01210c6695855eeaad38d</sys_id>
        <sys_mod_count>0</sys_mod_count>
        <sys_name>ITFM_Budgeting</sys_name>
        <sys_package display_value="Now Utils" source="x_938076_now_utils">b208a7c083689e50c6695855eeaad3d2</sys_package>
        <sys_policy/>
        <sys_scope display_value="Now Utils">b208a7c083689e50c6695855eeaad3d2</sys_scope>
        <sys_update_name>sys_metadata_link_1c30b85583b01210c6695855eeaad38d</sys_update_name>
        <sys_updated_by>admin</sys_updated_by>
        <sys_updated_on>2024-09-21 08:08:53</sys_updated_on>
        <tablename>sys_script_include</tablename>
    </sys_metadata_link>
</record_update>
