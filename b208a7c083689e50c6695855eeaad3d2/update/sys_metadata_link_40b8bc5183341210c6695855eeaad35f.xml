<?xml version="1.0" encoding="UTF-8"?><record_update table="sys_metadata_link">
    <sys_metadata_link action="INSERT_OR_UPDATE">
        <directory>update</directory>
        <documentkey>98ba8ce8eb3a211078aca892e2522816</documentkey>
        <payload>&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;record_update table="sys_script_include"&gt;
    &lt;sys_script_include action="INSERT_OR_UPDATE"&gt;
        &lt;access&gt;package_private&lt;/access&gt;
        &lt;active&gt;true&lt;/active&gt;
        &lt;api_name&gt;sn_entitlement.LicenseDetailMetricHistoryDAO&lt;/api_name&gt;
        &lt;caller_access/&gt;
        &lt;client_callable&gt;false&lt;/client_callable&gt;
        &lt;description&gt;DAO to retrieve data from license_detail_metric_history&lt;/description&gt;
        &lt;name&gt;LicenseDetailMetricHistoryDAO&lt;/name&gt;
        &lt;script&gt;&lt;![CDATA[var LicenseDetailMetricHistoryDAO = Class.create();
LicenseDetailMetricHistoryDAO.prototype = {
    initialize: function() {
        this._licenseDetailMetricHistoryTable = "license_detail_metric_history";
        /**
         * (0,2,3 - user) : (1 - capacity) : (4- PA-Indicator) : (5- Display) : (99 - others) 
         * User, Unrestricted User, Unlimited User, PA-Indicator are user product 
         */
        this._licenseType = {
            0: "User",
            1: "Quota",
            2: "User",
            3: "User",
            4: "User",
            5: "Display",
            99: "others",
        };
    },

    /**
     * @returns {array} An array contains list of product code that have allotment history
     */
    getProductCodesThatHaveAllotmentHistoryLog: function() {
        const count = new GlideAggregate(this._licenseDetailMetricHistoryTable);
        count.addAggregate('COUNT', 'license_detail');
        count.query();

        let product_code = [];
        while (count.next()) {
            var licenseGr = new GlideRecord('license_details');
            licenseGr.get(count.getValue('license_detail'));
            if (licenseGr.isValid() &amp;&amp; !global.JSUtil.nil(licenseGr.getValue('product_code')))
                product_code.push(licenseGr.getValue('product_code'));
        }
        return product_code;
    },

    /**
     * @param {productCodeToSubscriptionSysIdMap} this to look up ems subscription sysId for a product code
     * 
     * @returns {array} An array contains allotment history
     */
    getEntitlementAllotmentHistory: function(productCodeToSubscriptionSysIdMap) {
        let subscriptionAllotmentLog = [];
        for (const productCode of Object.keys(productCodeToSubscriptionSysIdMap)) {
            const allotmentLogGr = new GlideRecord(this._licenseDetailMetricHistoryTable);
            allotmentLogGr.addQuery('name', '!=', 'unmapped');
            allotmentLogGr.addQuery('sys_created_on', '&gt;', gs.monthsAgo(3));
			allotmentLogGr.addQuery('license_detail.product_code', productCode);
            allotmentLogGr.query();
            while (allotmentLogGr.next()) {
                const name = String(allotmentLogGr.getValue('name'));
                const license_type = this._licenseType[String(allotmentLogGr.getElement('license_detail.license_type'))];
                const smv1SubscriptionSysID = String(allotmentLogGr.getElement('license_detail.sys_id'));

                //fields for user product
                let allocated_user_count;
                let available_user_count;

                //fields for custom table(s)
                let allocated_custom_table_count;
                let available_custom_table_count;

                //fields for quota product
                let allocated_quota_count;
                let available_quota_count;

                if (license_type == 'Display' || license_type === 'others')
                    continue;

                //populate user product allocation history column
                if (license_type === 'User') {
                    if (name == 'allocated' || name === 'over_allocated')
                        allocated_user_count = Number(allotmentLogGr.getValue('value')) || 0;

                    if (name == 'available')
                        available_user_count = Number(allotmentLogGr.getValue('value')) || 0;
                }

                //populate quota product allocation history column
                if (license_type === 'Quota') {
                    if (name == 'allocated' || name === 'over_allocated')
                        allocated_quota_count = Number(allotmentLogGr.getValue('value')) || 0;

                    if (name === 'available')
                        available_quota_count = Number(allotmentLogGr.getValue('value')) || 0;
                }

                if (name === 'tables_used')
                    allocated_custom_table_count = Number(allotmentLogGr.getValue('value')) || 0;

                if (name === 'tables_available')
                    available_custom_table_count = Number(allotmentLogGr.getValue('value')) || 0;

                let subscriptionLogObject = {
                    migrated_state: String(allotmentLogGr.getValue('name')),
                    allocated_user_count: allocated_user_count,
                    available_user_count: available_user_count,
                    subscription: String(productCodeToSubscriptionSysIdMap[String(allotmentLogGr.getElement('license_detail.product_code'))]),
					calculated_on: allotmentLogGr.getValue('date'),
                    available_custom_table_count: available_custom_table_count,
                    allocated_custom_table_count: allocated_custom_table_count,
                    license: smv1SubscriptionSysID,
                    allocated_quota_count: allocated_quota_count,
                    available_quota_count: available_quota_count,
                    processing_complete: true,
                    is_latest: false
                };
                subscriptionAllotmentLog.push(subscriptionLogObject);
            }
        }

        return subscriptionAllotmentLog;
    },

    type: 'LicenseDetailMetricHistoryDAO'
};]]&gt;&lt;/script&gt;
        &lt;sys_class_name&gt;sys_script_include&lt;/sys_class_name&gt;
        &lt;sys_created_by&gt;maint&lt;/sys_created_by&gt;
        &lt;sys_created_on&gt;2023-05-10 19:03:27&lt;/sys_created_on&gt;
        &lt;sys_id&gt;98ba8ce8eb3a211078aca892e2522816&lt;/sys_id&gt;
        &lt;sys_mod_count&gt;34&lt;/sys_mod_count&gt;
        &lt;sys_name&gt;LicenseDetailMetricHistoryDAO&lt;/sys_name&gt;
        &lt;sys_package display_value="Licensing Engine" source="sn_entitlement"&gt;bcadabf277f311109c62f5f3cb5a992a&lt;/sys_package&gt;
        &lt;sys_policy&gt;read&lt;/sys_policy&gt;
        &lt;sys_scope display_value="Licensing Engine"&gt;bcadabf277f311109c62f5f3cb5a992a&lt;/sys_scope&gt;
        &lt;sys_update_name&gt;sys_script_include_98ba8ce8eb3a211078aca892e2522816&lt;/sys_update_name&gt;
        &lt;sys_updated_by&gt;maint&lt;/sys_updated_by&gt;
        &lt;sys_updated_on&gt;2023-06-10 23:59:14&lt;/sys_updated_on&gt;
    &lt;/sys_script_include&gt;
&lt;/record_update&gt;
</payload>
        <sys_class_name>sys_metadata_link</sys_class_name>
        <sys_created_by>admin</sys_created_by>
        <sys_created_on>2024-09-21 08:46:01</sys_created_on>
        <sys_id>40b8bc5183341210c6695855eeaad35f</sys_id>
        <sys_mod_count>0</sys_mod_count>
        <sys_name>LicenseDetailMetricHistoryDAO</sys_name>
        <sys_package display_value="Now Utils" source="x_938076_now_utils">b208a7c083689e50c6695855eeaad3d2</sys_package>
        <sys_policy/>
        <sys_scope display_value="Now Utils">b208a7c083689e50c6695855eeaad3d2</sys_scope>
        <sys_update_name>sys_metadata_link_40b8bc5183341210c6695855eeaad35f</sys_update_name>
        <sys_updated_by>admin</sys_updated_by>
        <sys_updated_on>2024-09-21 08:46:01</sys_updated_on>
        <tablename>sys_script_include</tablename>
    </sys_metadata_link>
</record_update>
