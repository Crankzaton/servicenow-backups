<?xml version="1.0" encoding="UTF-8"?><record_update table="sys_metadata_link">
    <sys_metadata_link action="INSERT_OR_UPDATE">
        <directory>update</directory>
        <documentkey>43bc2b027782b010d3ef07dc7d5a9942</documentkey>
        <payload>&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;record_update table="sys_script_include"&gt;
    &lt;sys_script_include action="INSERT_OR_UPDATE"&gt;
        &lt;access&gt;public&lt;/access&gt;
        &lt;active&gt;true&lt;/active&gt;
        &lt;api_name&gt;global.CSMRelationshipUtils&lt;/api_name&gt;
        &lt;caller_access/&gt;
        &lt;client_callable&gt;true&lt;/client_callable&gt;
        &lt;description/&gt;
        &lt;name&gt;CSMRelationshipUtils&lt;/name&gt;
        &lt;script&gt;&lt;![CDATA[var CSMRelationshipUtils = Class.create();
CSMRelationshipUtils.prototype = {
    initialize: function() {
    },
	
	getSafely: function(object, keys) {
		if (!keys || !object) return object;
		return this.getSafely(object[keys[0]], keys.splice(1));
	},
	
	isChildOf: function(parent, tableName) {
		if(gs.nil(tableName) || gs.nil(parent))
			return false;
		var tu = new global.TableUtils(tableName); 
		var tables = tu.getTables();
		return tables.indexOf(parent) &gt; -1;
	},
	
	// Returns the very fist matching relationship
	getRelationshipEPService: function(relationship, additionalParams){
		if(gs.nil(relationship))
			return null;

		var ep = new GlideScriptedExtensionPoint().getExtensions(global.CSMRelationshipConstants.RELATIONSHIP_EXTENSION_POINT);
		for (var e = 0; e &lt; ep.length; e++) {
			ep[e].initialize();
			if (ep[e].canProcess(relationship, additionalParams)){
				return ep[e];
			}
		}
	},

	hasAccess: function(current, relationship, accessLevel, additionalParams) {
		var service = this.getRelationshipEPService(relationship, additionalParams);
		return service.hasAccess(current, relationship, accessLevel, additionalParams);
	},

	getResponsibilities: function(relationship, accessLevel, respParams) {
		var service = this.getRelationshipEPService(relationship);
		return service.getResponsibilities(relationship, accessLevel, respParams);
	},
	
	getMyEntities: function(current, relationship, entityName, accessLevel, additionalParams) {
		var service = this.getRelationshipEPService(relationship, additionalParams);
		return service.getMyEntities(current, relationship, entityName, accessLevel, additionalParams);
	},
	
	getRelatedPartyCases: function() {
		var RC = global.CSMRelationshipConstants;
		var params = {};
		params[RC.SKIP_BEFORE_QUERY_FILTER] = true;
		return this.getMyEntities(null, RC.RELATIONSHIP_CASE_RELATED_PARTY, RC.RP_CASE_FIELD, RC.ACCESS.FULL, params);
	},
	
	/*
	entityList: ['&lt;entity_type&gt;:&lt;entity_sys_id&gt;', '&lt;entity_type&gt;:&lt;entity_sys_id&gt;' ...]
	entity_type can be customer_contact | csm_consumer | sys_user

	returns:
	{
		'customer_contact': [sys_id1, sys_id2 ...],
		'sys_user': [sys_id1, sys_id2.. ],
		'csm_consumer': [sys_id1, sys_id2..]
	}
	*/
	groupRelatedPartiesByEntityTypes: function(entityList, groupedEntityObject){
		if (gs.nil(groupedEntityObject))
			groupedEntityObject = {};
		
		var contactTable = global.CSMBaseConstants.CONTACT_TABLE,
			consumerTable = global.CSMBaseConstants.CONSUMER_TABLE,
			userTable = global.CSMBaseConstants.USER_TABLE;
		if (gs.nil(groupedEntityObject[contactTable]))
			groupedEntityObject[contactTable] = [];
		if (gs.nil(groupedEntityObject[consumerTable]))
			groupedEntityObject[consumerTable] = [];
		if (gs.nil(groupedEntityObject[userTable]))
			groupedEntityObject[userTable] = [];

		if(gs.nil(entityList) || entityList.length == 0)
			return groupedEntityObject;

		for(var i=0; i &lt; entityList.length; i++){
			var entityObject = entityList[i];
			//splitting entity object with ':' as seperator should give us array of length two
			//First element in the array will be entity type, second element will be entity sys_id
			var entityObjectArray = entityObject.split(":");

			if(gs.nil(entityObjectArray) || entityObjectArray.length !=2 || gs.nil(entityObjectArray[1])) continue;
			if(entityObjectArray[0] != contactTable &amp;&amp; entityObjectArray[0] != consumerTable &amp;&amp; entityObjectArray[0] != userTable) continue;

			groupedEntityObject[entityObjectArray[0]].push(entityObjectArray[1]);
		}
		return groupedEntityObject;
	},

	/*
	returns:
	{
		'customer_contact': [sys_id1, sys_id2 ...],
		'sys_user': [sys_id1, sys_id2.. ],
		'csm_consumer': [sys_id1, sys_id2..]
	}
	*/
	getSoldProductMembers: function(current, accessLevel, groupedEntityObject) {
		if (!current || !current.getTableName() == global.CSMBaseConstants.CASE_TABLE)
			return;
		if (gs.nil(groupedEntityObject))
			groupedEntityObject = {};
		
		var additionalParams = {};
		additionalParams[CSMRelationshipConstants.NO_PERSONA_QUERY] = true;
		additionalParams[CSMRelationshipConstants.SKIP_ROLE_CHECK] = true;
		
		if (!gs.nil(current[global.CSMRelationshipConstants.FIELD_SOLD_PRODUCT])) {
			if (current[CSMRelationshipConstants.FIELD_CONSUMER]) {
				additionalParams[CSMRelationshipConstants.IS_CONSUMER_SOLD_PRODUCT] = true;
				additionalParams[CSMRelationshipConstants.IS_CONTACT_SOLD_PRODUCT] = false;
				this._populateSoldProductRelatedParties(current, CSMRelationshipConstants.RELATIONSHIP_SOLD_PRODUCT_RELATED_PARTY, CSMRelationshipConstants.FIELD_CONSUMER, accessLevel, additionalParams, groupedEntityObject, global.CSMBaseConstants.CONSUMER_TABLE);
			}
			if (current[CSMRelationshipConstants.FIELD_CONTACT]) {
				additionalParams[CSMRelationshipConstants.IS_CONTACT_SOLD_PRODUCT] = true;
				additionalParams[CSMRelationshipConstants.IS_CONSUMER_SOLD_PRODUCT] = false;
				this._populateSoldProductRelatedParties(current, CSMRelationshipConstants.RELATIONSHIP_SOLD_PRODUCT_RELATED_PARTY, CSMRelationshipConstants.FIELD_CONTACT, accessLevel, additionalParams, groupedEntityObject, global.CSMBaseConstants.CONTACT_TABLE);
			}
		}

		return groupedEntityObject;
	},
	
	/*
	returns:
	{
		'customer_contact': [sys_id1, sys_id2 ...],
		'sys_user': [sys_id1, sys_id2.. ],
		'csm_consumer': [sys_id1, sys_id2..]
	}
	*/
	getCaseRelatedParties: function(current, accessLevel, groupedEntityObject) {
		if (!current || !current.getTableName() == global.CSMBaseConstants.CASE_TABLE)
			return;
		if (gs.nil(groupedEntityObject))
			groupedEntityObject = {};

		var additionalParams = {};
		additionalParams[CSMRelationshipConstants.NO_PERSONA_QUERY] = true;
		additionalParams[CSMRelationshipConstants.SKIP_ROLE_CHECK] = true;

		var entityList = this.getMyEntities(current, CSMRelationshipConstants.RELATIONSHIP_CASE_RELATED_PARTY, null, accessLevel, additionalParams) || [];
		this.groupRelatedPartiesByEntityTypes(entityList, groupedEntityObject);

		return groupedEntityObject;
	},
	
	/*
	returns:
	{
		'customer_contact': [sys_id1, sys_id2 ...],
		'sys_user': [sys_id1, sys_id2.. ],
		'csm_consumer': [sys_id1, sys_id2..]
	}
	*/
	getAllRelatedParties: function(current, accessLevel) {
		if (!current || !current.getTableName() == global.CSMBaseConstants.CASE_TABLE)
			return;

		var groupedEntityObject = {};
		this.getCaseRelatedParties(current, accessLevel, groupedEntityObject);
		this.getSoldProductMembers(current, accessLevel, groupedEntityObject);
		return groupedEntityObject;
	},

	/*
	relatedParties:
	{
		'customer_contact': [sys_id1, sys_id2 ...],
		'sys_user': [sys_id1, sys_id2.. ],
		'csm_consumer': [sys_id1, sys_id2..]
	}
	This method returns list of emailIds of these related parties: [emailId1, emailId2, ...]
	*/
	fetchEmailIdListOfCaseRelatedParties: function(relatedParties){
		if (gs.nil(relatedParties)) return [];

		var contactTable = global.CSMBaseConstants.CONTACT_TABLE,
			consumerTable = global.CSMBaseConstants.CONSUMER_TABLE,
			userTable = global.CSMBaseConstants.USER_TABLE;
		var contactIds = relatedParties[contactTable] || [];
		var userIds = relatedParties[userTable] || [];
		var consumerIds = relatedParties[consumerTable] || [];
		var emailIdList = [];

		//For both user and contact records, we can query user table to fetch email.
		if (userIds.length &gt; 0 || contactIds.length &gt; 0) {
			var userGr = new GlideRecord(userTable);
			userGr.addQuery('sys_id', 'IN', userIds.concat(contactIds));
			userGr.setWorkflow(false);
			userGr.query();
			while (userGr.next()) {
				if (!gs.nil(userGr.email))
					emailIdList.push(userGr.email + '');
			}
		}

		if (consumerIds.length &gt; 0) {
			var consumerGr = new GlideRecord(consumerTable);
			consumerGr.addQuery('sys_id', 'IN', consumerIds);
			consumerGr.setWorkflow(false);
			consumerGr.query();
			while (consumerGr.next()) {
				if (!gs.nil(consumerGr.email))
					emailIdList.push(consumerGr.email + '');
			}
		}
		return emailIdList;
	},

	/*
	caseGr: GlideRecord of sn_customerservice_case
	Checks if the given email belongs to the case related party with full access
	*/
	checkIfEmailBelongsToCaseRelatedPartyWithFullAccess: function(caseGr, email_from) {
		if(gs.nil(caseGr) || gs.nil(email_from)) return false;
		var emailIdList = this.fetchEmailIdListOfCaseRelatedParties(this.getAllRelatedParties(caseGr, CSMRelationshipConstants.ACCESS.FULL)) || [];
		var email_from_lowercase = email_from.toLowerCase();
		for(var i=0; i&lt;emailIdList.length; i++){
			if(emailIdList[i].toLowerCase() == email_from_lowercase) return true;
		}
		return false;
	},

	generateSoldProductRelatedPartyNotifications: function(current, eventName) {
		var recipients = this.fetchEmailIdListOfCaseRelatedParties(this.getSoldProductMembers(current, CSMRelationshipConstants.ACCESS.FULL, null));
		if (recipients.length &gt; 0) {
			gs.eventQueue(eventName, current, recipients);
		}
	},
	
	generateCaseRelatedPartyNotifications: function(current, eventName) {
		var recipients = this.fetchEmailIdListOfCaseRelatedParties(this.getCaseRelatedParties(current, CSMRelationshipConstants.ACCESS.FULL, null));
		if (recipients.length &gt; 0) {
			gs.eventQueue(eventName, current, recipients);
		}
	},
	
	generateRelatedPartyNotifications_caseCommented: function(current) {
		this.generateCaseRelatedPartyNotifications(current, CSMRelationshipConstants.EVENT_CASE_COMMENTED_RP);
		this.generateSoldProductRelatedPartyNotifications(current, CSMRelationshipConstants.EVENT_CASE_COMMENTED_SP);
	},
	
	generateRelatedPartyNotifications_caseClosed: function(current) {
		this.generateCaseRelatedPartyNotifications(current, CSMRelationshipConstants.EVENT_CASE_CLOSED_RP);
		this.generateSoldProductRelatedPartyNotifications(current, CSMRelationshipConstants.EVENT_CASE_CLOSED_SP);
	},
	
	generateRelatedPartyNotifications_caseResolved: function(current) {
		this.generateCaseRelatedPartyNotifications(current, CSMRelationshipConstants.EVENT_CASE_RESOLVED_RP);
		this.generateSoldProductRelatedPartyNotifications(current, CSMRelationshipConstants.EVENT_CASE_RESOLVED_SP);
	},
	
	//This method checks can contact create or update sold product cases for restricted access account
	canContactCreateOrUpdateCase: function(current) {
		var caseAccessUtil = new global.CSMContentAccessUtils().getContentAccessEPService(global.CSMBaseConstants.CASE_TABLE, current);
		var spGR = new GlideRecord(global.CSMBaseConstants.SOLD_PRODUCT);
		spGR._skip_before_query_filter = true;
		spGR.get(current.sold_product);
		var loggedInUserId = gs.getUserID();
		
		/*
		* if case is not created by sp contact or sp additional contact throw error message
		* else if case is not being updated by primary contact, related party, sp primary contact, sp additional contact throw error 
		* message
		*/
		var RC = global.CSMRelationshipConstants;
		var authorizedContactParams = {};
		authorizedContactParams[RC.SKIP_BEFORE_QUERY_FILTER] = true;
		authorizedContactParams[RC.IS_CONTACT_SOLD_PRODUCT] = true;
		var authorizedAccountParams = {};
		authorizedAccountParams[RC.SKIP_BEFORE_QUERY_FILTER] = true;
		authorizedAccountParams[RC.NO_PERSONA_QUERY] = true;
		authorizedAccountParams[RC.IS_ACCOUNT_QUERY] = true;
		authorizedAccountParams[RC.IS_CONTACT_SOLD_PRODUCT] = true;
		
		if (current.operation() == 'insert' &amp;&amp; spGR.contact != current.contact &amp;&amp; !caseAccessUtil.canCreate(authorizedContactParams) &amp;&amp; !caseAccessUtil.canCreate(authorizedAccountParams)) {
			gs.addErrorMessage(gs.getMessage("Contact does not match with valid contacts for the sold product"));
			current.setAbortAction(true);
			return false;

		} else if (current.operation() == 'update' &amp;&amp; !caseAccessUtil.canWrite(authorizedContactParams) &amp;&amp; !caseAccessUtil.canWrite(authorizedAccountParams) &amp;&amp; current.contact != loggedInUserId &amp;&amp; spGR.contact != loggedInUserId) {
			gs.addErrorMessage(gs.getMessage("Contact does not match with valid contacts for the case"));
			current.setAbortAction(true);
			return false;
		} else return true;
	},
	


	/* Private Methods */

	/*
	current: case record
	relationship: sn_install_base_sold_product_related_party
	entity: consumer or contact
	groupedEntityObjectKey: csm_consumer or customer_contact
	*/
	_populateSoldProductRelatedParties: function(current, relationship, entity, accessLevel, additionalParams, groupedEntityObject, groupedEntityObjectKey) {
		if (!current || !this.isChildOf(global.CSMBaseConstants.CASE_TABLE, current.getTableName()) || gs.nil(current[global.CSMRelationshipConstants.FIELD_SOLD_PRODUCT]) || gs.nil(groupedEntityObject) || !groupedEntityObjectKey)
			return;

		if (gs.nil(groupedEntityObject[groupedEntityObjectKey]))
			groupedEntityObject[groupedEntityObjectKey] = [];
		
		if (current[entity]) {
			var entityList = this.getMyEntities(current, relationship, entity, accessLevel, additionalParams) || [];
			entityList.forEach(function(entity_id){
				groupedEntityObject[groupedEntityObjectKey].push(entity_id);
			});
		}
	},

	getCSMRelationshipRolesAndRespConfig: function(config, configUtil) {
		if (!configUtil)
			return;
		config = config || {};
		var ep = new GlideScriptedExtensionPoint().getExtensions(global.CSMRelationshipConstants.RELATIONSHIP_RESP_CONFIG_EXTENSION_POINT);
		for (var e = 0; e &lt; ep.length; e++) {
			ep[e].initialize();
			var relationshipEntity = ep[e].getRelationshipEntity();
			if (!gs.nil(relationshipEntity))
				config[relationshipEntity] = ep[e][configUtil]();
		}
		return config;
	},
	
    type: 'CSMRelationshipUtils'
};]]&gt;&lt;/script&gt;
        &lt;sys_class_name&gt;sys_script_include&lt;/sys_class_name&gt;
        &lt;sys_created_by&gt;admin&lt;/sys_created_by&gt;
        &lt;sys_created_on&gt;2021-08-20 08:01:41&lt;/sys_created_on&gt;
        &lt;sys_id&gt;43bc2b027782b010d3ef07dc7d5a9942&lt;/sys_id&gt;
        &lt;sys_mod_count&gt;6&lt;/sys_mod_count&gt;
        &lt;sys_name&gt;CSMRelationshipUtils&lt;/sys_name&gt;
        &lt;sys_package display_value="Customer Service Base Entities" source="com.snc.cs_base"&gt;4f2cce6b47664210cd4e1ce4316d43a4&lt;/sys_package&gt;
        &lt;sys_policy&gt;read&lt;/sys_policy&gt;
        &lt;sys_scope display_value="Global"&gt;global&lt;/sys_scope&gt;
        &lt;sys_update_name&gt;sys_script_include_43bc2b027782b010d3ef07dc7d5a9942&lt;/sys_update_name&gt;
        &lt;sys_updated_by&gt;admin&lt;/sys_updated_by&gt;
        &lt;sys_updated_on&gt;2022-11-18 06:00:02&lt;/sys_updated_on&gt;
    &lt;/sys_script_include&gt;
&lt;/record_update&gt;
</payload>
        <sys_class_name>sys_metadata_link</sys_class_name>
        <sys_created_by>admin</sys_created_by>
        <sys_created_on>2024-09-21 08:36:23</sys_created_on>
        <sys_id>0f76f0d983f01210c6695855eeaad3f5</sys_id>
        <sys_mod_count>0</sys_mod_count>
        <sys_name>CSMRelationshipUtils</sys_name>
        <sys_package display_value="Now Utils" source="x_938076_now_utils">b208a7c083689e50c6695855eeaad3d2</sys_package>
        <sys_policy/>
        <sys_scope display_value="Now Utils">b208a7c083689e50c6695855eeaad3d2</sys_scope>
        <sys_update_name>sys_metadata_link_0f76f0d983f01210c6695855eeaad3f5</sys_update_name>
        <sys_updated_by>admin</sys_updated_by>
        <sys_updated_on>2024-09-21 08:36:23</sys_updated_on>
        <tablename>sys_script_include</tablename>
    </sys_metadata_link>
</record_update>
