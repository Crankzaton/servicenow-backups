<?xml version="1.0" encoding="UTF-8"?><record_update table="sys_metadata_link">
    <sys_metadata_link action="INSERT_OR_UPDATE">
        <directory>update</directory>
        <documentkey>b1e670d00f9a3010e28740c1df767e49</documentkey>
        <payload>&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;record_update table="sys_script_include"&gt;
    &lt;sys_script_include action="INSERT_OR_UPDATE"&gt;
        &lt;access&gt;public&lt;/access&gt;
        &lt;active&gt;true&lt;/active&gt;
        &lt;api_name&gt;sn_appclient.AppsDataAPI&lt;/api_name&gt;
        &lt;caller_access/&gt;
        &lt;client_callable&gt;false&lt;/client_callable&gt;
        &lt;description/&gt;
        &lt;name&gt;AppsDataAPI&lt;/name&gt;
        &lt;script&gt;&lt;![CDATA[/**
 * This API is needed to other scopes access to limited number of private methods on AppData.
 **/
var AppsDataAPI = Class.create();
AppsDataAPI.prototype = {

    appsData: {},
    all: [],

    initialize: function() {
        this.appsData = new AppsData();
    },

    getAppCounts: function() {
        var apps = [];
        try {
            apps = this.appsData.getAllAppsWithVersions(false, false, false, false)['data'];

            return this._getCounts(apps);
        } catch (e) {
            gs.error(e.message);

            return {
                notInstalled: 0,
                updated: 0
            };
        }
    },

    _getCounts: function(apps) {
        var notInstalledCount = 0;
        var updatesCount = 0;

        apps.forEach(function(app) {

            if (this._isUpdate(app))
                updatesCount++;

            if (this._isReadyForInstall(app))
                notInstalledCount++;

        }, this);

        return {
            notInstalled: notInstalledCount,
            updated: updatesCount
        };
    },

    _isUpdate: function(app) {
        return app.version &amp;&amp; app.active &amp;&amp; app.latest_version != app.version &amp;&amp; app.can_install_or_upgrade &amp;&amp; app.isInstalledAndUpdateAvailable;
    },

    _isReadyForInstall: function(app) {
        return app.isInstalled === false;
    },

    getAllEntitledApps: function() {
        var apps = [];
        var plugins = [];
        try {
            apps = this.appsData.getAllAppsWithVersions(false, false, false, false)['data'];
            plugins = sn_ua.ScopedUAAppInfo.getAllPluginInfo();
            plugins = plugins.length == 0 ? [] : JSON.parse(plugins);
        } catch (e) {
            gs.error(e.message);
            return [];
        }

        return this._getEntitlementsObj(apps, plugins);
    },

    // Returns apps/plugins matching the sys_ids in a list
    getEntitledApps: function( /*[]*/ list) {
        var apps = [];
        var plugins = [];
        try {
            apps = this.appsData.getAllAppsWithVersions(false, false, false, false)['data'];
            plugins = sn_ua.ScopedUAAppInfo.getAllPluginInfo();
            plugins = plugins.length == 0 ? [] : JSON.parse(plugins);
        } catch (e) {
            gs.error(e.message);
            return [];
        }

        return this._getEntitlementsObj(this._filterAppsOrPlugins(apps, list), this._filterAppsOrPlugins(plugins, list));
    },

    _getEntitlementsObj: function(apps, plugins) {
        var result = [];
        var appMap = {};

        if (apps.length == 0 &amp;&amp; plugins.length == 0)
            return result;

        apps.forEach(function(app, index) {
            appMap[app.name] = this._getAppObj(app);
        }, this);

        var ignoredApps = {};
        plugins.forEach(function(plugin, index) {
            if (appMap[plugin.app_name]) {
                var pluginObj = this._getPluginObj(plugin);
                var combinedDependencies = this._mergeDependencies(appMap[plugin.app_name], pluginObj);

                if (this._treatAsPlugin(appMap[plugin.app_name], plugin)) {
                    ignoredApps[plugin.app_name] = true;
                    pluginObj.dependencies = combinedDependencies;
                    result.push(pluginObj);
                } else {
                    appMap[plugin.app_name].dependencies = combinedDependencies;
                }
            } else {
                result.push(this._getPluginObj(plugin));
            }
        }, this);

        for (var i = 0; i &lt; apps.length; i++) {
            if (!ignoredApps[apps[i].name]) {
                result.push(appMap[apps[i].name]);
            }
        }

        return result;
    },

    _mergeDependencies: function(app, plugin) {
        var arrayUtil = new global.ArrayUtil();
        return arrayUtil.union(app.dependencies || [], plugin.dependencies || []);
    },

    _treatAsPlugin: function(app, plugin) {
        return app.latest_version === app.version &amp;&amp; !app.isAppstorePlugin &amp;&amp; !plugin.is_customized_app;
    },

    _getAppObj: function(app) {
        var appData = this._pick(app,
            ['sys_id', 'isInstalled', 'name', 'short_description', 'scope', 'products', 'price_type', 'latest_version', 'sys_code', 'isAppstorePlugin', 'isInstalledAndUpdateAvailable']);
        appData.isApplication = true;
        appData.entitled = true;
	 if (appData.indicators &amp;&amp; appData.indicators.length &gt; 0) {
	    appData.indicators.forEach(function(item) {
            if (item.id == 'not_licensed') {
                appData.entitled = false;
            }
        });
	}
	if (appData.versions &amp;&amp; appData.versions.length &gt; 0) {
	    appData.entitled &amp;&amp; appData.versions.forEach(function(item, Index) {
            item.indicators.forEach(function(item) {
                if (item.id == 'not_licensed') {
                    appData.entitled = false;
                }
            });
        });
	}
        var hasValidAppVersions = app.versions &amp;&amp; Array.isArray(app.versions) &amp;&amp; app.versions.length &gt; 0;
        appData.version = hasValidAppVersions ? app.versions[app.versions.length - 1].version : app.version;
        appData.dependencies = hasValidAppVersions ? app.versions[app.versions.length - 1].dependencies : '';

        return appData;
    },

    _getPluginObj: function(plugin) {
        var pluginData = this._pick(plugin, ['sys_id', 'description', 'lob_id', 'lob_name']);
        pluginData.plugin_id = plugin.app_id;
        pluginData.isPlugin = true;
        pluginData.name = plugin.app_name;
        pluginData.isInstalled = plugin.active == 0 ? false : true;
        pluginData.paid = plugin.for_fee == 1;
        pluginData.entitled = plugin.license_check_required == 1 ? plugin.entitled : "not_applicable";
        pluginData.dependencies = this._getPluginDependencies(plugin.app_id);
        pluginData.is_customized_app = plugin.is_customized_app;

        return pluginData;
    },

    _getPluginDependencies: function(plugin_id) {
        var gr = new GlideRecord('v_plugin');
        gr.addQuery('id', plugin_id);
        gr.query();
        gr.next();

        return gr.getValue('requires');
    },

    // Fetches App/Plugin details data. Marketing data for AdminX.
    getStoreAppDetails: function(app_id, version, requiredForPurchase) {
        var appDetails = new AppsData().getStoreAppDetail(app_id, version, requiredForPurchase);
		return appDetails;
    },

    getAppDependencyStatus: function(appScope, dependencies) {
        return new DependencyProcessor(appScope).processDependency(dependencies.split(","));
    },

    // Creates an object composed of the picked object properties
    _pick: function(data, keys) {
        var result = {};

        keys.forEach(function(key) {
            if (data.hasOwnProperty(key)) result[key] = data[key];
        });

        return result;
    },

    _filterAppsOrPlugins: function(appsOrPlugins, sysIdList) {
        var arrayUtil = new global.ArrayUtil();
        return appsOrPlugins.filter(function(i) {
			// Only plugin object has app_id(plugin_id) and for apps use sys_id
            return !gs.nil(i.app_id) ? arrayUtil.contains(sysIdList, i.app_id) : arrayUtil.contains(sysIdList, i.sys_id);
        });
    },

    type: 'AppsDataAPI'
};]]&gt;&lt;/script&gt;
        &lt;sys_class_name&gt;sys_script_include&lt;/sys_class_name&gt;
        &lt;sys_created_by&gt;admin&lt;/sys_created_by&gt;
        &lt;sys_created_on&gt;2021-08-26 18:32:14&lt;/sys_created_on&gt;
        &lt;sys_id&gt;b1e670d00f9a3010e28740c1df767e49&lt;/sys_id&gt;
        &lt;sys_mod_count&gt;57&lt;/sys_mod_count&gt;
        &lt;sys_name&gt;AppsDataAPI&lt;/sys_name&gt;
        &lt;sys_package display_value="Scoped App Client" source="sn_appclient"&gt;781f36a96fef21005be8883e6b3ee43d&lt;/sys_package&gt;
        &lt;sys_policy&gt;read&lt;/sys_policy&gt;
        &lt;sys_scope display_value="Scoped App Client"&gt;781f36a96fef21005be8883e6b3ee43d&lt;/sys_scope&gt;
        &lt;sys_update_name&gt;sys_script_include_b1e670d00f9a3010e28740c1df767e49&lt;/sys_update_name&gt;
        &lt;sys_updated_by&gt;admin&lt;/sys_updated_by&gt;
        &lt;sys_updated_on&gt;2023-06-23 07:10:54&lt;/sys_updated_on&gt;
    &lt;/sys_script_include&gt;
&lt;/record_update&gt;
</payload>
        <sys_class_name>sys_metadata_link</sys_class_name>
        <sys_created_by>admin</sys_created_by>
        <sys_created_on>2024-09-21 09:18:10</sys_created_on>
        <sys_id>1700899d83341210c6695855eeaad3a6</sys_id>
        <sys_mod_count>0</sys_mod_count>
        <sys_name>AppsDataAPI</sys_name>
        <sys_package display_value="Now Utils" source="x_938076_now_utils">b208a7c083689e50c6695855eeaad3d2</sys_package>
        <sys_policy/>
        <sys_scope display_value="Now Utils">b208a7c083689e50c6695855eeaad3d2</sys_scope>
        <sys_update_name>sys_metadata_link_1700899d83341210c6695855eeaad3a6</sys_update_name>
        <sys_updated_by>admin</sys_updated_by>
        <sys_updated_on>2024-09-21 09:18:10</sys_updated_on>
        <tablename>sys_script_include</tablename>
    </sys_metadata_link>
</record_update>
