<?xml version="1.0" encoding="UTF-8"?><record_update table="sys_metadata_link">
    <sys_metadata_link action="INSERT_OR_UPDATE">
        <directory>update</directory>
        <documentkey>20d8dcac5bd81010f22b6e533381c762</documentkey>
        <payload>&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;record_update table="sys_script_include"&gt;
    &lt;sys_script_include action="INSERT_OR_UPDATE"&gt;
        &lt;access&gt;public&lt;/access&gt;
        &lt;active&gt;true&lt;/active&gt;
        &lt;api_name&gt;global.FSMTimeUtil&lt;/api_name&gt;
        &lt;caller_access/&gt;
        &lt;client_callable&gt;false&lt;/client_callable&gt;
        &lt;description/&gt;
        &lt;name&gt;FSMTimeUtil&lt;/name&gt;
        &lt;script&gt;&lt;![CDATA[var FSMTimeUtil = Class.create();
    FSMTimeUtil.prototype = {
    
        initialize: function() {
            this.type = {};
            this.type.ASSIGNED_ACCEPTED = 0;
            this.type.ACCEPTED_ONROUTE = 1;
            this.type.WIP = 2;
            this.type.CLOSED = 3;
            this.isOnsiteEnabled = new global.FSMOnsiteUtil().isOnsiteEnabled("wm_task"); 
                if(this.isOnsiteEnabled){
                this.type.ACCEPTED_ONSITE = 4; 
		    }
        },
    
        changeTimeZone: function(object, prop, timeZone) {
            if (!JSUtil.nil(prop) &amp;&amp; !JSUtil.nil(timeZone)) {
                var tz = Packages.java.util.TimeZone.getTimeZone(timeZone);
                object[prop].getGlideObject().setTZ(tz);
            }
        },
    
        getCurrentUserTimeFormat: function() {
            return gs.getSession().getUser().getTimeFormat() + "";
        },
    
        // Return init window for task. Moved from DynamicSchedulingAgentRecommendationUtil - housing it here.
        initWindow: function(task) {
            var windowStart = task.getValue("window_start");
            var windowEnd = task.getValue("window_end");
            var now = new GlideDateTime(GlideSystemDateUtil.nowNoTZ());
            var windowTimes = {};
            var useScheduleStart = false;
    
            // no window start
            if (JSUtil.nil(windowStart)) {
                windowTimes.window_start = now;
            } else {
                var windowStartDate = new GlideDateTime(windowStart);
                if (windowStartDate.compareTo(now) &lt; 0) {
                    windowTimes.window_start = now;
                } else {
                    windowTimes.window_start = new GlideDateTime(windowStart);
                }
            }
    
            if (JSUtil.nil(windowEnd)) {
                var timeLeft = GlideProperties.getInt("com.snc.wm.wo.task_window_days", 4);
                var windowEnd = new GlideDateTime(windowTimes.window_start);
                windowEnd.addDaysUTC(timeLeft);
                windowTimes.window_end = windowEnd;
            } else {
                var windowEndDate = new GlideDateTime(windowEnd);
                windowTimes.window_end = windowEndDate;
            }
    
            return windowTimes;
        },
    
        getWindowTimesForTasks: function(tableName, selectedTasks) {
            var window = {};
            var minWindowStart = null,
                maxWindowEnd = null;
            var minWindowStartValue = Number.MAX_VALUE,
                maxWindowEndValue = -1;
    
            var taskGR = new GlideRecord(tableName);
            taskGR.addQuery('sys_id', 'IN', selectedTasks.join() + '');
            taskGR.query();
    
            while (taskGR.next()) {
                var windowTimes = this.initWindow(taskGR);
                var windowStart = windowTimes.window_start.getNumericValue();
                var windowEnd = windowTimes.window_end.getNumericValue();
    
                if (JSUtil.notNil(windowStart) &amp;&amp; windowStart &lt; minWindowStartValue) {
                    minWindowStartValue = windowStart;
                    minWindowStart = windowTimes.window_start;
                }
                if (JSUtil.notNil(windowEnd) &amp;&amp; windowEnd &gt; maxWindowEndValue) {
                    maxWindowEndValue = windowEnd;
                    maxWindowEnd = windowTimes.window_end;
                }
            }
    
            window.windowStart = minWindowStart;
            window.windowEnd = maxWindowEnd;
            return window;
        },
    
        _getTimestamps: function(taskGr, type, startTimeField) {
            var start_time, mid_time, end_time, start_gdt, end_gdt;
            switch (type) {
                case this.type.ASSIGNED_ACCEPTED:
                    start_gdt = new GlideDateTime(taskGr.getValue(startTimeField));
                    start_time = start_gdt.getNumericValue();
                    mid_time = new GlideDateTime(taskGr.getValue("expected_start")).getNumericValue();
                    end_gdt = new GlideDateTime(taskGr.getValue("estimated_end"));
                    end_time = end_gdt.getNumericValue();
                    break;
                case this.type.ACCEPTED_ONROUTE:
                    start_gdt = new GlideDateTime(taskGr.getValue(startTimeField));
                    start_time = start_gdt.getNumericValue();
                    mid_time = start_time + new GlideDateTime(taskGr.getValue("estimated_travel_duration")).getNumericValue();
                    if(this.isOnsiteEnabled)
					  mid_time = mid_time + new GlideDateTime(taskGr.getValue("estimated_onsite_arrival_buffer_duration")).getNumericValue();
                    end_time = mid_time + new GlideDateTime(taskGr.getValue("estimated_work_duration")).getNumericValue();
                    end_gdt = start_gdt;
                    end_gdt.add(new GlideDateTime(taskGr.getValue("estimated_travel_duration")).getNumericValue());
                    if(this.isOnsiteEnabled)
					 	end_gdt.add(new GlideDateTime(taskGr.getValue("estimated_onsite_arrival_buffer_duration")).getNumericValue());
                    end_gdt.add(new GlideDateTime(taskGr.getValue("estimated_work_duration")).getNumericValue());
                    break;
                case this.type.ACCEPTED_ONSITE :    
					start_gdt = new GlideDateTime(taskGr.getValue(startTimeField));
					start_time = start_gdt.getNumericValue();
					mid_time = start_time + new GlideDateTime(taskGr.getValue("estimated_onsite_arrival_buffer_duration")).getNumericValue();
					end_time = mid_time + new GlideDateTime(taskGr.getValue("estimated_work_duration")).getNumericValue();
					end_gdt = start_gdt;
					end_gdt.add(new GlideDateTime(taskGr.getValue("estimated_onsite_arrival_buffer_duration")).getNumericValue());
					end_gdt.add(new GlideDateTime(taskGr.getValue("estimated_work_duration")).getNumericValue());
					break;	    
                case this.type.WIP:
                    start_gdt = new GlideDateTime(taskGr.getValue(startTimeField));
                    start_time = start_gdt.getNumericValue();
                    mid_time = new GlideDateTime(taskGr.getValue("work_start")).getNumericValue();
                    // for WIP task, if no actual_travel_start, do not pick the expected_travel_start to avoid the long narrow bar
                    if (startTimeField === "expected_travel_start")
                        start_time = mid_time;
                    else
                        start_time = Math.min(start_time, mid_time);
                    end_time = mid_time + new GlideDateTime(taskGr.getValue("estimated_work_duration")).getNumericValue();
                    end_gdt = new GlideDateTime(taskGr.getValue("work_start"));
                    if(start_time == 0 &amp;&amp; mid_time == 0 &amp;&amp; end_gdt.getNumericValue() == 0)
						end_time = 0;					
					else
						end_gdt.add(new GlideDateTime(taskGr.getValue("estimated_work_duration")).getNumericValue());
                    break;
                case this.type.CLOSED:
                    start_gdt = new GlideDateTime(taskGr.getValue(startTimeField));
                    start_time = start_gdt.getNumericValue();
                    mid_time = new GlideDateTime(taskGr.getValue("work_start")).getNumericValue();
                    // for closed task, if no actual_travel_start, do not pick the expected_travel_start to avoid the long narrow bar
                    if (startTimeField === "expected_travel_start")
                        start_time = mid_time;
                    else
                        start_time = Math.min(start_time, mid_time);
                    end_gdt = new GlideDateTime(taskGr.getValue("work_end"));
                    end_time = end_gdt.getNumericValue();
                    break;
                default:
                    start_time = null;
                    mid_time = null;
                    end_time = null;
                    end_gdt = new GlideDateTime();
            }
    
            start_gdt = new GlideDateTime();
            if (start_time)
                start_gdt.setNumericValue(start_time);
            return {
                start_time: start_time,
                mid_time: mid_time,
                end_time: end_time,
                end_gdt: end_gdt,
                start_gdt: start_gdt
            };
        },
    
        getTaskTimeFields: function(state, subState, taskRec) {
            var startTimeField = "";
            var taskType = -1;
            if ((state == 16 || state == 17 || state == 12) &amp;&amp; (gs.nil(subState) || (subState != 8 &amp;&amp; subState != 10))) { // subState 10 is onsite arrival introduced in Van Couver
                startTimeField = "expected_travel_start";
                taskType = this.type.ASSIGNED_ACCEPTED;
            } else if (state == 17 &amp;&amp; subState == 8) {
                startTimeField = "actual_travel_start";
                taskType = this.type.ACCEPTED_ONROUTE;
            } else if(this.isOnsiteEnabled &amp;&amp; state==17 &amp;&amp; subState==10){ 
				startTimeField = "actual_onsite_arrival"; 
				taskType = this.type.ACCEPTED_ONSITE;
		    } else if (state == 18 &amp;&amp; gs.nil(taskRec.getValue("actual_travel_start"))) {
                startTimeField = "expected_travel_start";
                taskType = this.type.WIP;
            } else if (state == 18) {
                startTimeField = "actual_travel_start";
                taskType = this.type.WIP;
            } else if ((state == 3 || state == 4) &amp;&amp; gs.nil(taskRec.getValue("actual_travel_start"))) {
                startTimeField = "expected_travel_start";
                taskType = this.type.CLOSED;
            } else if (state == 3 || state == 4) {
                startTimeField = "actual_travel_start";
                taskType = this.type.CLOSED;
            }
            return {
                "startTimeField": startTimeField,
                "taskType": taskType
            };
        },
	
		updateDisplayDateTimeFieldsAsync: function(taskId) {
			var taskRec = new GlideRecord("wm_task");
			taskRec.addEncodedQuery("sys_id="+taskId);
			taskRec.setCategory("field_service");
			taskRec.query();

			taskRec.next();
			return this.updateDisplayDateTimeFields(taskRec);
        },

        updateDisplayDateTimeFields: function(taskRec) {
            var timeFields = this.getTaskTimeFields(taskRec.state, taskRec.substate, taskRec);
            var startTimeField = timeFields["startTimeField"];
            var taskType = timeFields["taskType"];
    
            var timestamps = this._getTimestamps(taskRec, taskType, startTimeField);
            taskRec.display_travel_start = timestamps.start_gdt;
            taskRec.display_work_end = timestamps.end_gdt;
            taskRec.setWorkflow(false)
            return taskRec.update();
        },

        getDateStart: function(date, timezone) {
            var dateStart = new GlideDateTime(date.getValue());
            dateStart.setTimeZone(timezone);
            dateStart.setDisplayValue(dateStart.getLocalDate().getDisplayValue());
            return dateStart;
        },
    
        type: 'FSMTimeUtil'
    };]]&gt;&lt;/script&gt;
        &lt;sys_class_name&gt;sys_script_include&lt;/sys_class_name&gt;
        &lt;sys_created_by&gt;admin&lt;/sys_created_by&gt;
        &lt;sys_created_on&gt;2020-04-17 08:33:07&lt;/sys_created_on&gt;
        &lt;sys_id&gt;20d8dcac5bd81010f22b6e533381c762&lt;/sys_id&gt;
        &lt;sys_mod_count&gt;8&lt;/sys_mod_count&gt;
        &lt;sys_name&gt;FSMTimeUtil&lt;/sys_name&gt;
        &lt;sys_package display_value="Field Service Management" source="com.snc.work_management"&gt;b66bd6bb4722c210cd4e1ce4316d4387&lt;/sys_package&gt;
        &lt;sys_policy/&gt;
        &lt;sys_scope display_value="Global"&gt;global&lt;/sys_scope&gt;
        &lt;sys_update_name&gt;sys_script_include_20d8dcac5bd81010f22b6e533381c762&lt;/sys_update_name&gt;
        &lt;sys_updated_by&gt;admin&lt;/sys_updated_by&gt;
        &lt;sys_updated_on&gt;2023-05-26 01:18:54&lt;/sys_updated_on&gt;
    &lt;/sys_script_include&gt;
&lt;/record_update&gt;
</payload>
        <sys_class_name>sys_metadata_link</sys_class_name>
        <sys_created_by>admin</sys_created_by>
        <sys_created_on>2024-09-21 08:11:56</sys_created_on>
        <sys_id>05e03c1983b01210c6695855eeaad35f</sys_id>
        <sys_mod_count>0</sys_mod_count>
        <sys_name>FSMTimeUtil</sys_name>
        <sys_package display_value="Now Utils" source="x_938076_now_utils">b208a7c083689e50c6695855eeaad3d2</sys_package>
        <sys_policy/>
        <sys_scope display_value="Now Utils">b208a7c083689e50c6695855eeaad3d2</sys_scope>
        <sys_update_name>sys_metadata_link_05e03c1983b01210c6695855eeaad35f</sys_update_name>
        <sys_updated_by>admin</sys_updated_by>
        <sys_updated_on>2024-09-21 08:11:56</sys_updated_on>
        <tablename>sys_script_include</tablename>
    </sys_metadata_link>
</record_update>
