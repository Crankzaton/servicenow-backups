<?xml version="1.0" encoding="UTF-8"?><record_update table="sys_metadata_link">
    <sys_metadata_link action="INSERT_OR_UPDATE">
        <directory>update</directory>
        <documentkey>2bdb76b8532313008cd9ddeeff7b12a9</documentkey>
        <payload>&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;record_update table="sys_script_include"&gt;
    &lt;sys_script_include action="INSERT_OR_UPDATE"&gt;
        &lt;access&gt;public&lt;/access&gt;
        &lt;active&gt;true&lt;/active&gt;
        &lt;api_name&gt;global.ATFOrderUpdate&lt;/api_name&gt;
        &lt;caller_access/&gt;
        &lt;client_callable&gt;false&lt;/client_callable&gt;
        &lt;description/&gt;
        &lt;name&gt;ATFOrderUpdate&lt;/name&gt;
        &lt;script&gt;&lt;![CDATA[var ATFOrderUpdate = Class.create();
ATFOrderUpdate.prototype = {
    initialize: function() {
    },

	getNextOrder: function(tableName, testId) {
		var ga = new GlideAggregate(tableName);
		ga.addQuery("test", testId);
		ga.addAggregate("COUNT");
		ga.query();
		if (ga.next())
			return parseInt(ga.getAggregate("COUNT"), 10)+1;

		return 1;
	},

	reorderAfterRemove: function(tableName, currGr) {
		var gr = new GlideRecord(tableName);
		gr.addQuery("test", currGr.test);
		gr.orderBy('order');
		gr.query();
		var smallestRemovedNumber = 1;
		while (gr.next()) {
			if(parseInt(gr.order, 10) !== smallestRemovedNumber) {

				// Make it zero so all upcoming are decremented
				smallestRemovedNumber = 0;
				gr.order--;
				gr.setWorkflow(false);
				gr.update();

				// generate the customer update
				gr.setWorkflow(true);
				gr.setForceUpdate(true);
				gr.update();
			} else {
				smallestRemovedNumber++;
			}
		}

		if (tableName == 'sys_atf_step')
			this.updateStepsThatReferenceStepNumbersInDescription(currGr);
	},
	
	updateOrder : function (tableName, currGr, prevGr) {
		var ga = new GlideAggregate(tableName);
		ga.addQuery("test", currGr.test);
		ga.addAggregate("COUNT");
		ga.query();
		if (ga.next()) {
			var numberOfSteps = parseInt(ga.getAggregate("COUNT"), 10);
			if (!this.justEndsMovedOutOfRange(currGr, prevGr, numberOfSteps)) {
				this.reorderStepsBetween(tableName, currGr, prevGr.getValue('order'), numberOfSteps);
				if (tableName == 'sys_atf_step')
					this.updateStepsThatReferenceStepNumbersInDescription(currGr);
			}
		}
	},
	
	updateRecordsAfterCurrent : function (tableName, currGr) {
		var ga = new GlideAggregate(tableName);
		ga.addQuery("test", currGr.test);
		ga.addAggregate("COUNT");
		ga.query();

		if (ga.next()) {

			// current is not counted, so adding by one
			var numberOfSteps = parseInt(ga.getAggregate("COUNT"), 10) + 1;
			if (this.withinRange(currGr, numberOfSteps)) {
				this.shiftUpStepsAfter(tableName, currGr);
				if (tableName == 'sys_atf_step')
					this.updateStepsThatReferenceStepNumbersInDescription(currGr);
			}
		}
	},
	
	justEndsMovedOutOfRange : function (currGr, prevGr, highestNumber) {
        if (prevGr.order == 1 &amp;&amp; currGr.order &lt; prevGr.order) {
            currGr.order = 1;
            return true;
        } else if (prevGr.order == highestNumber &amp;&amp; currGr.order &gt; prevGr.order) {
            currGr.order = highestNumber;
            return true;
        }
        return false;
    },
	
	shiftUpStepsAfter : function (tableName, afterThisRecord) {
        var gr = new GlideRecord(tableName);
        gr.addQuery("test", afterThisRecord.test);
        gr.addQuery("order", '&gt;=', afterThisRecord.order);
        gr.orderByDesc('order');
        gr.query();
        while (gr.next()) {
            gr.order++;
            gr.setWorkflow(false);
            gr.update();

            // generate the customer update
            gr.setWorkflow(true);
            gr.setForceUpdate(true);
            gr.update();
        }
    },
	
	reorderStepsBetween : function(tableName, currGr, prevGrStepNumber, totalNumberOfSteps) {
        this.withinRange(currGr, totalNumberOfSteps);

        // The way to make sense of this algo is to account for two scenarios:
        // 1. If I'm replacing a step number less than me, that number
        //      and numbers less than my prevGr, need to shift up
        // 2. If I'm replacing a step number greater than me, that number
        //      and numbers greater than my prevGr, need to shift down
        // However, in both cases, we need to start the shift with the step closest to the gap
        // in order to prevent index collision.
        var startingStepNumber = totalNumberOfSteps;
        var endingStepNumber = totalNumberOfSteps;
        var shiftValue = 0;
        var gr = new GlideRecord(tableName);
        gr.addQuery("test", currGr.test);
        if (currGr.order &gt; prevGrStepNumber) {
            startingStepNumber = prevGrStepNumber;
            endingStepNumber = currGr.getValue('order');
            shiftValue = -1;
            gr.addQuery("order", '&gt;', startingStepNumber);
            gr.addQuery("order", '&lt;=', endingStepNumber);
            gr.orderBy('order');
        } else {
            startingStepNumber = currGr.getValue('order');
            endingStepNumber = prevGrStepNumber;
            shiftValue = 1;
            gr.addQuery("order", '&gt;=', startingStepNumber);
            gr.addQuery("order", '&lt;', endingStepNumber);
            gr.orderByDesc('order');
        }
        gr.addQuery("sys_id", '!=', currGr.sys_id);

        // Two pass takes a snapshot of our gliderecord's ordering before our shifting operation
        gr.setTwoPass();
        gr.query();

        // Another index collision prevention measure is to temporarily place currGr to the largest new
        // position, during the shift, before placing it back to its new position.
        var currGrStepNumber = currGr.getValue('order');
        currGr.order = totalNumberOfSteps + 1;
        currGr.setSystem(false);
        currGr.setWorkflow(false);
        currGr.update();

        while (gr.next()) {
            gr.order += shiftValue;
            gr.setWorkflow(false);
            gr.update();

            // generate the customer update
            gr.setWorkflow(true);
            gr.setForceUpdate(true);
            gr.update();
        }

        currGr.setWorkflow(true);
        currGr.setSystem(true);
        currGr.order = currGrStepNumber;
        currGr.update();
    },
	
	withinRange : function (currGr, highestNumber) {
        if (gs.nil(currGr.order) || currGr.order &gt;= highestNumber) {
            currGr.order = highestNumber;
            return false;
        } else if (currGr.order &lt; 1) {
            currGr.order = 1;
            return true;
        }
        return true;
    },
	
	updateStepsThatReferenceStepNumbersInDescription : function (currGr){
        var gr = new GlideRecord('sys_atf_step');
        gr.addQuery("test", currGr.test);
        gr.addQuery("description", "CONTAINS", "{{Step");
        gr.query();

        while (gr.next()) {
            gr.setForceUpdate(true);
            gr.update();
        }
    },
    type: 'ATFOrderUpdate'
};]]&gt;&lt;/script&gt;
        &lt;sys_class_name&gt;sys_script_include&lt;/sys_class_name&gt;
        &lt;sys_created_by&gt;admin&lt;/sys_created_by&gt;
        &lt;sys_created_on&gt;2018-07-24 20:32:47&lt;/sys_created_on&gt;
        &lt;sys_id&gt;2bdb76b8532313008cd9ddeeff7b12a9&lt;/sys_id&gt;
        &lt;sys_mod_count&gt;12&lt;/sys_mod_count&gt;
        &lt;sys_name&gt;ATFOrderUpdate&lt;/sys_name&gt;
        &lt;sys_package display_value="Automated Test Framework" source="com.glide.automated_testing_framework"&gt;ee18bcec3cb1311068bcf327dfe37fc8&lt;/sys_package&gt;
        &lt;sys_policy&gt;read&lt;/sys_policy&gt;
        &lt;sys_scope display_value="Global"&gt;global&lt;/sys_scope&gt;
        &lt;sys_update_name&gt;sys_script_include_2bdb76b8532313008cd9ddeeff7b12a9&lt;/sys_update_name&gt;
        &lt;sys_updated_by&gt;admin&lt;/sys_updated_by&gt;
        &lt;sys_updated_on&gt;2020-10-30 05:48:07&lt;/sys_updated_on&gt;
    &lt;/sys_script_include&gt;
&lt;/record_update&gt;
</payload>
        <sys_class_name>sys_metadata_link</sys_class_name>
        <sys_created_by>admin</sys_created_by>
        <sys_created_on>2024-09-21 08:13:04</sys_created_on>
        <sys_id>a921709983b01210c6695855eeaad3f6</sys_id>
        <sys_mod_count>0</sys_mod_count>
        <sys_name>ATFOrderUpdate</sys_name>
        <sys_package display_value="Now Utils" source="x_938076_now_utils">b208a7c083689e50c6695855eeaad3d2</sys_package>
        <sys_policy/>
        <sys_scope display_value="Now Utils">b208a7c083689e50c6695855eeaad3d2</sys_scope>
        <sys_update_name>sys_metadata_link_a921709983b01210c6695855eeaad3f6</sys_update_name>
        <sys_updated_by>admin</sys_updated_by>
        <sys_updated_on>2024-09-21 08:13:04</sys_updated_on>
        <tablename>sys_script_include</tablename>
    </sys_metadata_link>
</record_update>
