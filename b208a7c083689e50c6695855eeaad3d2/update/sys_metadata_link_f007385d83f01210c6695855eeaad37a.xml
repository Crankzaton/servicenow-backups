<?xml version="1.0" encoding="UTF-8"?><record_update table="sys_metadata_link">
    <sys_metadata_link action="INSERT_OR_UPDATE">
        <directory>update</directory>
        <documentkey>72f75af353232010c722ddeeff7b126b</documentkey>
        <payload>&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;record_update table="sys_script_include"&gt;
    &lt;sys_script_include action="INSERT_OR_UPDATE"&gt;
        &lt;access&gt;package_private&lt;/access&gt;
        &lt;active&gt;true&lt;/active&gt;
        &lt;api_name&gt;sn_mab_api.ConfigSortingService&lt;/api_name&gt;
        &lt;caller_access/&gt;
        &lt;client_callable&gt;false&lt;/client_callable&gt;
        &lt;description/&gt;
        &lt;name&gt;ConfigSortingService&lt;/name&gt;
        &lt;script&gt;&lt;![CDATA[var ConfigSortingService = Class.create();
ConfigSortingService.prototype = {
    initialize: function() {
        this.validationHandler = new sn_mab_api.ValidationHandler();
        this.errorHandler = new sn_mab_api.ErrorHandler();
    },

    sortNodes: function(inputData) {
        var sortedNodes = [];
        var nodesMap = this.parseNodes(inputData);
        this.connectNodes(nodesMap);

        var foundGraph;
        //Try to extract all the different graphs from our nodes one at a time
        do {
            foundGraph = false;
            var extractedGraph = this.extractGraph(nodesMap);
            if (extractedGraph &amp;&amp; Object.keys(extractedGraph).length) {
                foundGraph = true;
                sortedNodes = this.concatArray(sortedNodes, this.sortGraphTopographicalOrder(extractedGraph));
            }
        } while(foundGraph);

        //Sanity check, we should have cleared out all our nodes or found a cycle and thrown an error
        if (Object.keys(nodesMap).length)
            this.errorHandler.throwInternalError('Error - Remaining nodes after sorting');

        //cleanup
        sortedNodes.forEach(function(currNode) {
            delete currNode.children;
            delete currNode.parents;
            delete currNode.tempMarked;
            delete currNode.marked;
        });

        return sortedNodes;
    },

    parseNodes: function(inputData) {
        var outputNodesMap = {};

        if (!inputData || !Object.keys(inputData).length)
            return outputNodesMap;

        //Flatten structure and create a map of sysId to nodes
        for (var currTableName in inputData) {
            for (var currSysId in inputData[currTableName]) {
                var outputNode = {'tableName': currTableName, 'sysId': currSysId, 'fields': inputData[currTableName][currSysId], 'children': [], 'parents': []};
                outputNodesMap[currSysId] = outputNode;
            }
        }

        return outputNodesMap;
    },

    connectNodes: function(nodes) {
        //Connect all nodes just by comparing sysIds, sysIds should be unique across all tables/rows
        for (var currNodeSysId in nodes) {
            var currNode = nodes[currNodeSysId];
            //loop through all nodes fields for any value which can represent a sysId
            for (var currFieldName in currNode.fields) {
                var possibleSysId = currNode.fields[currFieldName];
                //Does our curr field contain something like a sysId and does this sysId exist in our nodes?
                if (!this.validationHandler.isGeneratedOrNormalSysId(possibleSysId) || !nodes[possibleSysId])
                    continue;

                // if update node contains its sys_id dont connect as child or parent
                if (currNodeSysId === possibleSysId)
                    continue;

                currNode.children.push(possibleSysId);
                nodes[possibleSysId].parents.push(currNodeSysId);
            }
        }
    },

    extractGraph: function(nodesMap) {
        var nodesMapKeys = Object.keys(nodesMap);
        //Anything left to extract?
        if (!nodesMapKeys.length)
            return null;

        //If so grab the first one and follow it to extract out the graph connected to it
        var extractedGraphNodes = {};
        this.extractGraphNodes(nodesMapKeys[0], nodesMap, extractedGraphNodes);
        return extractedGraphNodes;
    },

    extractGraphNodes: function(currNodeSysId, allNodes, graphNodes) {
        //Does currNode exist?
        if (!allNodes[currNodeSysId])
            return;

        //Add ourselves to the output and delete from original node list
        var currNode = allNodes[currNodeSysId];
        graphNodes[currNodeSysId] = currNode;
        delete allNodes[currNodeSysId];

        //Process children and parent nodes
        currNode.children.forEach(function(currChildSysId){
            this.extractGraphNodes(currChildSysId, allNodes, graphNodes);
        }, this);
        currNode.parents.forEach(function(currParentSysId){
            this.extractGraphNodes(currParentSysId, allNodes, graphNodes);
        }, this);
    },

    //Topographical sort algorithm based on depth first search
    sortGraphTopographicalOrder: function(graphNodes) {
        var sortedNodes = [];
        var foundUnMarkedNode;
        do {
            foundUnMarkedNode = false;
            for(var currNodeSysId in graphNodes) {
                if (graphNodes[currNodeSysId].marked)
                    continue;

                foundUnMarkedNode = true;
                this.visitNode(graphNodes[currNodeSysId], graphNodes, sortedNodes);
            }
        } while(foundUnMarkedNode);

        return sortedNodes;
    },

    visitNode: function(node, graphNodes, sortedNodes) {
        if (!node || node.marked)
            return;

        if (node.tempMarked)
            this.errorHandler.throwBadRequestError('Error - Cycle found in nodes, cannot sort');

        node.tempMarked = true;

        node.children.forEach(function(currChildSysId){
            this.visitNode(graphNodes[currChildSysId], graphNodes, sortedNodes);
        }, this);

        node.tempMarked = false;
        node.marked = true;

        sortedNodes.push(node);
    },

    concatArray: function(first, second) {
        var outputArray = [];
        if (first)
            outputArray = first;

        if (second)
            second.forEach(function(currValue) {
                outputArray.push(currValue);
            });

        return outputArray;
    },

    type: 'ConfigSortingService'
};
]]&gt;&lt;/script&gt;
        &lt;sys_class_name&gt;sys_script_include&lt;/sys_class_name&gt;
        &lt;sys_created_by&gt;admin&lt;/sys_created_by&gt;
        &lt;sys_created_on&gt;2021-04-23 05:42:53&lt;/sys_created_on&gt;
        &lt;sys_id&gt;72f75af353232010c722ddeeff7b126b&lt;/sys_id&gt;
        &lt;sys_mod_count&gt;21&lt;/sys_mod_count&gt;
        &lt;sys_name&gt;ConfigSortingService&lt;/sys_name&gt;
        &lt;sys_package display_value="Mobile App Builder API" source="sn_mab_api"&gt;3c64259bc7812010100f2f3bf4c2609a&lt;/sys_package&gt;
        &lt;sys_policy&gt;read&lt;/sys_policy&gt;
        &lt;sys_scope display_value="Mobile App Builder API"&gt;3c64259bc7812010100f2f3bf4c2609a&lt;/sys_scope&gt;
        &lt;sys_update_name&gt;sys_script_include_72f75af353232010c722ddeeff7b126b&lt;/sys_update_name&gt;
        &lt;sys_updated_by&gt;admin&lt;/sys_updated_by&gt;
        &lt;sys_updated_on&gt;2021-04-26 08:17:32&lt;/sys_updated_on&gt;
    &lt;/sys_script_include&gt;
&lt;/record_update&gt;
</payload>
        <sys_class_name>sys_metadata_link</sys_class_name>
        <sys_created_by>admin</sys_created_by>
        <sys_created_on>2024-09-21 08:38:41</sys_created_on>
        <sys_id>f007385d83f01210c6695855eeaad37a</sys_id>
        <sys_mod_count>0</sys_mod_count>
        <sys_name>ConfigSortingService</sys_name>
        <sys_package display_value="Now Utils" source="x_938076_now_utils">b208a7c083689e50c6695855eeaad3d2</sys_package>
        <sys_policy/>
        <sys_scope display_value="Now Utils">b208a7c083689e50c6695855eeaad3d2</sys_scope>
        <sys_update_name>sys_metadata_link_f007385d83f01210c6695855eeaad37a</sys_update_name>
        <sys_updated_by>admin</sys_updated_by>
        <sys_updated_on>2024-09-21 08:38:41</sys_updated_on>
        <tablename>sys_script_include</tablename>
    </sys_metadata_link>
</record_update>
