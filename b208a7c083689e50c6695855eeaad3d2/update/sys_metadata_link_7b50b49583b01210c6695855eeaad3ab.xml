<?xml version="1.0" encoding="UTF-8"?><record_update table="sys_metadata_link">
    <sys_metadata_link action="INSERT_OR_UPDATE">
        <directory>update</directory>
        <documentkey>09ca6c8d88642110fa9bf275d1a0435c</documentkey>
        <payload>&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;record_update table="sys_script_include"&gt;
    &lt;sys_script_include action="INSERT_OR_UPDATE"&gt;
        &lt;access&gt;package_private&lt;/access&gt;
        &lt;active&gt;true&lt;/active&gt;
        &lt;api_name&gt;global.SplayTree&lt;/api_name&gt;
        &lt;caller_access/&gt;
        &lt;client_callable&gt;false&lt;/client_callable&gt;
        &lt;description/&gt;
        &lt;name&gt;SplayTree&lt;/name&gt;
        &lt;script&gt;&lt;![CDATA[//https://github.com/w8r/splay-tree/blob/v3.1.0/src/index.ts
var SplayTree = Class.create();
SplayTree.prototype = {
    initialize: function (comparator) {
        if (gs.nil(comparator)) {
            comparator = DEFAULT_COMPARE;
        }
        this._comparator = comparator;
    },

    type: 'SplayTree',

    _comparator: null,
    _root: null,
    _size: 0,


    /**
     * Inserts a key, allows duplicates
     */
    insert: function (key, data) {
        this._size++;
        return this._root = insert(key, data, this._root, this._comparator);
    },


    /**
     * Adds a key, if it is not present in the tree
     */
    add: function (key, data) {
        var node = new Node(key, data);

        if (this._root === null) {
            node.left = node.right = null;
            this._size++;
            this._root = node;
        }

        var comparator = this._comparator;
        var t = splay(key, this._root, comparator);
        var cmp = comparator(key, t.key);
        if (cmp === 0) this._root = t;
        else {
            if (cmp &lt; 0) {
                node.left = t.left;
                node.right = t;
                t.left = null;
            } else if (cmp &gt; 0) {
                node.right = t.right;
                node.left = t;
                t.right = null;
            }
            this._size++;
            this._root = node;
        }

        return this._root;
    },


    /**
     * @param  {Key} key
     * @return {Node}
     */
    remove: function (key) {
        this._root = this._remove(key, this._root, this._comparator);
    },


    /**
     * Deletes i from the tree if it's there
     */
    _remove: function (
        i, t,
        comparator) {
        var x;
        if (t === null) return null;
        t = splay(i, t, comparator);
        var cmp = comparator(i, t.key);
        if (cmp === 0) {
            /* found it */
            if (t.left === null) {
                x = t.right;
            } else {
                x = splay(i, t.left, comparator);
                x.right = t.right;
            }
            this._size--;
            return x;
        }
        return t; /* It wasn't there */
    },


    /**
     * Removes and returns the node with smallest key
     */
    pop: function () {
        var node = this._root;
        if (node) {
            while (node.left) node = node.left;
            this._root = splay(node.key, this._root, this._comparator);
            this._root = this._remove(node.key, this._root, this._comparator);
            return {
                key: node.key,
                data: node.data
            };
        }
        return null;
    },


    /**
     * Find without splaying
     */
    findStatic: function (key) {
        var current = this._root;
        var compare = this._comparator;
        while (current) {
            var cmp = compare(key, current.key);
            if (cmp === 0) return current;
            else if (cmp &lt; 0) current = current.left;
            else current = current.right;
        }
        return null;
    },


    find: function (key) {
        if (this._root) {
            this._root = splay(key, this._root, this._comparator);
            if (this._comparator(key, this._root.key) !== 0) return null;
        }
        return this._root;
    },


    contains: function (key) {
        var current = this._root;
        var compare = this._comparator;
        while (current) {
            var cmp = compare(key, current.key);
            if (cmp === 0) return true;
            else if (cmp &lt; 0) current = current.left;
            else current = current.right;
        }
        return false;
    },


    forEach: function (visitor, ctx) {
        var current = this._root;
        var Q = []; /* Initialize stack s */
        var done = false;

        while (!done) {
            if (current !== null) {
                Q.push(current);
                current = current.left;
            } else {
                if (Q.length !== 0) {
                    current = Q.pop();
                    visitor.call(ctx, current);

                    current = current.right;
                } else done = true;
            }
        }
        return this;
    },


    /**
     * Walk key range from `low` to `high`. Stops if `fn` returns a value.
     */
    range: function (low, high, fn, ctx) {
        var Q = [];
        var compare = this._comparator;
        var node = this._root;
        var cmp;

        while (Q.length !== 0 || node) {
            if (node) {
                Q.push(node);
                node = node.left;
            } else {
                node = Q.pop();
                cmp = compare(node.key, high);
                if (cmp &gt; 0) {
                    break;
                } else if (compare(node.key, low) &gt;= 0) {
                    if (fn.call(ctx, node)) return this; // stop if smth is returned
                }
                node = node.right;
            }
        }
        return this;
    },


    /**
     * Returns array of keys
     */
    keys: function () {
        var keys = [];
        this.forEach(function (obj) {
            keys.push(obj.key);
        });
        return keys;
    },


    /**
     * Returns array of all the data in the nodes
     */
    values: function () {
        var values = [];
        this.forEach(function (obj) {
            values.push(obj.data);
        });
        return values;
    },


    min: function () {
        if (this._root) return this.minNode(this._root).key;
        return null;
    },


    max: function () {
        if (this._root) return this.maxNode(this._root).key;
        return null;
    },


    minNode: function (t) {
        if (gs.nil(t)) {
            t = this._root;
        }
        if (t)
            while (t.left) t = t.left;
        return t;
    },


    maxNode: function (t) {
        if (gs.nil(t)) {
            t = this._root;
        }
        if (t)
            while (t.right) t = t.right;
        return t;
    },


    /**
     * Returns node at given index
     */
    at: function (index) {
        var current = this._root;
        var done = false;
        var i = 0;
        var Q = [];

        while (!done) {
            if (current) {
                Q.push(current);
                current = current.left;
            } else {
                if (Q.length &gt; 0) {
                    current = Q.pop();
                    if (i === index) return current;
                    i++;
                    current = current.right;
                } else done = true;
            }
        }
        return null;
    },


    next: function (d) {
        var root = this._root;
        var successor = null;

        if (d.right) {
            successor = d.right;
            while (successor.left) successor = successor.left;
            return successor;
        }

        var comparator = this._comparator;
        while (root) {
            var cmp = comparator(d.key, root.key);
            if (cmp === 0) break;
            else if (cmp &lt; 0) {
                successor = root;
                root = root.left;
            } else root = root.right;
        }

        return successor;
    },


    prev: function (d) {
        var root = this._root;
        var predecessor = null;

        if (d.left !== null) {
            predecessor = d.left;
            while (predecessor.right) predecessor = predecessor.right;
            return predecessor;
        }

        var comparator = this._comparator;
        while (root) {
            var cmp = comparator(d.key, root.key);
            if (cmp === 0) break;
            else if (cmp &lt; 0) root = root.left;
            else {
                predecessor = root;
                root = root.right;
            }
        }
        return predecessor;
    },


    clear: function () {
        this._root = null;
        this._size = 0;
        return this;
    },


    toList: function () {
        return toList(this._root);
    },


    /**
     * Bulk-load items. Both array have to be same size
     */
    load: function (keys, values, presort) {
        if (gs.nil(values)) {
            values = [];
        }
        if (gs.nil(presort)) {
            presort = false;
        }
        var size = keys.length;
        var comparator = this._comparator;

        // sort if needed
        if (presort) sort(keys, values, 0, size - 1, comparator);

        if (this._root === null) { // empty tree
            this._root = loadRecursive(keys, values, 0, size);
            this._size = size;
        } else { // that re-builds the whole tree from two in-order traversals
            var mergedList = mergeLists(this.toList(), createList(keys, values), comparator);
            size = this._size + size;
            this._root = sortedListToBST({
                head: mergedList
            }, 0, size);
        }
        return this;
    },


    isEmpty: function () {
        return this._root === null;
    },


    getSize: function () {
        return this._size;
    },
    geRoot: function () {
        return this._root;
    },

    toString: function (printNode) {
        var out = [];
        printRow(this._root, '', true, function (v) {
            out.push(v);
		}, printNode);
        return out.join('');
    },


    update: function (key, newKey, newData) {
        var comparator = this._comparator;
        var obj = split(key, this._root, comparator);
        var left = obj.left;
        var right = obj.right;
        if (comparator(key, newKey) &lt; 0) {
            right = insert(newKey, newData, right, comparator);
        } else {
            left = insert(newKey, newData, left, comparator);
        }
        this._root = merge(left, right, comparator);
    },


    split: function (key) {
        return split(key, this._root, this._comparator);
    }
};


var Node = Class.create();

Node.prototype = {
    key: null,
    data: null,
    left: null,
    right: null,
    next: null,
    initialize: function (key, data) {
        this.key = key;
        this.data = data;
        this.left = null;
        this.right = null;
    },
    type: 'Node'
};

function DEFAULT_COMPARE(a, b) {
    return a &gt; b ? 1 : a &lt; b ? -1 : 0;
}

/**
 * Simple top down splay, not requiring i to be in the tree t.
 */
function splay(i, t, comparator) {
    var N = new Node(null, null);
    var l = N;
    var r = N;

    while (true) {
        var cmp = comparator(i, t.key);
        //if (i &lt; t.key) {
        if (cmp &lt; 0) {
            if (t.left === null) break;
            //if (i &lt; t.left.key) {
            if (comparator(i, t.left.key) &lt; 0) {
                var y = t.left; /* rotate right */
                t.left = y.right;
                y.right = t;
                t = y;
                if (t.left === null) break;
            }
            r.left = t; /* link right */
            r = t;
            t = t.left;
            //} else if (i &gt; t.key) {
        } else if (cmp &gt; 0) {
            if (t.right === null) break;
            //if (i &gt; t.right.key) {
            if (comparator(i, t.right.key) &gt; 0) {
                var y2 = t.right; /* rotate left */
                t.right = y2.left;
                y2.left = t;
                t = y2;
                if (t.right === null) break;
            }
            l.right = t; /* link left */
            l = t;
            t = t.right;
        } else break;
    }
    /* assemble */
    l.right = t.left;
    r.left = t.right;
    t.left = N.right;
    t.right = N.left;
    return t;
}


function insert(
    i, data,
    t,
    comparator
) {
    var node = new Node(i, data);

    if (t === null) {
        node.left = node.right = null;
        return node;
    }

    t = splay(i, t, comparator);
    var cmp = comparator(i, t.key);
    if (cmp &lt; 0) {
        node.left = t.left;
        node.right = t;
        t.left = null;
    } else if (cmp &gt;= 0) {
        node.right = t.right;
        node.left = t;
        t.right = null;
    }
	
    return node;
}


function split(key, v, comparator) {
    var left = null;
    var right = null;
    if (v) {
        v = splay(key, v, comparator);

        var cmp = comparator(v.key, key);
        if (cmp === 0) {
            left = v.left;
            right = v.right;
        } else if (cmp &lt; 0) {
            right = v.right;
            v.right = null;
            left = v;
        } else {
            left = v.left;
            v.left = null;
            right = v;
        }
    }
    return {
        left: left,
        right: right
    };
}


function merge(
    left,
    right,
    comparator
) {
    if (right === null) return left;
    if (left === null) return right;

    right = splay(left.key, right, comparator);
    right.left = left;
    return right;
}



/**
 * Prints level of the tree
 */
function printRow(
    root,
    prefix,
    isTail,
    out,
    printNode
) {
    if (root) {
        out("" + prefix + isTail ? '└── ' : '├── ' + printNode(root) + "\n");
        var indent = prefix + (isTail ? '    ' : '│   ');
        if (root.left) printRow(root.left, indent, false, out, printNode);
        if (root.right) printRow(root.right, indent, true, out, printNode);
    }
}

function loadRecursive(keys, values, start, end) {
    var size = end - start;
    if (size &gt; 0) {
        var middle = start + Math.floor(size / 2);
        var key = keys[middle];
        var data = values[middle];
        var node = new Node(key, data);
        node.left = loadRecursive(keys, values, start, middle);
        node.right = loadRecursive(keys, values, middle + 1, end);
        return node;
    }
    return null;
}


function createList(keys, values) {
    var head = new Node(null, null);
    var p = head;
    for (var i = 0; i &lt; keys.length; i++) {
        p = p.next = new Node(keys[i], values[i]);
    }
    p.next = null;
    return head.next;
}


function toList(root) {
    var current = root;
    var Q = [];
    var done = false;

    var head = new Node(null, null);
    var p = head;

    while (!done) {
        if (current) {
            Q.push(current);
            current = current.left;
        } else {
            if (Q.length &gt; 0) {
                current = p = p.next = Q.pop();
                current = current.right;
            } else done = true;
        }
    }
    p.next = null; // that'll work even if the tree was empty
    return head.next;
}


function sortedListToBST(list, start, end) {
    var size = end - start;
    if (size &gt; 0) {
        var middle = start + Math.floor(size / 2);
        var left = sortedListToBST(list, start, middle);

        var root = list.head;
        root.left = left;

        list.head = list.head.next;

        root.right = sortedListToBST(list, middle + 1, end);
        return root;
    }
    return null;
}


function mergeLists(
    l1, l2,
    compare) {
    var head = new Node(null, null); // dummy
    var p = head;

    var p1 = l1;
    var p2 = l2;

    while (p1 !== null &amp;&amp; p2 !== null) {
        if (compare(p1.key, p2.key) &lt; 0) {
            p.next = p1;
            p1 = p1.next;
        } else {
            p.next = p2;
            p2 = p2.next;
        }
        p = p.next;
    }

    if (p1 !== null) {
        p.next = p1;
    } else if (p2 !== null) {
        p.next = p2;
    }

    return head.next;
}


function sort(
    keys, values,
    left, right, compare
) {
    if (left &gt;= right) return;

    var pivot = keys[(left + right) &gt;&gt; 1];
    var i = left - 1;
    var j = right + 1;

    while (true) {
        do i++; while (compare(keys[i], pivot) &lt; 0);
        do j--; while (compare(keys[j], pivot) &gt; 0);
        if (i &gt;= j) break;

        var tmp = keys[i];
        keys[i] = keys[j];
        keys[j] = tmp;

        tmp = values[i];
        values[i] = values[j];
        values[j] = tmp;
    }

    sort(keys, values, left, j, compare);
    sort(keys, values, j + 1, right, compare);
}]]&gt;&lt;/script&gt;
        &lt;sys_class_name&gt;sys_script_include&lt;/sys_class_name&gt;
        &lt;sys_created_by&gt;admin&lt;/sys_created_by&gt;
        &lt;sys_created_on&gt;2023-01-20 14:17:33&lt;/sys_created_on&gt;
        &lt;sys_id&gt;09ca6c8d88642110fa9bf275d1a0435c&lt;/sys_id&gt;
        &lt;sys_mod_count&gt;1&lt;/sys_mod_count&gt;
        &lt;sys_name&gt;SplayTree&lt;/sys_name&gt;
        &lt;sys_package display_value=""&gt;fa60558563b044509d2cba84af9c019c&lt;/sys_package&gt;
        &lt;sys_policy/&gt;
        &lt;sys_scope display_value=""&gt;fa60558563b044509d2cba84af9c019c&lt;/sys_scope&gt;
        &lt;sys_update_name&gt;sys_script_include_09ca6c8d88642110fa9bf275d1a0435c&lt;/sys_update_name&gt;
        &lt;sys_updated_by&gt;admin&lt;/sys_updated_by&gt;
        &lt;sys_updated_on&gt;2023-01-30 14:47:35&lt;/sys_updated_on&gt;
    &lt;/sys_script_include&gt;
&lt;/record_update&gt;
</payload>
        <sys_class_name>sys_metadata_link</sys_class_name>
        <sys_created_by>admin</sys_created_by>
        <sys_created_on>2024-09-21 08:09:40</sys_created_on>
        <sys_id>7b50b49583b01210c6695855eeaad3ab</sys_id>
        <sys_mod_count>0</sys_mod_count>
        <sys_name>SplayTree</sys_name>
        <sys_package display_value="Now Utils" source="x_938076_now_utils">b208a7c083689e50c6695855eeaad3d2</sys_package>
        <sys_policy/>
        <sys_scope display_value="Now Utils">b208a7c083689e50c6695855eeaad3d2</sys_scope>
        <sys_update_name>sys_metadata_link_7b50b49583b01210c6695855eeaad3ab</sys_update_name>
        <sys_updated_by>admin</sys_updated_by>
        <sys_updated_on>2024-09-21 08:09:40</sys_updated_on>
        <tablename>sys_script_include</tablename>
    </sys_metadata_link>
</record_update>
