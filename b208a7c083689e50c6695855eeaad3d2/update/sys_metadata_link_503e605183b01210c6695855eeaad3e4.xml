<?xml version="1.0" encoding="UTF-8"?><record_update table="sys_metadata_link">
    <sys_metadata_link action="INSERT_OR_UPDATE">
        <directory>update</directory>
        <documentkey>366bccb3472221004695d7527c9a717a</documentkey>
        <payload>&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;record_update sys_domain="global" table="sys_script"&gt;
    &lt;sys_script action="INSERT_OR_UPDATE"&gt;
        &lt;abort_action&gt;false&lt;/abort_action&gt;
        &lt;access&gt;package_private&lt;/access&gt;
        &lt;action_delete&gt;false&lt;/action_delete&gt;
        &lt;action_insert&gt;true&lt;/action_insert&gt;
        &lt;action_query&gt;false&lt;/action_query&gt;
        &lt;action_update&gt;true&lt;/action_update&gt;
        &lt;active&gt;true&lt;/active&gt;
        &lt;add_message&gt;false&lt;/add_message&gt;
        &lt;advanced&gt;true&lt;/advanced&gt;
        &lt;change_fields&gt;false&lt;/change_fields&gt;
        &lt;client_callable&gt;false&lt;/client_callable&gt;
        &lt;collection&gt;ecc_queue&lt;/collection&gt;
        &lt;condition&gt;current.state == "ready" &amp;amp;&amp;amp; current.queue == "output" &amp;amp;&amp;amp; current.agent == "RESTClient"&lt;/condition&gt;
        &lt;description/&gt;
        &lt;execute_function&gt;false&lt;/execute_function&gt;
        &lt;filter_condition/&gt;
        &lt;is_rest&gt;false&lt;/is_rest&gt;
        &lt;message/&gt;
        &lt;name&gt;RESTClient&lt;/name&gt;
        &lt;order&gt;100&lt;/order&gt;
        &lt;priority&gt;100&lt;/priority&gt;
        &lt;rest_method/&gt;
        &lt;rest_method_text/&gt;
        &lt;rest_service/&gt;
        &lt;rest_service_text/&gt;
        &lt;rest_variables/&gt;
        &lt;role_conditions/&gt;
        &lt;script&gt;&lt;![CDATA[scopeFunctionWrapper();
function scopeFunctionWrapper() {
	
	processEccOuputMessage();
	
	var g_end_point,g_method,g_uname,g_password,g_authorization,g_req,g_resp,g_content,g_content_attachment_source_id,g_log_level, g_http_timeout, g_follow_redirect, g_artifact_scope_id, g_caller_scope, g_artifact, g_artifact_type, g_calling_source, g_originating_scope;
	
	var g_message_params = {};
	var g_message_headers = {};
	var g_attachment_dest_metadata = {};
	// must initialize these as we're always putting them into transaction attributes
	var g_log_source_table = '';
	var g_log_source_record = '';
	
	function processEccOuputMessage() {
		current.state = "processed";
		current.processed = gs.nowDateTime();
		current.setWorkflow(false);
		current.update();
		parseOutputMessage();
		try {
			prepareHTTPReq();
		} catch (ex) {
			processException('Error constructing http request: ' + ex.getMessage());
			return;
		}
		
		try {
			g_resp = g_req.execute();
			processResponse();
		} catch (ex) {
			processException('Error invoking http request: ' + ex.getMessage());
			return;
		}
	}
	
	function parseOutputMessage() {
		g_end_point = current.source; // default to current.source, but could override below
		g_method = current.name;
		
		var xmlPayload = new GlideXMLDocument();
		xmlPayload.parse(current.payload);
		
		var messageParamsNode = xmlPayload.selectSingleNode('//parameter[@name=\'message_parameters\']/@value');
		if(JSUtil.notNil(messageParamsNode))
			extractParams(messageParamsNode.nodeValue);
		
		var messageHeadersNode = xmlPayload.selectSingleNode('//parameter[@name=\'message_headers\']/@value');
		if(JSUtil.notNil(messageHeadersNode))
			extractHeaders(messageHeadersNode.nodeValue);
		
		var attachDestMetadataNode = xmlPayload.selectSingleNode('//parameter[@name=\'message_attachment_dest\']/@value');
		if(JSUtil.notNil(attachDestMetadataNode))
			extractAttachmentDestMetadata(attachDestMetadataNode.nodeValue);
		
		var contentNode = xmlPayload.selectSingleNode('//parameter[@name=\'content\']/@value');
		if(JSUtil.notNil(contentNode))
			g_content = contentNode.nodeValue;
		
		var contentAttachSrcIdNode = xmlPayload.selectSingleNode('//parameter[@name=\'content_attachment_source_id\']/@value');
		if(JSUtil.notNil(contentAttachSrcIdNode))
			g_content_attachment_source_id = contentAttachSrcIdNode.nodeValue;
		
		var sourceNode = xmlPayload.selectSingleNode('//parameter[@name=\'source\']/@value');
		if(JSUtil.notNil(sourceNode))
			g_end_point = sourceNode.nodeValue;
		
		var restUserNode = xmlPayload.selectSingleNode('//parameter[@name=\'rest_user\']/@value');
		if(JSUtil.notNil(restUserNode))
			g_uname =  restUserNode.nodeValue;
		
		var restPasswordNode = xmlPayload.selectSingleNode('//parameter[@name=\'rest_password\']/@value');
		if(JSUtil.notNil(restPasswordNode))
			g_password = restPasswordNode.nodeValue;
		
	var authorizationNode = xmlPayload.selectSingleNode('//parameter[@name=\'Authorization\']/@value');
	if(JSUtil.notNil(authorizationNode))
		g_authorization =  authorizationNode.nodeValue;	
		
		var logLevelNode = xmlPayload.selectSingleNode('//parameter[@name=\'log_level\']/@value');
		if(JSUtil.notNil(logLevelNode))
			g_log_level = logLevelNode.nodeValue;

		var logLevelSourceTable = xmlPayload.selectSingleNode('//parameter[@name=\'source_table\']/@value');
		if(JSUtil.notNil(logLevelSourceTable))
			g_log_source_table = logLevelSourceTable.nodeValue;

		var logLevelSourceRecord = xmlPayload.selectSingleNode('//parameter[@name=\'source_record\']/@value');
		if(JSUtil.notNil(logLevelSourceRecord))
			g_log_source_record = logLevelSourceRecord.nodeValue;
		
		var httpTimeout = xmlPayload.selectSingleNode('//parameter[@name=\'http_timeout\']/@value');
		if(JSUtil.notNil(httpTimeout))
			g_http_timeout = httpTimeout.nodeValue;
		
		var followRedirect = xmlPayload.selectSingleNode('//parameter[@name=\'follow_redirect\']/@value');
		if(JSUtil.notNil(followRedirect))
			g_follow_redirect = "false" != followRedirect.nodeValue.toLowerCase();

		var artifactScopeId = xmlPayload.selectSingleNode('//parameter[@name=\'artifact_scope_id\']/@value');
		if(JSUtil.notNil(artifactScopeId))
			g_artifact_scope_id = artifactScopeId.nodeValue;

		var callerScope = xmlPayload.selectSingleNode('//parameter[@name=\'caller_scope\']/@value');
		if(JSUtil.notNil(callerScope))
			g_caller_scope = callerScope.nodeValue;

		var artifact = xmlPayload.selectSingleNode('//parameter[@name=\'artifact\']/@value');
		if(JSUtil.notNil(artifact))
			g_artifact = artifact.nodeValue;

		var artifactType = xmlPayload.selectSingleNode('//parameter[@name=\'artifact_type\']/@value');
		if(JSUtil.notNil(artifactType))
			g_artifact_type = artifactType.nodeValue;

		var callingSource = xmlPayload.selectSingleNode('//parameter[@name=\'calling_source\']/@value');
		if(JSUtil.notNil(callingSource))
			g_calling_source = callingSource.nodeValue;

		var originatingScope = xmlPayload.selectSingleNode('//parameter[@name=\'originating_scope\']/@value');
		if(JSUtil.notNil(originatingScope))
			g_originating_scope = originatingScope.nodeValue;
	}
	
	function prepareHTTPReq() {
		g_req = new sn_ws.RESTMessageV2();
		g_req.setEndpoint(g_end_point);
		
		if(JSUtil.notNil(g_log_level))
		     g_req.setLogLevel(g_log_level);
	
	if(JSUtil.notNil(g_authorization))
		g_req.addHeader('Authorization', g_authorization);
	else if(JSUtil.notNil(g_uname) &amp;&amp; JSUtil.notNil(g_password))
			g_req.setBasicAuth(g_uname,g_password);
		
		for(var hdrkey in g_message_headers) {
			g_req.setRequestHeader(hdrkey, g_message_headers[hdrkey]);
		}
		
		for(var prmkey in g_message_params) {
			var queryValue =  g_message_params[prmkey]; //make js string
			var decodedQueryValue = new Packages.java.net.URLDecoder.decode(queryValue); // since these are encoded by RESTMessageClient before creating ecc record
			g_req.setQueryParameter(prmkey, decodedQueryValue);
		}
		
		g_req.setHttpMethod(g_method);
		if(g_method == 'post' || g_method == 'put' || g_method == 'patch') {
			if(JSUtil.notNil(g_content))
				g_req.setRequestBody(g_content);
			else
				g_req.setRequestBodyFromAttachment(g_content_attachment_source_id);
		}
		
		if (JSUtil.notNil(g_attachment_dest_metadata.table_name)) {
			g_req.saveResponseBodyAsAttachment(g_attachment_dest_metadata.table_name,
			g_attachment_dest_metadata.record_sysid,
			g_attachment_dest_metadata.file_name,
			g_attachment_dest_metadata.encrypt_context_sysid);
		}

		var gt = GlideTransaction.get();
		if (JSUtil.notNil(gt)) {
			// add these so logging code can use them
			gt.setAttribute('http_log_source_table', g_log_source_table);
			gt.setAttribute('http_log_source_record', g_log_source_record);
			// Integration Hub usage metadata
			if (JSUtil.notNil(g_artifact_scope_id)) {
				gt.setAttribute('artifact_scope_id', g_artifact_scope_id);
			}
			if (JSUtil.notNil(g_caller_scope)) {
				gt.setAttribute('caller_scope', g_caller_scope);
			}
			if (JSUtil.notNil(g_artifact)) {
				gt.setAttribute('artifact', g_artifact);
			}
			if (JSUtil.notNil(g_artifact_type)) {
				gt.setAttribute('artifact_type', g_artifact_type);
			}
			if (JSUtil.notNil(g_calling_source)) {
				gt.setAttribute('calling_source', g_calling_source);
			}
			if (JSUtil.notNil(g_originating_scope)) {
				gt.setAttribute('originating_scope', g_originating_scope);
			}
		}

		// Http Timeout
		if (JSUtil.notNil(g_http_timeout)) {
			g_req.setHttpTimeout(g_http_timeout);
		}
		// follow redirects
		if (JSUtil.notNil(g_follow_redirect)) {
			g_req.setFollowRedirect(g_follow_redirect);
		}
		
	}
	
	function getECCRecord(){
		var inputGr = new GlideRecord("ecc_queue");
		inputGr.initialize();
		inputGr.topic = current.topic;
		inputGr.name = current.name;
		inputGr.source = current.source;
		inputGr.queue = "input";
		inputGr.agent = "RESTClient";
		inputGr.response_to = current.sys_id;
		return inputGr;
	}
	
	function processResponse() {
		var c = new HttpResponseEccPayloadConverter();
		
		// if we saved the response to an attachment, then save the response attachment sysid
		if (JSUtil.notNil(g_attachment_dest_metadata.table_name))
			c.setResponseAttachmentSysid(g_resp.getResponseAttachmentSysid());
		else
			c.setBody(g_resp.getBody());
		
		c.setStatus(g_resp.getStatusCode());
		c.setHttpHeaders(g_resp.getHeaders());
		
		if(JSUtil.notNil(g_resp.getErrorMessage())) {
			c.setErrorMsg(g_resp.getErrorMessage());
		}

		insertInputMessage(c);
	}
	
	function processException(exceptionMsg){
		var c = new HttpResponseEccPayloadConverter();
		c.setStatus(500);
		if(JSUtil.notNil(exceptionMsg)) {
			c.setErrorMsg(exceptionMsg);
		}
		insertInputMessage(c);
	}
	
	function insertInputMessage(eccPayloadConverter){
		var inputGr = getECCRecord();
		
		inputGr.payload = eccPayloadConverter.getPayload();
		var statusCode = eccPayloadConverter.params.http_status_code;
		if(statusCode &gt;= 400) {
			inputGr.state = "error";
		} else {
			inputGr.state = "ready";
		}
		
		inputGr.insert();
	}
	
	function extractParams(messageParams){
		var fieldsDoc = new GlideXMLDocument();
		fieldsDoc.parse(messageParams);
		var fieldNodes =  fieldsDoc.selectNodes('//field');
		
		g_message_params = {};
		for(var idx = 0;idx&lt;fieldNodes.length;idx++) {
			var fieldNode = fieldNodes.item(idx);
			g_message_params[fieldNode.getAttribute('name')] = fieldNode.getAttribute('value');
		}
	}
	
	function extractHeaders(messageHeaders){
		var fieldsDoc = new GlideXMLDocument();
		fieldsDoc.parse(messageHeaders);
		var fieldNodes =  fieldsDoc.selectNodes('//field');
		
		g_message_headers = {};
		for(var idx = 0;idx&lt;fieldNodes.length;idx++) {
			var fieldNode = fieldNodes.item(idx);
			g_message_headers[fieldNode.getAttribute('name')] = fieldNode.getAttribute('value');
		}
	}
	
	function extractAttachmentDestMetadata(attachDestMetadata) {
		var fieldsDoc = new GlideXMLDocument();
		fieldsDoc.parse(attachDestMetadata);
		
		var tableNameNode =  fieldsDoc.selectSingleNode("//field[@name='table_name']/@value");
		var recordSysidNode =  fieldsDoc.selectSingleNode("//field[@name='record_sysid']/@value");
		var fileNameNode =  fieldsDoc.selectSingleNode("//field[@name='file_name']/@value");
		var encryptCtxSysidNode =  fieldsDoc.selectSingleNode("//field[@name='encrypt_context_sysid']/@value");
		
		g_attachment_dest_metadata = {
			table_name: tableNameNode.nodeValue,
			record_sysid: recordSysidNode.nodeValue,
			file_name: fileNameNode.nodeValue,
			encrypt_context_sysid: encryptCtxSysidNode.nodeValue
		};
	}
	
}

]]&gt;&lt;/script&gt;
        &lt;sys_class_name&gt;sys_script&lt;/sys_class_name&gt;
        &lt;sys_created_by&gt;admin&lt;/sys_created_by&gt;
        &lt;sys_created_on&gt;2014-08-22 00:11:00&lt;/sys_created_on&gt;
        &lt;sys_domain&gt;global&lt;/sys_domain&gt;
        &lt;sys_domain_path&gt;/&lt;/sys_domain_path&gt;
        &lt;sys_id&gt;366bccb3472221004695d7527c9a717a&lt;/sys_id&gt;
        &lt;sys_mod_count&gt;174&lt;/sys_mod_count&gt;
        &lt;sys_name&gt;RESTClient&lt;/sys_name&gt;
        &lt;sys_overrides/&gt;
        &lt;sys_package display_value="REST API Provider" source="com.glide.rest"&gt;0273f8e03c31311068bcf327dfe37fbd&lt;/sys_package&gt;
        &lt;sys_policy/&gt;
        &lt;sys_scope display_value="Global"&gt;global&lt;/sys_scope&gt;
        &lt;sys_update_name&gt;sys_script_366bccb3472221004695d7527c9a717a&lt;/sys_update_name&gt;
        &lt;sys_updated_by&gt;admin&lt;/sys_updated_by&gt;
        &lt;sys_updated_on&gt;2023-08-24 07:27:50&lt;/sys_updated_on&gt;
        &lt;template/&gt;
        &lt;when&gt;async&lt;/when&gt;
    &lt;/sys_script&gt;
    &lt;sys_translated_text action="delete_multiple" query="documentkey=366bccb3472221004695d7527c9a717a"/&gt;
&lt;/record_update&gt;
</payload>
        <sys_class_name>sys_metadata_link</sys_class_name>
        <sys_created_by>admin</sys_created_by>
        <sys_created_on>2024-09-21 08:00:08</sys_created_on>
        <sys_id>503e605183b01210c6695855eeaad3e4</sys_id>
        <sys_mod_count>0</sys_mod_count>
        <sys_name>RESTClient</sys_name>
        <sys_package display_value="Now Utils" source="x_938076_now_utils">b208a7c083689e50c6695855eeaad3d2</sys_package>
        <sys_policy/>
        <sys_scope display_value="Now Utils">b208a7c083689e50c6695855eeaad3d2</sys_scope>
        <sys_update_name>sys_metadata_link_503e605183b01210c6695855eeaad3e4</sys_update_name>
        <sys_updated_by>admin</sys_updated_by>
        <sys_updated_on>2024-09-21 08:00:08</sys_updated_on>
        <tablename>sys_script</tablename>
    </sys_metadata_link>
</record_update>
