<?xml version="1.0" encoding="UTF-8"?><record_update table="sys_metadata_link">
    <sys_metadata_link action="INSERT_OR_UPDATE">
        <directory>update</directory>
        <documentkey>8efba937a3fdb11018d4189b66fcda15</documentkey>
        <payload>&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;record_update table="sys_script_include"&gt;
    &lt;sys_script_include action="INSERT_OR_UPDATE"&gt;
        &lt;access&gt;package_private&lt;/access&gt;
        &lt;active&gt;true&lt;/active&gt;
        &lt;api_name&gt;sn_udc.DeveloperHistory&lt;/api_name&gt;
        &lt;caller_access/&gt;
        &lt;client_callable&gt;false&lt;/client_callable&gt;
        &lt;description/&gt;
        &lt;name&gt;DeveloperHistory&lt;/name&gt;
        &lt;script&gt;&lt;![CDATA[class DeveloperHistory {
    static type = 'DeveloperHistory';
    static TABLE = 'sn_udc_developer_history';
    static COLUMNS = {
        APP: 'app',
        CONTEXT: 'context',
        TAXONOMY_BUILDER: 'taxonomy_builder',
        FILE_TABLE: 'file_table',
        FILE: 'file',
        LABEL: 'label',
        LAST_ACCESSED: 'last_accessed',
        SYS_ID: 'sys_id',
        URL: 'url',
        USER: 'user',
    };
    static HISTORY_DEFAULT_LIMIT = 20;
    static ENTRY_TYPE = {
        FILE: 'file',
        APP: 'app',
        TOOL: 'tool'
    };

    static #isEntryTypeFile(type) {
        return type === DeveloperHistory.ENTRY_TYPE.FILE;
    }

    static #isEntryTypeApp(type) {
        return type === DeveloperHistory.ENTRY_TYPE.APP;
    }

    static #isEntryTypeTool(type) {
        return type === DeveloperHistory.ENTRY_TYPE.TOOL;
    }

    static #isFileEntryNeeded(types) {
        return types.length === 0 || types.includes(DeveloperHistory.ENTRY_TYPE.FILE);
    }

    static #isAppEntryNeeded(types) {
        return types.length === 0 || types.includes(DeveloperHistory.ENTRY_TYPE.APP);
    }

    static #isToolEntryNeeded(types) {
        return types.length === 0 || types.includes(DeveloperHistory.ENTRY_TYPE.TOOL);
    }

    static #getCommonDetailsFromEntry(gr) {
        return {
            context: gr.getValue(DeveloperHistory.COLUMNS.CONTEXT),
            lastAccessed: {
                value: gr.getValue(DeveloperHistory.COLUMNS.LAST_ACCESSED),
                displayValue: gr.getDisplayValue(DeveloperHistory.COLUMNS.LAST_ACCESSED)
            },
        };
    }

    static #getEntryDetails(gr, types) {
        let entryDetails = null;
        if (gr.getValue(DeveloperHistory.COLUMNS.FILE) &amp;&amp; DeveloperHistory.#isFileEntryNeeded(types)) {
            entryDetails = DeveloperHistory.#getFileEntryDetails(gr);
            if (entryDetails) entryDetails.type = DeveloperHistory.ENTRY_TYPE.FILE;
        } else if (gr.getValue(DeveloperHistory.COLUMNS.APP)) {
            entryDetails = DeveloperHistory.#getAppEntryDetails(gr);
            if (entryDetails) entryDetails.type = DeveloperHistory.ENTRY_TYPE.APP;
        } else if (!gr.getValue(DeveloperHistory.COLUMNS.FILE)) {
            entryDetails = DeveloperHistory.#getToolEntryDetails(gr);
            if (entryDetails) entryDetails.type = DeveloperHistory.ENTRY_TYPE.TOOL;
        }

        return entryDetails;
    }

    static #logErrorMessage(gr, e, fallbackMessge) {
        const errorMessage = `${gr.getValue(DeveloperHistory.COLUMNS.SYS_ID)} - ${e?.message || e?.detail || fallbackMessge}`;
        gs.error(errorMessage);
    }

    static #getFileEntryDetails(gr) {
        try {
            const fileSysId = gr.getValue(DeveloperHistory.COLUMNS.FILE);
            const fileTable = gr.file.sys_class_name.toString();
            const {
                builder = {}, file = {}, icon, url
            } = FileTaxonomy.getFileDetails(fileTable, fileSysId);
            if (file.scope) {
                file.scope.class = gr.file.sys_scope?.sys_class_name || '';
            }

            return {
                url: gr.getValue(DeveloperHistory.COLUMNS.URL) || url,
                icon,
                builder,
                file: {
                    ...file,
                    label: file.label || gr.getValue(DeveloperHistory.COLUMNS.LABEL)
                }
            };
        } catch(e) {
            DeveloperHistory.#logErrorMessage(gr, e, 'File entry details fetch failed');
        }
    }

    static #getAppDetailsFromFile(gr) {
        try {
            const {
                sys_scope
            } = gr.file;
            const appSysId = sys_scope.sys_id.toString();
            const appTable = sys_scope.sys_class_name.toString();
            const {
                icon,
                url
            } = FileTaxonomy.getFileDetails('sys_scope', appSysId);

            if (!sys_scope || appSysId === 'global') return null;

            return {
                url,
                icon: sys_scope.logo ? `/${sys_scope.logo.toString()}.iix` : icon,
                file: {
                    table: appTable,
                    sysId: appSysId,
                    label: sys_scope.getDisplayValue(),
                    name: sys_scope.scope.toString(),
                },
            };
        } catch(e) {
            DeveloperHistory.#logErrorMessage(gr, e, 'App details from file entry failed');
        }
    }

    static #getToolDetailsFromFile(gr) {
        try {
            const builderSysId = gr.getValue(DeveloperHistory.COLUMNS.TAXONOMY_BUILDER);
            const fileSysId = gr.getValue(DeveloperHistory.COLUMNS.FILE);
            const fileTable = gr.file.sys_class_name.toString();
            const taxonomy = new FileTaxonomy(fileTable, fileSysId);
            const builder = new FileTaxonomyBuilder(taxonomy.getFileTaxonomySysId(), null, builderSysId);
            const builderUrl = builder.getHomeUrlForBuilder();
            if (!builderUrl) return null;

            return {
                url: builderUrl,
                icon: builder.getIcon(),
                name: builder.getName(),
                label: builder.getLabel(),
                sysId: builder.getSysId(),
                properties: builder.getBuilderProperties()
            };
        } catch(e) {
            DeveloperHistory.#logErrorMessage(gr, e, 'Tool details from file entry failed');
        }
    }

    static #getAppEntryDetails(gr) {
        try {
            const appSysId = gr.getValue(DeveloperHistory.COLUMNS.APP);
            const {
                app
            } = gr;
            const appTable = app.sys_class_name.toString();

            return {
                url: gr.getValue(DeveloperHistory.COLUMNS.URL),
                icon: app.logo ? `/${app.logo.toString()}.iix` : '',
                file: {
                    table: appTable,
                    sysId: appSysId,
                    label: app.getDisplayValue() || gr.getValue(DeveloperHistory.COLUMNS.LABEL),
                    name: app.scope.toString(),
                }
            };
        } catch(e) {
            DeveloperHistory.#logErrorMessage(gr, e, 'App entry details fetch failed');
        }
    }

    static #getToolEntryDetails(gr) {
        try {
            const builderSysId = gr.getValue(DeveloperHistory.COLUMNS.TAXONOMY_BUILDER);
            const {
                name,
                sysId,
                label,
                icon,
                url,
                properties
            } = FileTaxonomyBuilder.getBuilderDetails(builderSysId);

            return {
                url: gr.getValue(DeveloperHistory.COLUMNS.URL) || url,
                icon,
                name,
                label: label || gr.getValue(DeveloperHistory.COLUMNS.LABEL),
                sysId,
                properties
            };
        } catch(e) {
            DeveloperHistory.#logErrorMessage(gr, e, 'Tool entry details fetch failed');
        }
    }

    static #checkAndDeriveAdditionalEntries(gr, commonDetails, types) {
        const additionalEntries = [];
        // Derive app &amp; tool records from file entry
        if (gr.getValue(DeveloperHistory.COLUMNS.FILE)) {
            /*
             ** App entry from file
             ** As per new requirement no need to derive app entry from file as we are insterting/updating while post call.
             **
             */

            // Tool entry from file
            if (DeveloperHistory.#isToolEntryNeeded(types) &amp;&amp; DeveloperHistory.#getToolDetailsFromFile(gr)) {
                additionalEntries.push({
                    ...commonDetails,
                    ...DeveloperHistory.#getToolDetailsFromFile(gr),
                    type: DeveloperHistory.ENTRY_TYPE.TOOL,
                });
            }
        }

        return additionalEntries;
    }

    static #formatHistoryEntries(grEntries, type = '') {
        const types = type ? type.trim().split(',') : [];
        const entries = [];
        let totalCount = 0;
        grEntries.forEach((gr) =&gt; {
            const commonDetails = DeveloperHistory.#getCommonDetailsFromEntry(gr);
            const entryDetails = DeveloperHistory.#getEntryDetails(gr, types);

            if (entryDetails) {
                entries.push({
                    ...commonDetails,
                    ...entryDetails
                });
                totalCount += 1;
            }

            const additionalEntries = DeveloperHistory.#checkAndDeriveAdditionalEntries(
                gr,
                commonDetails,
                types
            );
            totalCount += additionalEntries.length;
            entries.push(...additionalEntries);
        });

        const uniqueValues = [];
        const uniqueEntries = entries.filter(entry =&gt; {
            if ((DeveloperHistory.#isEntryTypeFile(entry.type) || DeveloperHistory.#isEntryTypeApp(entry.type)) &amp;&amp; !uniqueValues.includes(entry.file.sysId)) {
                uniqueValues.push(entry.file.sysId);
                return true;
            } else if (DeveloperHistory.#isEntryTypeTool(entry.type) &amp;&amp; !uniqueValues.includes(entry.url)) {
                uniqueValues.push(entry.url);
                return true;
            }

            totalCount -= 1;
            return false;
        });

        return {
            entries: uniqueEntries,
            totalCount,
        };
    }

    static #generateFilterQuery(options) {
        const gr = new GlideRecord(DeveloperHistory.TABLE);
        gr.addQuery(DeveloperHistory.COLUMNS.USER, gs.getUserID());

        // TODO: Search filter need to be updated if product suggests any other columns
        if (options.searchText)
            gr.addQuery(DeveloperHistory.COLUMNS.LABEL, 'CONTAINS', options.searchText);

        if (options.context) gr.addQuery(DeveloperHistory.COLUMNS.CONTEXT, options.context);

        if (options.type) DeveloperHistory.#checkAndAddTypeQueries(options.type, gr);

        if (gr.isEncodedQueryValid(options.encodedQuery))
            gr.addEncodedQuery(options.encodedQuery);

        return gr.getEncodedQuery();
    }

    static #sortHistoryEntries(grEntries) {
        grEntries.sort((a, b) =&gt; {
            const aLastAccessed = new GlideDateTime(a[DeveloperHistory.COLUMNS.LAST_ACCESSED]);
            const bLastAccessed = new GlideDateTime(b[DeveloperHistory.COLUMNS.LAST_ACCESSED]);
            if (aLastAccessed.getNumericValue() &gt; bLastAccessed.getNumericValue())
                return -1;
            else if (aLastAccessed.getNumericValue() &lt; bLastAccessed.getNumericValue())
                return 1;

            return 0;
        });

        return [...grEntries]; // Destructuring to avoid any reference issues
    }

    static getHistoryEntries(options) {
        const encodedQuery = DeveloperHistory.#generateFilterQuery(options);
        const ga = new GlideAggregate(DeveloperHistory.TABLE);
        ga.addEncodedQuery(encodedQuery);
        ga.groupBy(DeveloperHistory.COLUMNS.URL);
        ga.query();

        const grEntries = [];
        while (ga.next()) {
            const gr = new GlideRecord(DeveloperHistory.TABLE);
            gr.addEncodedQuery(encodedQuery);
            gr.addQuery(DeveloperHistory.COLUMNS.URL, ga.getValue(DeveloperHistory.COLUMNS.URL));
            gr.orderByDesc(DeveloperHistory.COLUMNS.LAST_ACCESSED); // Sorting by last accessed
            gr.query();

            if (gr.next()) grEntries.push(gr);
        }

        const sortedEntries = DeveloperHistory.#sortHistoryEntries(grEntries, options);

        const {
            entries,
            totalCount
        } = DeveloperHistory.#formatHistoryEntries(
            sortedEntries,
            options.type
        );

        if (options.limit) {
            const limit = DeveloperHistory.#validateLimitParam(options.limit);
            const offset = DeveloperHistory.#validateOffsetParam(options.offset);
            return {
                entries: entries.slice(offset, offset + limit),
                totalCount
            }
        }

        return {
            entries,
            totalCount,
        };
    }

    static #validateLimitParam(limit) {
        return DeveloperHistory.isValidNumber(limit) ?
            parseInt(limit, 10) :
            DeveloperHistory.HISTORY_DEFAULT_LIMIT;
    }

    static #validateOffsetParam(offset) {
        return DeveloperHistory.isValidNumber(offset) ? parseInt(offset, 10) : 0;
    }

    static #checkAndAddTypeQueries(type = '', gr) {
        const types = type ? type.trim().split(',') : [];
        let encodedQueryForType = '';
        for (const type of types) {
            switch (type) {
                case DeveloperHistory.ENTRY_TYPE.APP: {
                    encodedQueryForType += encodedQueryForType.length ? '^NQ' : '';
                    encodedQueryForType += `${DeveloperHistory.COLUMNS.APP}ISNOTEMPTY`;
                    break;
                }
                case DeveloperHistory.ENTRY_TYPE.TOOL: {
                    encodedQueryForType += encodedQueryForType.length ? '^NQ' : '';
                    encodedQueryForType += `${DeveloperHistory.COLUMNS.APP}ISEMPTY`;
                    break;
                }
                default: {
                    encodedQueryForType += encodedQueryForType.length ? '^NQ' : '';
                    encodedQueryForType += `${DeveloperHistory.COLUMNS.FILE}!=`;
                    break;
                }
            }
        }

        if (gr.isEncodedQueryValid(encodedQueryForType))
            gr.addEncodedQuery(encodedQueryForType);
    }

    static isValidNumber(value) {
        const parsedVal = parseInt(value, 10);
        if (isNaN(value) || isNaN(parsedVal)) return false;

        if (parsedVal &lt; 0) return false;

        return true;
    }

    static #isHistoryEntryValid(entry) {
        const {
            builderSysId,
            label,
            sysId,
            type,
            url
        } = entry;

        // Ensure file/app should contain sysId
        if ([DeveloperHistory.ENTRY_TYPE.FILE, DeveloperHistory.ENTRY_TYPE.APP].includes(type) &amp;&amp; !sysId) return false;

        // Ensure tool contain builderSysId
        if (DeveloperHistory.#isEntryTypeTool(type) &amp;&amp; !builderSysId) return false;

        // url &amp; label should be there irrespective of history type
        if (!url || !label) return false;

        return true;
    }

    static validatePayload(options) {
        if (!options || !options.payload) throw new Error('Invalid payload data.');

        const {
            context,
            entries
        } = options.payload;

        if (!context) throw new Error('Context not valid.');

        const validEntries = [];
        for (const entry of entries) {
            let valid = true;
            if (!entry || !entry.type || !DeveloperHistory.#isHistoryEntryValid(entry)) valid = false;

            if (valid) validEntries.push(entry);
        }

        if (!validEntries.length) throw new Error('Invalid history entry data.');

        return validEntries;
    }

    static addHistoryEntries(options) {
        const {
            context,
            entries = [],
            validEntries = []
        } = options.payload;

        const entriesToBeCreated = DeveloperHistory.#checkAndUpdateDuplicates(
            context,
            validEntries
        );
        if (entriesToBeCreated) {
            for (const entry of entriesToBeCreated) {
                let createEntry = true;
                if (DeveloperHistory.#isEntryTypeApp(entry.type) &amp;&amp; entry.sysId !== 'global') {
                    const gr = new GlideRecord(DeveloperHistory.TABLE);
                    gr.addQuery(DeveloperHistory.COLUMNS.USER, gs.getUserID());
                    gr.addQuery(DeveloperHistory.COLUMNS.APP, entry.sysId);
                    gr.addQuery(DeveloperHistory.COLUMNS.CONTEXT, context);
                    gr.query();
                    if (gr.next()) {
                        createEntry = false;
                        DeveloperHistory.#updateHistoryEntry({
                            sysId: gr.getUniqueValue(),
                            label: entry.label,
                            url: entry.url,
                            lastAccessed: {
                                value: new GlideDateTime()
                            },
                        });
                    }
                } else if (entry.sysId === 'global') {
                    createEntry = false;
                }

                if (createEntry) DeveloperHistory.#createHistoryEntry(context, entry);
            }
        }

        if (validEntries.length !== entries.length) {
            return {
                message: `${validEntries.length} out of ${entries.length} history entries added/updated.`,
            };
        }
    }

    static #getThresholdTimePropVal() {
        const thresholdTimePropVal = gs.getProperty('sn_udc.history_threshold_time') || '';
        if (DeveloperHistory.isValidNumber(thresholdTimePropVal))
            return `00:${parseInt(thresholdTimePropVal, 10)}:00`;

        return '00:15:00';
    }

    static #checkAndUpdateDuplicates(context, entries) {
        const thresholdTime = new GlideTime();
        thresholdTime.setValue(DeveloperHistory.#getThresholdTimePropVal());
        const currentDateTime = new GlideDateTime();
        currentDateTime.subtract(thresholdTime);

        const entriesToBeCreated = [];
        const recentEntries = DeveloperHistory.#getRecentHistoryEntries(
            context,
            currentDateTime.getValue()
        );

        for (const entry of entries) {
            let updated = false;
            for (const recent of recentEntries) {
                const lastAccessed = new GlideDateTime(recent.lastAccessed.value);
                if (lastAccessed.getNumericValue() &gt; currentDateTime.getNumericValue() &amp;&amp; DeveloperHistory.#shouldUpdateRecord(entry, recent)) {
                    recent.lastAccessed.value = new GlideDateTime();
                    recent.label = entry.label;
                    recent.url = entry.url;
                    updated = DeveloperHistory.#updateHistoryEntry(recent);

                    if (DeveloperHistory.#isEntryTypeFile(entry.type)) DeveloperHistory.#upsertAppHistoryEntryFromFile(context, entry, recent.sysId);
                }
            }

            if (!updated) entriesToBeCreated.push(entry);
        }

        return entriesToBeCreated;
    }

    static #shouldUpdateRecord(entry, recent) {
        // Comparing url values for tool entries and sysId values for other entries whether to update existing record or not
        return (
            ([DeveloperHistory.ENTRY_TYPE.FILE, DeveloperHistory.ENTRY_TYPE.APP].includes(entry.type) &amp;&amp; entry.sysId === recent.file.sysId) ||
            (DeveloperHistory.#isEntryTypeTool(entry.type) &amp;&amp; entry.url === recent.url)
        );
    }

    static #getRecentHistoryEntries(context, offsetTime) {
        const gr = new GlideRecord(DeveloperHistory.TABLE);
        gr.addQuery(DeveloperHistory.COLUMNS.USER, gs.getUserID());
        gr.addQuery(DeveloperHistory.COLUMNS.CONTEXT, context);
        gr.addEncodedQuery(`${DeveloperHistory.COLUMNS.LAST_ACCESSED}&gt;${offsetTime}`);
        gr.query();
        const recentEntries = [];
        while (gr.next()) {
            recentEntries.push({
                file: {
                    sysId: gr.getValue(DeveloperHistory.COLUMNS.FILE) || gr.getValue(DeveloperHistory.COLUMNS.APP),
                },
                label: gr.getValue(DeveloperHistory.COLUMNS.LABEL),
                lastAccessed: {
                    value: gr.getValue(DeveloperHistory.COLUMNS.LAST_ACCESSED)
                },
                sysId: gr.getValue(DeveloperHistory.COLUMNS.SYS_ID),
                url: gr.getValue(DeveloperHistory.COLUMNS.URL),
            });
        }

        return recentEntries;
    }

    static #getTableName(type) {
        if (DeveloperHistory.#isEntryTypeFile(type)) return 'sys_metadata';
        if (DeveloperHistory.#isEntryTypeApp(type)) return 'sys_scope';
        return '';
    }

    static #createHistoryEntry(context, entry) {
        const gr = new GlideRecord(DeveloperHistory.TABLE);
        gr.initialize();
        gr.setValue(DeveloperHistory.COLUMNS.LABEL, entry.label);
        gr.setValue(DeveloperHistory.COLUMNS.URL, entry.url);
        gr.setValue(DeveloperHistory.COLUMNS.CONTEXT, context);
        gr.setValue(DeveloperHistory.COLUMNS.FILE_TABLE, DeveloperHistory.#getTableName(entry.type));

        if (DeveloperHistory.#isEntryTypeFile(entry.type)) gr.setValue(DeveloperHistory.COLUMNS.FILE, entry.sysId);
        if (DeveloperHistory.#isEntryTypeApp(entry.type)) gr.setValue(DeveloperHistory.COLUMNS.APP, entry.sysId);

        gr.setValue(DeveloperHistory.COLUMNS.USER, gs.getUserID());
        gr.setValue(DeveloperHistory.COLUMNS.LAST_ACCESSED, new GlideDateTime());
        gr.setValue(DeveloperHistory.COLUMNS.TAXONOMY_BUILDER, entry.builderSysId || '');
        const entrySysId = gr.insert();

        // Upsert app entry for file entry
        if (!DeveloperHistory.#isEntryTypeFile(entry.type))
            return true;

        return DeveloperHistory.#upsertAppHistoryEntryFromFile(context, entry, entrySysId);
    }

    static #updateHistoryEntry(recent) {
        const gr = new GlideRecord(DeveloperHistory.TABLE);
        const record = gr.get(DeveloperHistory.COLUMNS.SYS_ID, recent.sysId);
        if (record) {
            gr.setValue(DeveloperHistory.COLUMNS.LAST_ACCESSED, recent.lastAccessed.value);
            gr.setValue(DeveloperHistory.COLUMNS.URL, recent.url);
            gr.setValue(DeveloperHistory.COLUMNS.LABEL, recent.label || '');
            gr.update();
            return true;
        }

        return false;
    }

    static #upsertAppHistoryEntryFromFile(context, entry, entrySysId) {
        const historyGr = new GlideRecord(DeveloperHistory.TABLE);
        historyGr.get(entrySysId);
        if (historyGr) {
            const appDetails = DeveloperHistory.#getAppDetailsFromFile(historyGr);
            if (appDetails) {
                const appGr = new GlideRecord(DeveloperHistory.TABLE);
                appGr.addQuery(DeveloperHistory.COLUMNS.USER, gs.getUserID());
                appGr.addQuery(DeveloperHistory.COLUMNS.APP, appDetails.file.sysId);
                appGr.query();
                if (appGr.isValidRecord()) {
                    return DeveloperHistory.#updateHistoryEntry({
                        sysId: appGr.getUniqueValue(),
                        label: appDetails.file.label,
                        url: appDetails.url,
                        lastAccessed: {
                            value: new GlideDateTime()
                        },
                    });
                }

                return DeveloperHistory.#createHistoryEntry(context, {
                    sysId: appDetails.file.sysId,
                    type: DeveloperHistory.ENTRY_TYPE.APP,
                    url: appDetails.url,
                    label: appDetails.file.label,
                });
            }
        }
        return true;
    }
}]]&gt;&lt;/script&gt;
        &lt;sys_class_name&gt;sys_script_include&lt;/sys_class_name&gt;
        &lt;sys_created_by&gt;admin&lt;/sys_created_by&gt;
        &lt;sys_created_on&gt;2023-10-17 07:36:01&lt;/sys_created_on&gt;
        &lt;sys_id&gt;8efba937a3fdb11018d4189b66fcda15&lt;/sys_id&gt;
        &lt;sys_mod_count&gt;57&lt;/sys_mod_count&gt;
        &lt;sys_name&gt;DeveloperHistory&lt;/sys_name&gt;
        &lt;sys_package display_value="Unified Developer Core" source="sn_udc"&gt;8a841f2bc42f457e8809ea71d35e821f&lt;/sys_package&gt;
        &lt;sys_policy&gt;read&lt;/sys_policy&gt;
        &lt;sys_scope display_value="Unified Developer Core"&gt;8a841f2bc42f457e8809ea71d35e821f&lt;/sys_scope&gt;
        &lt;sys_update_name&gt;sys_script_include_8efba937a3fdb11018d4189b66fcda15&lt;/sys_update_name&gt;
        &lt;sys_updated_by&gt;admin&lt;/sys_updated_by&gt;
        &lt;sys_updated_on&gt;2024-03-07 11:48:27&lt;/sys_updated_on&gt;
    &lt;/sys_script_include&gt;
&lt;/record_update&gt;
</payload>
        <sys_class_name>sys_metadata_link</sys_class_name>
        <sys_created_by>admin</sys_created_by>
        <sys_created_on>2024-09-21 08:45:23</sys_created_on>
        <sys_id>cb88345183341210c6695855eeaad327</sys_id>
        <sys_mod_count>0</sys_mod_count>
        <sys_name>DeveloperHistory</sys_name>
        <sys_package display_value="Now Utils" source="x_938076_now_utils">b208a7c083689e50c6695855eeaad3d2</sys_package>
        <sys_policy/>
        <sys_scope display_value="Now Utils">b208a7c083689e50c6695855eeaad3d2</sys_scope>
        <sys_update_name>sys_metadata_link_cb88345183341210c6695855eeaad327</sys_update_name>
        <sys_updated_by>admin</sys_updated_by>
        <sys_updated_on>2024-09-21 08:45:23</sys_updated_on>
        <tablename>sys_script_include</tablename>
    </sys_metadata_link>
</record_update>
