<?xml version="1.0" encoding="UTF-8"?><record_update table="sys_metadata_link">
    <sys_metadata_link action="INSERT_OR_UPDATE">
        <directory>update</directory>
        <documentkey>61ed64f5c3322010ea04a5a1d840dd1c</documentkey>
        <payload>&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;record_update table="sys_script_include"&gt;
    &lt;sys_script_include action="INSERT_OR_UPDATE"&gt;
        &lt;access&gt;package_private&lt;/access&gt;
        &lt;active&gt;true&lt;/active&gt;
        &lt;api_name&gt;sn_app_shell_aw.BreadcrumbItemsProvider&lt;/api_name&gt;
        &lt;caller_access/&gt;
        &lt;client_callable&gt;false&lt;/client_callable&gt;
        &lt;description&gt;Entry point for app shell breadcubs data broker and provides the items for breadcrumbs&lt;/description&gt;
        &lt;name&gt;BreadcrumbItemsProvider&lt;/name&gt;
        &lt;script&gt;&lt;![CDATA[// This is standard SI
var BreadcrumbItemsProvider = Class.create();
BreadcrumbItemsProvider.prototype = {
	OPERATION: {
		APPEND: "APPEND",
		REPLACE: "REPLACE",
		REPLACE_LAST_ITEM: "REPLACE_LAST_ITEM"
	},
	initialize: function () {
	},
	/**
	 * @param {string} route
	 */
	getPayloadTemplate: function (route) {
		return {
			label: route || gs.getMessage("Unknown"),
			icon: "",
			operation: this.OPERATION.REPLACE_LAST_ITEM,
			routeInfo: {
				route: "",
				fields: {},
				params: {}
			},
			operation: this.OPERATION.REPLACE_LAST_ITEM
		};
	},
	/**
	 * @param {string} tableName
	 * @param {string} sysId
	 * @param {string} route
	 */
	getRecordPayload: function (tableName, sysId, route) {
		var payload = this.getPayloadTemplate(route);
		if (!gs.tableExists(tableName))
			return payload;
		var gr = new GlideRecord(tableName);
		if (!gr.isValid())
			return payload;
		if (sysId === "-1")
			payload.label = gs.getMessage("{0} (New Record)", gr.getClassDisplayValue());
		else if(gr.get(sysId))
			payload.label = gr.getDisplayValue();
		return payload;
	},
	/**
	 * @param {{appId: string,
	 * route: string,
	 * fields: Record&lt;string, any&gt;,
	 * params: Record&lt;string, any&gt;,
	 * fetchStaticRoutes: boolean,
	 * selectedToolbarItem: { availability: any, badge: any, group?: string,
	 * 	icon?: string, id: string,
	 * 	label: string | { message: string, translatable: boolean},
	 * 	order?: number, presence?: any,
	 * 	routeInfo: {route: string, fields: Record&lt;string, any&gt;, params?: Record&lt;string, any&gt;}}
	 * prevBreadcrumbRoute: { route: string, fields?: Record&lt;string, any&gt;, params?: Record&lt;string, any&gt;},
	 * prevSelectedContent: { route: string, fields?: Record&lt;string, any&gt;, params?: Record&lt;string, any&gt;}
	 * }} context
	 */
	provideItems: function (context) {
		var output = {
			defaultHandler: true,
			operation: this.OPERATION.REPLACE_LAST_ITEM,
			items: [],
			routeInfo: {
				route: context.route,
				fields: context.fields,
				params: context.params
			},
			prevBreadcrumbRoute: context.prevBreadcrumbRoute,
			prevSelectedContent: context.prevSelectedContent
		};
		switch (context.route) {
			case 'record':
				var payload = this.getRecordPayload(context.fields.table, context.fields.sysId, context.route);
				payload.routeInfo.route = context.route;
				payload.routeInfo.fields = context.fields;
				payload.routeInfo.params = context.params;
				payload.operation = this.OPERATION.REPLACE_LAST_ITEM;
				output.items = [payload];
				break;
			default:
				var defaultPayload = this.getPayloadTemplate(context.route);
				defaultPayload.routeInfo = {
					route: context.route,
					fields: context.fields,
					params: context.params
				}
				var toolbarRootInfo = context.selectedToolbarItem.routeInfo;
				if (toolbarRootInfo &amp;&amp; toolbarRootInfo.route === context.route) {
					output.operation = this.OPERATION.REPLACE;
					defaultPayload.operation = this.OPERATION.REPLACE;
					defaultPayload.icon = context.selectedToolbarItem.icon;
					if (context.selectedToolbarItem.label &amp;&amp;
						typeof context.selectedToolbarItem.label.message === 'string' &amp;&amp;
						context.selectedToolbarItem.label.message.length &gt; 0)
						defaultPayload.label = context.selectedToolbarItem.label.message;
					else if (typeof context.selectedToolbarItem.label === 'string' &amp;&amp; context.selectedToolbarItem.label.length &gt; 0)
						defaultPayload.label = context.selectedToolbarItem.label;
				}
				output.items = [defaultPayload];
		}
		return output;
	},

	/**
	 * @param {{appId: string,
	 * route: string,
	 * fields: Record&lt;string, any&gt;,
	 * params: Record&lt;string, any&gt;,
	 * fetchStaticRoutes: boolean,
	 * selectedToolbarItem: { availability: any, badge: any, group?: string,
	 * 	icon?: string, id: string,
	 * 	label: string | { message: string, translatable: boolean},
	 * 	order?: number, presence?: any,
	 * 	routeInfo: {route: string, fields: Record&lt;string, any&gt;, params?: Record&lt;string, any&gt;},
	 * 	preparedByAppShell?: boolean
	 * }
	 * prevBreadcrumbRoute: { route: string, fields?: Record&lt;string, any&gt;, params?: Record&lt;string, any&gt;},
	 * prevSelectedContent: { route: string, fields?: Record&lt;string, any&gt;, params?: Record&lt;string, any&gt;}
	 * }} context
	 */
	process: function (context) {
		/**
		 * @type {Array&lt;{getAppId(): string, getHandledRoutes(): Array&lt;string&gt;, getStaticRoutes(): Array, provideItems(context: )}&gt;}
		 */
		var availableExtPoints = new GlideScriptedExtensionPoint().getExtensions("sn_app_shell_aw.AppShellBreadcrumbItemsProvider");
		var i18nTranslation = {
			toggle: gs.getMessage("Toggle subtoolbar content"),
			expand: gs.getMessage("Expand"),
			collapse: gs.getMessage("Collapse")
		};
		var output = {
			input: context,
			errMsg: [],
			warnMsg: [],
			i18nTranslation: i18nTranslation
		};
		
		var handledExtPoints = availableExtPoints.filter(function (extPoint) {
			if (typeof extPoint.getAppId !== 'function')
				return false;
			try {
				return extPoint.getAppId() === context.appId;
			} catch (e) {
				output.errMsg.push(e + "");
			}
			return false;
		});

		var resultAPIs = context.selectedToolbarItem.preparedByAppShell? handledExtPoints: handledExtPoints.filter(function (item) {
			if (typeof item.getHandledRoutes !== 'function')
				return false;
			/**
			 * @type {Array}
			 *  */
			var handledRoutes = [];
			try {
				handledRoutes = item.getHandledRoutes();
			} catch (e) {
				output.errMsg.push(e + '');
				return false;
			}
			return Array.isArray(handledRoutes) &amp;&amp; handledRoutes.indexOf(context.selectedToolbarItem.id) &gt;= 0;
		});


		if (resultAPIs.length === 0)
			output.errMsg.push(gs.getMessage("Unable to find the appId, please provide one"));

		if (resultAPIs.length &gt; 1)
			output.warnMsg.push(gs.getMessage("Multiple providers found for same appId"));

		var api = resultAPIs.length &gt; 0? resultAPIs[0]: this;
		if (context.fetchStaticRoutes) {
			if (typeof api.getStaticRoutes === 'function') {
				try {
					output.staticRoutes = api.getStaticRoutes(context);
				} catch (e) {
					output.errMsg.push(e + '');
				}

				if (!Array.isArray(output.staticRoutes))
					output.staticRoutes = [];
				var selfRef = this;
				output.staticRoutes.forEach(function (item, index, src) {
					src[index] = selfRef.fixHRef(item);
				});
			}
		}
		var currentRoute = {items: []};
		try {
			if (typeof api.provideItems === 'function')
				currentRoute = api.provideItems(context);
		} catch (e) {
			output.errMsg.push(e + '');
		}
		currentRoute = currentRoute || this.provideItems(context);
		if (!currentRoute)
			return output;
		currentRoute.i18nTranslation = i18nTranslation;
		if (!Array.isArray(currentRoute.items))
			currentRoute.items = [];
		currentRoute = this.fixHRef(currentRoute);
		currentRoute.routeInfo = currentRoute.routeInfo || {
			route: context.route,
			fields: context.fields,
			params: context.params,
		};
		output.currentRoute = currentRoute;
		output.menu = this.getMenuItems(context);

		return output;
	},
	/**
	* @param {{items: Array&lt;{label: string, icon?: string, href?: string, rootInfo: {root: string, fields: any, params: any}}&gt;}} rootItem
	*/
	fixHRef: function (rootItem) {
		if (!Array.isArray(rootItem.items))
			rootItem.items = [];
		var selfRef = this;
		rootItem.items.forEach(function (item) {
			item.href = 'javascript:void(0)';
			if (!item.operation || !(item.operation === selfRef.OPERATION.APPEND || item.operation === selfRef.OPERATION.REPLACE || item.operation === selfRef.OPERATION.REPLACE_LAST_ITEM))
				item.operation = selfRef.OPERATION.REPLACE_LAST_ITEM;
		});
		if (!rootItem.operation || !(rootItem.operation === this.OPERATION.APPEND || rootItem.operation === this.OPERATION.REPLACE || rootItem.operation === this.OPERATION.REPLACE_LAST_ITEM))
			rootItem.operation = this.OPERATION.REPLACE_LAST_ITEM;
		return rootItem;
	},

	/**
	 *
	 * @returns Menu Items
	 */
	provideMenuItems: function () {
		return [
			{
				"value": {
					"label": "Default Link",
					"target": "",
					"type": "route",
					"value": {
						"route": "home",
						"fields": {}
					}
				}
			}
		];
	},

	provideActionButtons: function() {
		return [
			{
				"label": "Default Action button",
				"value": "default-value",
				"size": "sm",
				"variant": "primary"
			}
		];
	},


	/**
	 * For menu items
	 */
	getMenuItems: function (context) {
		var availableExtPoints = new GlideScriptedExtensionPoint().getExtensions("sn_app_shell_aw.AppShellBreadcrumbMenuProvider");
		var result = {
			items: [],
			actionButtons: [],
			errMsg: []
		};

		var validExtensionPoints = availableExtPoints.filter(function (extPoint) {
			if (typeof extPoint.getAppId !== 'function')
				return false;
			try {
				return extPoint.getAppId() === context.appId;
			} catch (e) {
				result.errMsg.push(e + "");
			}
			return false;
		});

		// If not valid extension point found.
		if (validExtensionPoints.length === 0) {
			result.errMsg.push(gs.getMessage("Unable to find the valid extension point, loading default "));
		}

		// If no valid extension, provide will use default implementations.
		var api = validExtensionPoints.length &gt; 0 ? validExtensionPoints[0] : this;


		if (typeof api.provideMenuItems === 'function') {
			try {
				result.items = api.provideMenuItems(context);
			} catch (e) {
				var errorMessage = e + '';
				result.errMsg.push(errorMessage);
			}
		}

		if (typeof api.provideActionButtons === 'function') {
			try {
				result.actionButtons = api.provideActionButtons(context);
			} catch (e) {
				var errorMessage = e + '';
				result.errMsg.push(errorMessage);
			}
		}

		return result;
	},

	type: 'BreadcrumbItemsProvider'
};]]&gt;&lt;/script&gt;
        &lt;sys_class_name&gt;sys_script_include&lt;/sys_class_name&gt;
        &lt;sys_created_by&gt;admin&lt;/sys_created_by&gt;
        &lt;sys_created_on&gt;2021-03-10 10:03:57&lt;/sys_created_on&gt;
        &lt;sys_id&gt;61ed64f5c3322010ea04a5a1d840dd1c&lt;/sys_id&gt;
        &lt;sys_mod_count&gt;122&lt;/sys_mod_count&gt;
        &lt;sys_name&gt;BreadcrumbItemsProvider&lt;/sys_name&gt;
        &lt;sys_package display_value="Workspace App Shell" source="sn_app_shell_aw"&gt;4524dc30c331101080d6d3658940dd22&lt;/sys_package&gt;
        &lt;sys_policy&gt;read&lt;/sys_policy&gt;
        &lt;sys_scope display_value="Workspace App Shell"&gt;4524dc30c331101080d6d3658940dd22&lt;/sys_scope&gt;
        &lt;sys_update_name&gt;sys_script_include_61ed64f5c3322010ea04a5a1d840dd1c&lt;/sys_update_name&gt;
        &lt;sys_updated_by&gt;admin&lt;/sys_updated_by&gt;
        &lt;sys_updated_on&gt;2023-04-27 06:50:22&lt;/sys_updated_on&gt;
    &lt;/sys_script_include&gt;
&lt;/record_update&gt;
</payload>
        <sys_class_name>sys_metadata_link</sys_class_name>
        <sys_created_by>admin</sys_created_by>
        <sys_created_on>2024-09-21 08:37:49</sys_created_on>
        <sys_id>80d6781d83f01210c6695855eeaad309</sys_id>
        <sys_mod_count>0</sys_mod_count>
        <sys_name>BreadcrumbItemsProvider</sys_name>
        <sys_package display_value="Now Utils" source="x_938076_now_utils">b208a7c083689e50c6695855eeaad3d2</sys_package>
        <sys_policy/>
        <sys_scope display_value="Now Utils">b208a7c083689e50c6695855eeaad3d2</sys_scope>
        <sys_update_name>sys_metadata_link_80d6781d83f01210c6695855eeaad309</sys_update_name>
        <sys_updated_by>admin</sys_updated_by>
        <sys_updated_on>2024-09-21 08:37:49</sys_updated_on>
        <tablename>sys_script_include</tablename>
    </sys_metadata_link>
</record_update>
