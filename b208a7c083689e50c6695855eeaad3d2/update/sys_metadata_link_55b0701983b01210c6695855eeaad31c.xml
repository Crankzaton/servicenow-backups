<?xml version="1.0" encoding="UTF-8"?><record_update table="sys_metadata_link">
    <sys_metadata_link action="INSERT_OR_UPDATE">
        <directory>update</directory>
        <documentkey>1a2f73f2eb2011003623666cd206fee2</documentkey>
        <payload>&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;record_update table="sys_script_include"&gt;
    &lt;sys_script_include action="INSERT_OR_UPDATE"&gt;
        &lt;access&gt;package_private&lt;/access&gt;
        &lt;active&gt;true&lt;/active&gt;
        &lt;api_name&gt;global.sc_ic_Base&lt;/api_name&gt;
        &lt;caller_access/&gt;
        &lt;client_callable&gt;false&lt;/client_callable&gt;
        &lt;description&gt;Base class for all Item Designer wrapper classes&lt;/description&gt;
        &lt;name&gt;sc_ic_Base&lt;/name&gt;
        &lt;script&gt;&lt;![CDATA[/**
 * sc_ic_Base
 *
 * Base class used for the creation of components of the Service Catalog Item Creator.
 *
 * This class should never be instanciated directly.  It should only be extedned.
 *
 * @author Chris Henson &lt;chris.henson@service-now.com&gt;
 */
var sc_ic_Base = Class.create();

sc_ic_Base.prototype = {
    initialize: function(_gr,_gs) {
        this._log = (new GSLog(sc_ic.LOG_LEVEL,this.type)).setLog4J();

		// Assume current if not defined.  This can only ever work if you're instantiating objects directly.
		this._gr = (typeof _gr !== "undefined" ? _gr : current);
		 // Assume gs if not defined
		this._gs = (typeof _gs !== "undefined" ? _gs : gs);
		
		// Assume null if global action not defined
		try {
			this._action = (JSUtil.notNil(action) ? action : null);
		} catch(e) {
			this._action = null;
		}
		
        if (this.type == "sc_ic_Base")
            this._log.error("[initialise] You shouldn't be instanciating objects of type sc_ic_Base");
    },

    /**
     * Returns the GlideRecord object this object wraps
     */
    get_gr: function() {
        return this._gr;
    },
	
	/**
	 * Returns the GlideSystem object this was instantiated with
	 */
	get_gs: function() {
		return this._gs;
	},

	// A lot of the following methods could be moved to a mixin script include and simply referenced in this class.
	
	convertToJSONString: function(anObj){
		if (GlideStringUtil.nil(anObj))
			return "{}";
		
		var myJSON = new JSON();
		return myJSON.encode(anObj);
	},

	/**
	 * Turns off engines sys fields and business rules for the GlideRecord
	 */
	_enableQuietUpdate: function() {
		this._gr.setWorkflow(false);
		this._gr.autoSysFields(false);
		this._gr.useEngines(false);
	},

	/**
	 * Turns on engines, sys fields and business rules for the GlideRecord
	 */
	_disableQuietUpdate: function() {
		this._gr.useEngines(true);
		this._gr.autoSysFields(true);
		this._gr.setWorkflow(true);
	},

	/**
	 * Copies all translation data between source and target glide element
	 * Source and target should both be of type GlideElement
	 * This only copies values in the translation tables, not the base value.
	 */
	copyElementTranslations: function(sourceGr, sourceFld, targetFld) {
		var TRANSLATED_FIELD = "translated_field";
		var TRANSLATED_TEXT = "translated_text";
		var TRANSLATED_HTML = "translated_html";
		
		var Translation = function() {
			return {"sys_id" : "",
					"tableName" : "",
					"fieldName" : "",
					"key" : "",
					"translation" : "",
					"language" : ""
			};
		};
		
		var sourceType = sourceGr[sourceFld].getED().getInternalType()+"";
		var targetType = this._gr[targetFld].getED().getInternalType()+"";
		var targetTable = this._gr.getElement(targetFld).getTableName()+"";
		
		if (this._log.atLevel(GSLog.DEBUG))
			this._log.debug("[copyElementTranslations] Source field " + sourceFld + " is: " + sourceType + ", Target field " + targetFld + " is: " + targetType);
		
		var sourceTrans = [];
		var transFld = "";
		var sysTrans = null;
		
		//Query the appropriate table.
		if (sourceType == TRANSLATED_FIELD) {
			transFld = "label";
			sysTrans = new GlideRecord("sys_translated");
			sysTrans.addQuery("name",sourceGr.getTableName());
			sysTrans.addQuery("element",sourceFld);
			sysTrans.addQuery("value", sourceGr.getValue(sourceFld + ''));
			sysTrans.query();
		}
		else if (sourceType == TRANSLATED_TEXT || sourceType == TRANSLATED_HTML) {
			transFld = "value";
			sysTrans = new GlideRecord("sys_translated_text");
			sysTrans.addQuery("tablename",sourceGr.getTableName());
			sysTrans.addQuery("fieldname",sourceFld);
			sysTrans.addQuery("documentkey",sourceGr.getUniqueValue());
			sysTrans.query();
		}
		
		// If there's no translations for this field put in a log entry.
		if (this._log.atLevel(GSLog.DEBUG) &amp;&amp; (sysTrans == null || !sysTrans.hasNext()))
			this._log.debug("[copyElementTranslations] No translations found for " + sourceGr.getTableName() + "." + sourceFld + " &lt;" + sourceGr.getUniqueValue() + "&gt;");
		
		while (sysTrans.next()) {
			var nt = new Translation();
			nt.sys_id = sourceGr.getUniqueValue()+"";
			nt.tableName = sourceGr.getTableName()+"";
			nt.fieldName = sourceFld;
			nt.key = sourceGr.getValue(sourceFld + '');
			nt.translation = sysTrans[transFld]+"";
			nt.language = sysTrans.language+"";				
			sourceTrans.push(nt);
			
			if (this._log.atLevel(GSLog.DEBUG))
				this._log.debug("[copyElementTranslations] Found translation: " + nt.language + ":" + nt.translation + " &lt;" + nt.sys_id + "&gt;");
		}
		
		// Determine target field type
		if (targetType == TRANSLATED_FIELD) {
			sysTrans = new GlideRecord("sys_translated");
			sysTrans.addQuery("name", targetTable);
			sysTrans.addQuery("element",targetFld);
			sysTrans.addQuery("value",this._gr[targetFld]);
			sysTrans.query();
			
			//Update any that already exist and do not delete any orphans if translated field
			while (sysTrans.next()) {
				for (i = 0; i &lt; sourceTrans.length; i++) {
					st = sourceTrans[i];

					if (sysTrans.language+"" == st.language &amp;&amp; sysTrans.label+"" != st.translation) {
						sysTrans.label = st.translation;
						sysTrans.update();

						transItem = st;
						sourceTrans.splice(i,1);

						if (this._log.atLevel(GSLog.DEBUG))
							this._log.debug("[copyElementTranslations] Updated (sys_translated): " + transItem.key + ":" + transItem.language + ":" + transItem.translation + " &lt;" + transItem.sys_id + "&gt;");
						break;
					}
					else if (sysTrans.language+"" == st.language &amp;&amp; sysTrans.label+"" == st.translation) {
						if (this._log.atLevel(GSLog.DEBUG))
							this._log.debug("[copyElementTranslations] " + st.language + " Translation is up to date");

						transItem = st;
						sourceTrans.splice(i,1);
						break;
					}
				}
			}
			
			//At this point we have an object with any new translations in.
			if (this._log.atLevel(GSLog.DEBUG))
				this._log.debug("[copyElementTranslations] " + sourceTrans.length + " translations to insert");
			
			for (i = 0; i &lt; sourceTrans.length; i++) {
				sysTrans = new GlideRecord("sys_translated");
				sysTrans.name = targetTable;
				sysTrans.element = targetFld;
				sysTrans.value = sourceTrans[i].key;
				sysTrans.label = sourceTrans[i].translation;
				sysTrans.language = sourceTrans[i].language;
				
				if (this._log.atLevel(GSLog.DEBUG))
					this._log.debug("[copyElementTranslations] Insert (sys_translated): " + sysTrans.name + ":" + sysTrans.element + ":" + sysTrans.language + ":" + sysTrans.value);
				
				sysTrans.insert();
			}
		}
		else if (targetType == TRANSLATED_HTML || targetType == TRANSLATED_TEXT) {
			sysTrans = new GlideRecord("sys_translated_text");
			sysTrans.addQuery("tablename",this._gr.getTableName());
			sysTrans.addQuery("fieldname",targetFld);
			sysTrans.addQuery("documentkey",this._gr.getUniqueValue());
			sysTrans.query();
			
			//Update any that already exist
			while (sysTrans.next()) {
				var transItem = null;
				for (i = 0; i &lt; sourceTrans.length; i++) {
					var st = sourceTrans[i];
					if (sysTrans.language+"" == st.language &amp;&amp; sysTrans.value+"" != st.translation) {
						sysTrans.value = st.translation;
						sysTrans.update();
						
						if (this._log.atLevel(GSLog.DEBUG))
							this._log.debug("[copyElementTranslations] Update (sys_translated_text): " + transItem.key + ":" + transItem.language + ":" + transItem.translation + " &lt;" + transItem.sys_id + "&gt;");
						
						transItem = st;
						sourceTrans.splice(i,1); //Remove the used element
						break;
					}
					else if (sysTrans.language+"" == st.language &amp;&amp; sysTrans.value+"" == st.translation) {
						if (this._log.atLevel(GSLog.DEBUG))
							this._log.debug("[copyElementTranslations] " + st.language + " Translation is up to date");
						
						transItem = st;
						sourceTrans.splice(i,1);
						break;
					}
				}
				
				if (transItem == null) {
					if (this._log.atLevel(GSLog.DEBUG))
						this._log.debug("[copyElementTranslations] Delete (sys_translated_text): " + sysTrans.tablename + ":" + sysTrans.fieldname + ":" + sysTrans.documentkey + ":" + sysTrans.language + ":" + sysTrans.value);
					sysTrans.deleteRecord();
				}
			}
			
			//Insert any new ones
			if (this._log.atLevel(GSLog.DEBUG))
				this._log.debug("[copyElementTranslations] " + sourceTrans.length + " translations to insert");
			 
			for (var i = 0; i &lt; sourceTrans.length; i++) {
				sysTrans = new GlideRecord("sys_translated_text");
				sysTrans.documentkey = this._gr.getUniqueValue();
				sysTrans.tablename = this._gr.getTableName();
				sysTrans.fieldname = targetFld;
				sysTrans.value = sourceTrans[i].translation;
				sysTrans.language = sourceTrans[i].language;
							
				if (this._log.atLevel(GSLog.DEBUG))
					this._log.debug("[copyElementTranslations] Insert (sys_translated_text): " + sysTrans.tablename + ":" + sysTrans.fieldname + ":" + sysTrans.language + ":" + sysTrans.value + ":" + sysTrans.documentkey);
				
				sysTrans.insert();
			}
		}
	},
	
	redirect: function() {
		if (this._action != null &amp;&amp; !JSUtil.nil(this._action.getActionSysId()))
			this._action.setRedirectURL(this._gr);
	},
	
    type: "sc_ic_Base"
};]]&gt;&lt;/script&gt;
        &lt;sys_class_name&gt;sys_script_include&lt;/sys_class_name&gt;
        &lt;sys_created_by&gt;admin&lt;/sys_created_by&gt;
        &lt;sys_created_on&gt;2013-10-25 09:05:17&lt;/sys_created_on&gt;
        &lt;sys_id&gt;1a2f73f2eb2011003623666cd206fee2&lt;/sys_id&gt;
        &lt;sys_mod_count&gt;38&lt;/sys_mod_count&gt;
        &lt;sys_name&gt;sc_ic_Base&lt;/sys_name&gt;
        &lt;sys_package display_value="Service Catalog Platform" source="com.glideapp.servicecatalog.platform"&gt;3607b4283cb1311068bcf327dfe37fee&lt;/sys_package&gt;
        &lt;sys_policy/&gt;
        &lt;sys_scope display_value="Global"&gt;global&lt;/sys_scope&gt;
        &lt;sys_update_name&gt;sys_script_include_1a2f73f2eb2011003623666cd206fee2&lt;/sys_update_name&gt;
        &lt;sys_updated_by&gt;admin&lt;/sys_updated_by&gt;
        &lt;sys_updated_on&gt;2014-04-24 16:46:13&lt;/sys_updated_on&gt;
    &lt;/sys_script_include&gt;
&lt;/record_update&gt;
</payload>
        <sys_class_name>sys_metadata_link</sys_class_name>
        <sys_created_by>admin</sys_created_by>
        <sys_created_on>2024-09-21 08:11:09</sys_created_on>
        <sys_id>55b0701983b01210c6695855eeaad31c</sys_id>
        <sys_mod_count>0</sys_mod_count>
        <sys_name>sc_ic_Base</sys_name>
        <sys_package display_value="Now Utils" source="x_938076_now_utils">b208a7c083689e50c6695855eeaad3d2</sys_package>
        <sys_policy/>
        <sys_scope display_value="Now Utils">b208a7c083689e50c6695855eeaad3d2</sys_scope>
        <sys_update_name>sys_metadata_link_55b0701983b01210c6695855eeaad31c</sys_update_name>
        <sys_updated_by>admin</sys_updated_by>
        <sys_updated_on>2024-09-21 08:11:09</sys_updated_on>
        <tablename>sys_script_include</tablename>
    </sys_metadata_link>
</record_update>
