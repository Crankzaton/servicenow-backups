<?xml version="1.0" encoding="UTF-8"?><record_update table="sys_metadata_link">
    <sys_metadata_link action="INSERT_OR_UPDATE">
        <directory>update</directory>
        <documentkey>51cf4b06c32001104b8e88c7c840dde0</documentkey>
        <payload>&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;record_update table="sys_script_include"&gt;
    &lt;sys_script_include action="INSERT_OR_UPDATE"&gt;
        &lt;access&gt;public&lt;/access&gt;
        &lt;active&gt;true&lt;/active&gt;
        &lt;api_name&gt;global.ACEAppBuilderGlobalScopedUtil&lt;/api_name&gt;
        &lt;caller_access/&gt;
        &lt;client_callable&gt;false&lt;/client_callable&gt;
        &lt;description/&gt;
        &lt;name&gt;ACEAppBuilderGlobalScopedUtil&lt;/name&gt;
        &lt;script&gt;&lt;![CDATA[var ACEAppBuilderGlobalScopedUtil = Class.create();
ACEAppBuilderGlobalScopedUtil.prototype = {
    initialize: function() {
        this._CB_CACHE_KEY = 'ace_content_block_cache';
        this._CB_CACHE_FIELDS = [
            'title',
            'subtitle',
            'order',
            'post_script',
            'visibility',
            'lazy_load',
            'type',
            'active',
            'name',
            'parent',
            'document_table',
            'document_id',
            'ace_config',
            'sys_domain',
            'sys_id'
        ];
        this.ACE_MACROPONENT_CB_PROPS_KEY = 'ace_macroponent_cb_properties';
        this.COMPRESSEDDATA2 = 'COMPRESSEDDATA2:';
    },
    _getValuePairsFromClonedRecord: function(table, sysId, fields) {
        try {
            if (!table || !sysId) return {};
            var valuePairs = {};
            var gr = new GlideRecordSecure(table);
            if (gr.get(sysId)) {
                fields.forEach(function(field) {
                    valuePairs[field] = gr.getValue(field);
                });
                return valuePairs;
            }
            return {};
        } catch (e) {
            return {};
        }
    },
    _grRecordCreator: function(table, valuePairs, cloneInfo) {
        try {
            var clonedValuePairs = {},
                field;
            if (cloneInfo &amp;&amp; cloneInfo.sys_id &amp;&amp; Array.isArray(cloneInfo.fields) &amp;&amp; cloneInfo.fields.length &gt; 0) {
                clonedValuePairs = this._getValuePairsFromClonedRecord(table, cloneInfo.sys_id, cloneInfo.fields);
            }
            var gr = new GlideRecordSecure(table);
            gr.initialize();
            for (field in clonedValuePairs) {
                gr[field] = clonedValuePairs[field];
            }
            for (field in valuePairs) {
                gr[field] = valuePairs[field];
            }
            if (gr.canWrite()) {
                return gr.insert();
            } else {
                gs.error("Inserting record failed to perform the operation as the user don't have write accesss " + table)
            }
        } catch (e) {
            return null;
        }
    },
    deleteRecord: function(table, sysId) {
        var gr = new GlideRecordSecure(table);
        if (gr.get(sysId)) return gr.deleteRecord();
        return null;
    },
    updateRecord: function(table, sysId, props) {
        var gr = new GlideRecordSecure(table);
        var result = null;
        if (gr.get(sysId)) {
            for (var key in props) {
                gr.setValue(key, props[key]);
            }
            if (gr.canWrite()) {
                result = gr.update();
                if (result) {
                    return result;
                } else {
                    gs.error("Updating record failed to perform the operation");
                }
            } else {
                gs.error("Updating record failed to perform the operation as the user don't have write accesss " + table + " " + sysId);
            }
        }
        return null;
    },

    _parseChoiceList: function(choiceList) {
        //parsing as per UIB List Component contract -&gt; {'id': @String, 'label': @string}
        var choices = choiceList.toArray();
        var result = [];

        if (!choices.length) {
            return [];
        }

        /* 
        If choice list has only one option with an empty value, then we don't need to consider that as a picker.
        This will be the case when we call GlideScriptChoiceList.getChoiceList on any field that has no options
        */
        if (choices.length == 1) {
            var choice = (choices[0] + '').trim();
            var choiceValue = choice.split(':')[1].trim();
            if (!choiceValue) {
                return [];
            }
        }

        choices.forEach(function(choice) {
            choice = (choice + '').trim();
            var splittedChoice = choice.split(':');
            result.push({
                'label': splittedChoice[0].trim(),
                'id': splittedChoice[1].trim() || ''
            });
        });

        return result;
    },
    _hasReadAccessSysProp: function(roles) {
        if (!roles) return true;
        var response = false;
        roles.split(',').forEach(function(role) {
            response = response || gs.hasRole(role);
        });
        return response;
    },
    getPropertiesPayload: function(propertyIds, supportedTypes) {
        var props = [];
        try {
            var gr = new GlideRecordSecure('sys_properties');
            gr.addQuery('sys_id', 'IN', propertyIds);
            gr.query();
            while (gr.next()) {
                if (!this._hasReadAccessSysProp(gr.getValue('read_roles'))) continue;
                var type = gr.getValue('type');
                var choices = gr.getValue('choices');
                if (supportedTypes.indexOf(type) == -1) continue;
                props.push({
                    'name': gr.getValue('name'),
                    'sys_id': gr.getUniqueValue(),
                    'description': gr.getValue('description'),
                    'type': type,
                    'choices': choices ? choices.split(',').map(function(choice) {
                        choice = choice.trim();
                        var parsedChoice = choice.split('=');
                        return parsedChoice.length == 2 ? {
                            'id': parsedChoice[1],
                            'label': parsedChoice[0]
                        } : {
                            'id': parsedChoice[0],
                            'label': parsedChoice[0]
                        };
                    }) : null,
                    'value': gr.getValue('value'),
                    'new_value': '',
                    'table': 'sys_properties',
                    'field_name': 'value'
                });
            }
            return props;
        } catch (e) {
            return props;
        }
    },
    getRecord: function(table, sysId, props /* Array of fields */ ) {
        var result = {};
        var _self = this;
        try {
            var gr = new GlideRecordSecure(table);
            if (gr.get(sysId)) {
                props.forEach(function(prop) {
                    result[prop] = gr[prop].toString(); //Do not use getValue() as it is showing display value in some cases like incident.category
                    result.__choices = _self._parseChoiceList(GlideScriptChoiceList.getChoiceList(table, prop));
                    result.__display_name = gr.getDisplayValue();
                    result.__internal_type = gr.getElement(prop).getED().getInternalType().toString();
                    result.__canWrite = gr.canWrite();
                    result.__isInSelectedScope = gr.isInSelectedScope();
                });
            }
            return result;
        } catch (e) {
            return result;
        }
    },
    _grGetKeyDataFromTable: function(table, sysId, key) {
        var gr = new GlideRecord(table);
        if (gr.get(sysId)) {
            return gr.getValue(key);
        }
        return null;
    },
    _aisPublishProfile: function(profileName) {
        return new sn_ais.Synchronizer().publishProfile(profileName);
    },
    _isAisEnabled: function() { //this function checks whether AIS is enabled or not
        return new sn_ais.StatusApi().isAisEnabled();
    },
    enableAIS: function() { //this function will place a request to enabled AIS if not already placed
        var grS = new GlideAggregate('sys_service');
        if (grS.isValid()) {
            grS.addQuery('name', 'AISearch');
            if (grS.getCount() &gt; 0)
                return true;
            else
                return new sn_ais.InfrastructureApi().requestAis();
        }
        return false;
    },
    AISAlreadyExists: function(appName) { //checks default configuration for a specific experience alreay exists
        var gr = new GlideRecord('ais_search_profile');
        gr.addQuery('label', appName + ' profile');
        gr.query();
        if (gr.next()) {
            return true;
        }
        return false;
    },
    /* --- Content Block Caching Methods START --- */
    _isCacheEnabled: function(experienceId) {
        // Check framework-level cache property
        var aceCacheEnabled = gs.getProperty('sn_ace.content_block.cache.enabled', 'true') === 'true';
        if (!aceCacheEnabled) {
            gs.debug('ACE Framework Cache Disabled');
            return false;
        }
        // Check experience-level cache property
        var cacheDisabledForExperience = gs.getProperty('sn_ace.experience.' + experienceId + '.disable_cache', 'true') === 'true';
        if (cacheDisabledForExperience) {
            gs.debug('ACE Cache Disabled for experience ' + experienceId);
            return false;
        }
        return true;
    },

    getCachedContentTypeMetaData: function(reload) {
        if (reload) {
            GlideCacheManager.flush(this._CB_CACHE_KEY);
        }
        var appConfigMap = GlideCacheManager.get(this._CB_CACHE_KEY, 'ace_content_block_cache');
        if (!appConfigMap) {
            appConfigMap = {};
            var screenTypeIds = [];
            var routeTypes = [];
            var cbTypeIds = [];
            var type2Var = {};
            var aceConfigs = {};
            var screenType2RouteTypeMap = {};
            var aceConfigGR = new GlideRecord('sn_ace_app_config');
            aceConfigGR.query();
            if (aceConfigGR.next()) {
                aceConfigs[aceConfigGR.getUniqueValue()] = {
                    name: aceConfigGR.getValue("name"),
                    uxAppConfig: aceConfigGR.getValue("app_config")
                }
            }

            var cbTypeGr = new GlideRecord('sn_ace_content_block_type');
            cbTypeGr.query();
            while (cbTypeGr.next()) {
                routeTypes.push(cbTypeGr.getValue("route"));
                cbTypeIds.push(cbTypeGr.getUniqueValue());
            }

            var gr_variables = new GlideRecord('sn_ace_variable');
            gr_variables.addQuery('model', 'IN', cbTypeIds);
			gr_variables.orderBy('order');
            gr_variables.query();
            while (gr_variables.next()) {
                var variable = {
                    'element': gr_variables.getValue('element'),
                    'type': gr_variables.getValue('internal_type')
                };

                if (type2Var[gr_variables.getValue("model")]) {
                    //TODO : Use spread op instead of push
                    var types = type2Var[gr_variables.getValue("model")];
                    types.push(variable)
                    type2Var[gr_variables.getValue("model")] = types;
                } else {
                    type2Var[gr_variables.getValue("model")] = [variable];
                }
            }

            var gr_route = new GlideRecord('sys_ux_app_route');
            gr_route.addQuery('route_type', 'IN', routeTypes);
            gr_route.query();
            while (gr_route.next()) {
                screenTypeIds.push(gr_route.getValue("screen_type"));
                screenType2RouteTypeMap[gr_route.getValue("screen_type")] = screenType2RouteTypeMap[gr_route.getValue("screen_type")] || [];
                screenType2RouteTypeMap[gr_route.getValue("screen_type")].push({
                    appConfigId: gr_route.getValue("app_config"),
                    routeId: gr_route.getUniqueValue(),
                    routeType: gr_route.getValue("route_type")
                });
                appConfigMap[gr_route.getValue("app_config")] = appConfigMap[gr_route.getValue("app_config")] || {};
                appConfigMap[gr_route.getValue("app_config")][gr_route.getValue("route_type")] = {
                    routeId: gr_route.getUniqueValue(),
                    screenType: gr_route.getValue("screen_type")
                };
            }
            gs.info(JSON.stringify(screenType2RouteTypeMap));
            var gr_screen = new GlideRecord('sys_ux_screen');
            gr_screen.addQuery('screen_type', 'IN', screenTypeIds);
            gr_screen.query();
            while (gr_screen.next()) {
                appConfigMap[gr_screen.getValue("app_config")] = appConfigMap[gr_screen.getValue("app_config")] || {};
                screenType2RouteTypeMap[gr_screen.getValue("screen_type")].forEach(function(routeTypeItem) {
                    appConfigMap[routeTypeItem["appConfigId"]][routeTypeItem.routeType] = appConfigMap[routeTypeItem["appConfigId"]][routeTypeItem.routeType] || {};
                    appConfigMap[routeTypeItem["appConfigId"]][routeTypeItem.routeType].macroponent = gr_screen.getValue("macroponent") || "";
                });
            }
            appConfigMap['typeVarsMap'] = type2Var;

            try {
                GlideCacheManager.put(
                    this._CB_CACHE_KEY,
                    'ace_content_block_cache',
                    appConfigMap);
            } catch (e) {
                gs.debug('ACE Cache: Unable to add cache item for ' + e.message);
            }
        }
        return appConfigMap;
    },

    /*
     * @param {String} experienceId - sys_id of the ACE experience
     * @param {Object} queryObj - An object to filter the cached items with
     *        Ex: { 'parent_id': '123', 'active': true }
     *
     * returns Array&lt;Object&gt; - a JSON array containing matching content block objects
     */
    getContentBlocksFromCache: function(experienceId, queryObj) {
        if (!experienceId)
            return null;
        if (!this._isCacheEnabled(experienceId))
            return null;
        var cache = GlideCacheManager.get(this._CB_CACHE_KEY, experienceId);
        if (cache) {
            var cachedData = cache.data;
            var fields = Object.keys(queryObj);
            var matchedSet = cachedData.filter(function(item) {
                var match = fields.every(function(k) {
                    return item[k] === queryObj[k];
                });
                return match;
            });
            // return a copy to avoid passing direct references to cached objects
            return JSON.parse(JSON.stringify(matchedSet));
        }
        return cache;
    },
    containsExperienceCache: function(experienceId) {
        return !!(GlideCacheManager.get(this._CB_CACHE_KEY, experienceId));
    },
    buildExperienceCache: function(experienceId) {
        var gr = new GlideRecord('sn_ace_content_block');
        gr.addQuery('ace_config', experienceId);
        gr.orderBy('order');
        gr.query();
        try {
            GlideCacheManager.put(
                this._CB_CACHE_KEY,
                experienceId,
                this._buildCacheItem(this._grToJson(gr))
            );
        } catch (e) {
            gs.debug('ACE Cache: Unable to add cache item for ' + experienceId + ' -- ' + e.message);
        }
    },
    removeExperienceCache: function(experienceId) {
        if (!experienceId)
            return null;
        GlideCacheManager.put(this._CB_CACHE_KEY, experienceId, null);
        gs.debug('ACE Cache: Cleared for experience ' + experienceId);
    },
    /*
     * Iterates the provided GlideRecord object and captures all the rows as JSON objects
     * 
     * IMPORTANT: This brings all the GR result set into the memory, so make sure the matching result set is not too big
     * 
     * @param {GlideRecord} gr - for content block
     */
    _grToJson: function(gr) {
        var json = [];
        while (gr.next()) {
            var cachedCb = this._CB_CACHE_FIELDS.reduce(function(acc, field) {
                acc[field] = gr.getValue(field);
                return acc;
            }, {});
            // cache content block 'variables'
            var cachedVars = {};
            for (var v in gr.variable) {
                if (v.indexOf('sys_') !== 0) cachedVars[v] = gr.variable[v].toString();
            }
            cachedCb.variable = cachedVars;
            json.push(cachedCb);
        }
        return json;
    },
    _buildCacheItem: function(item) {
        return {
            created_on: Date.now(),
            created_by: gs.getUserID(),
            data: item
        };
    },

    getCachedMacroponentCBProperties: function() {
        return this.containsExperienceCache(this.ACE_MACROPONENT_CB_PROPS_KEY) ?
            GlideCacheManager.get(this._CB_CACHE_KEY, this.ACE_MACROPONENT_CB_PROPS_KEY) : '';
    },

    putCachedMacroponentCBProperties: function(metadataProperties) {
        try {
            GlideCacheManager.put(
                this._CB_CACHE_KEY,
                this.ACE_MACROPONENT_CB_PROPS_KEY,
                metadataProperties);
        } catch (e) {
            gs.debug('ACE Metadata Cache: Unable to add cache item for ' + e.message);
        }
    },

    flushCachedMacroponentCBProperties: function() {
        try {
            GlideCacheManager.put(
                this._CB_CACHE_KEY,
                this.ACE_MACROPONENT_CB_PROPS_KEY,
                null);
        } catch (e) {
            gs.debug('ACE Metadata Cache: Unable to add cache item for ' + e.message);
        }
    },

    /**
     * Uses Glide string and compression utils to compress and base 64 encode the content block JSON structure.
     * 
     * @params {Array} composition - A JSON array
     * @returns {String} The bundled form of the content block structure.
     */
    getCompressedPageBundle: function(composition) {
        try {
            if (!gs.nil(composition)) {
                var compressedComposition = GlideCompressionUtil.compress(JSON.stringify(composition));
                var bundle = GlideStringUtil.base64Encode(compressedComposition);
                return this.COMPRESSEDDATA2 + bundle;
            }
        } catch (e) {
            gs.error("ACEAppBuilderGlobalScopedUtil: Unable to compress page bundle: " + e.toString());
        }
        return this.COMPRESSEDDATA2;
    },

    /**
     * Uses Glide string and compression utils to decode and decompress the content block bundle to a JSON array.
     * 
     * @params {String} bundle
     * @returns {Array} The content block structure for an ACE Page.
     */
    getDecompressedPageBundle: function(bundle) {
        try {
            if (!gs.nil(bundle)) {
                var encodedBundle = bundle.substring(this.COMPRESSEDDATA2.length);
                var decodedBundle = GlideStringUtil.base64DecodeAsBytes(encodedBundle);
                var composition = GlideCompressionUtil.expandToString(decodedBundle);
                return JSON.parse(composition);
            }
        } catch (e) {
            gs.error("ACEAppBuilderGlobalScopedUtil: Unable to decompress page bundle: " + e.toString());
        }
        return [];
    },
    /* --- Content Block Caching Methods END --- */

    updatePageMacroponentTransLation: function(pageId, params) {
        var result = {};
        var pageMacroponentId = '';
        var cbGr = new GlideRecord('sn_ace_page');
        cbGr.get(pageId);
        var routeId = cbGr.getValue('route');
        var routeGr = new GlideRecord('sys_ux_app_route');
        routeGr.get(routeId);
        var screenTypeId = routeGr.getValue('screen_type');
        var sysUxScreenGr = new GlideRecord('sys_ux_screen');
        sysUxScreenGr.addQuery('screen_type', screenTypeId);
        sysUxScreenGr.query();
        while (sysUxScreenGr.next()) {
            pageMacroponentId = sysUxScreenGr.getValue('macroponent');
        }
        var macroponnentGR = new GlideRecord('sys_ux_macroponent');
        macroponnentGR.get(pageMacroponentId);

        var existingTranslations = JSON.parse(macroponnentGR.getValue('required_translations'));
        var existingStrings = [];

        var requireUpdate = false;
        if (existingTranslations &amp;&amp; existingTranslations.length &gt; 0) {
            existingTranslations.forEach(function(existingTranslation) {
                existingStrings.push(existingTranslation.message);
            });
        }
        if (params) {
            var translateableStrings = [];
            params.forEach(function(param) {
                if (!requireUpdate) {
                    if (existingStrings.indexOf(param) === -1) {
                        requireUpdate = true;
                    }
                }
                translateableStrings.push({
                    "message": param,
                    "comment": ""
                });
            });
        }
        if (requireUpdate) {
            macroponnentGR.required_translations = JSON.stringify(translateableStrings);
            macroponnentGR.setWorkflow(false);
            macroponnentGR.update();
        }
        result.requireUpdate = requireUpdate;
        result.required_translations = JSON.stringify(translateableStrings);
        return result;

    },

     updateHandeledEventForV2toV3TemplateMigration: function(pageMacroponentId) {
        var gr = new GlideRecord('sys_ux_macroponent');
        gr.get(pageMacroponentId);
        gr.setDisplayValue('handled_events', 'ACE_CONTROLLER_UPDATED');
        gr.setWorkflow(false);
        gr.update();
    },

    type: 'ACEAppBuilderGlobalScopedUtil'
};]]&gt;&lt;/script&gt;
        &lt;sys_class_name&gt;sys_script_include&lt;/sys_class_name&gt;
        &lt;sys_created_by&gt;admin&lt;/sys_created_by&gt;
        &lt;sys_created_on&gt;2021-12-22 12:30:20&lt;/sys_created_on&gt;
        &lt;sys_id&gt;51cf4b06c32001104b8e88c7c840dde0&lt;/sys_id&gt;
        &lt;sys_mod_count&gt;70&lt;/sys_mod_count&gt;
        &lt;sys_name&gt;ACEAppBuilderGlobalScopedUtil&lt;/sys_name&gt;
        &lt;sys_package display_value="Conversational Interfaces Settings" source="com.glide.cs.admin_console"&gt;717df0203c75311068bcf327dfe37fac&lt;/sys_package&gt;
        &lt;sys_policy&gt;protected&lt;/sys_policy&gt;
        &lt;sys_scope display_value="Global"&gt;global&lt;/sys_scope&gt;
        &lt;sys_update_name&gt;sys_script_include_51cf4b06c32001104b8e88c7c840dde0&lt;/sys_update_name&gt;
        &lt;sys_updated_by&gt;admin&lt;/sys_updated_by&gt;
        &lt;sys_updated_on&gt;2023-08-01 04:00:40&lt;/sys_updated_on&gt;
    &lt;/sys_script_include&gt;
&lt;/record_update&gt;
</payload>
        <sys_class_name>sys_metadata_link</sys_class_name>
        <sys_created_by>admin</sys_created_by>
        <sys_created_on>2024-09-21 08:37:04</sys_created_on>
        <sys_id>05a6bcd983f01210c6695855eeaad3db</sys_id>
        <sys_mod_count>0</sys_mod_count>
        <sys_name>ACEAppBuilderGlobalScopedUtil</sys_name>
        <sys_package display_value="Now Utils" source="x_938076_now_utils">b208a7c083689e50c6695855eeaad3d2</sys_package>
        <sys_policy/>
        <sys_scope display_value="Now Utils">b208a7c083689e50c6695855eeaad3d2</sys_scope>
        <sys_update_name>sys_metadata_link_05a6bcd983f01210c6695855eeaad3db</sys_update_name>
        <sys_updated_by>admin</sys_updated_by>
        <sys_updated_on>2024-09-21 08:37:04</sys_updated_on>
        <tablename>sys_script_include</tablename>
    </sys_metadata_link>
</record_update>
