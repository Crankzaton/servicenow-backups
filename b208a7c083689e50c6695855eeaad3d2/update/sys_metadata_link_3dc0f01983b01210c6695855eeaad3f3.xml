<?xml version="1.0" encoding="UTF-8"?><record_update table="sys_metadata_link">
    <sys_metadata_link action="INSERT_OR_UPDATE">
        <directory>update</directory>
        <documentkey>1cc99d9577230010195693df59106117</documentkey>
        <payload>&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;record_update table="sys_script_include"&gt;
    &lt;sys_script_include action="INSERT_OR_UPDATE"&gt;
        &lt;access&gt;package_private&lt;/access&gt;
        &lt;active&gt;true&lt;/active&gt;
        &lt;api_name&gt;sn_doc.DocumentTaskNoteUtilsSNC&lt;/api_name&gt;
        &lt;caller_access/&gt;
        &lt;client_callable&gt;false&lt;/client_callable&gt;
        &lt;description/&gt;
        &lt;name&gt;DocumentTaskNoteUtilsSNC&lt;/name&gt;
        &lt;script&gt;&lt;![CDATA[var DocumentTaskNoteUtilsSNC = Class.create();
DocumentTaskNoteUtilsSNC.prototype = {
    initialize: function() {},

    /**
     * Description: Get all Notes.
     * @param {SysID} docTaskId 
     * @return {Array} notes
     */
    getOpenNotes: function(docTaskId) {
        var docTaskGr = new GlideRecord("sn_doc_task");
        docTaskGr.get(docTaskId);
        var participantSysId = docTaskGr.getValue("participant");

        var notes = this.getSubmittedNotesForReviewer(docTaskId, participantSysId);
        var note;
        var docTaskNoteGr = new GlideRecord("sn_doc_task_note");
        docTaskNoteGr.addQuery("source_document_task", docTaskId);
        docTaskNoteGr.addQuery("state", "IN", "new,submitted,revised");
        docTaskNoteGr.addQuery("participant", participantSysId);
        docTaskNoteGr.query();
        while (docTaskNoteGr.next()) {
            note = {};
            note.noteId = docTaskNoteGr.getUniqueValue();
            note.fieldId = docTaskNoteGr.getValue("field");
            if (docTaskNoteGr.field)
                note.fieldName = docTaskNoteGr.field.getRefRecord().getValue("document_field_label");

            note.pageNumber = docTaskNoteGr.getValue("page_number");
            note.note = docTaskNoteGr.getValue("note");
            note.state = docTaskNoteGr.getValue("state");
            notes.push(note);
        }
        return notes;
    },

    /**
     * Description: Get submitted notes for given document task and
     * all previous document tasks in the hierarchy for REVIEWER
     * @param {SysID} docTaskId 
     * @return {Array} notes
     */
    getSubmittedNotesForReviewer: function(docTaskId, participantSysId) {
        var notes = [];
        var note;
        var docTaskNoteGr;
        var triggeredString = "task_retriggered_by";
        var docTaskGr = new GlideRecord("sn_doc_task");
        docTaskGr.get(docTaskId);
        var documentTaskId = docTaskGr.getElement(triggeredString);
        while (!gs.nil(documentTaskId)) {
            docTaskNoteGr = new GlideRecord("sn_doc_task_note");
            docTaskNoteGr.addQuery("source_document_task", documentTaskId);
            docTaskNoteGr.addQuery("state", "submitted");
            docTaskNoteGr.addQuery("participant", participantSysId);
			docTaskNoteGr.orderBy('sys_created_on');
            docTaskNoteGr.query();
            while (docTaskNoteGr.next()) {
                note = this._constructNoteObj(docTaskNoteGr);
                notes.push(note);
            }
            triggeredString = triggeredString + ".task_retriggered_by";
            documentTaskId = docTaskGr.getElement(triggeredString);
        }
		notes.sort(function(a, b){
			if (GlideDateTime(a.createdOn) &gt; GlideDateTime(b.createdOn)) 
				return 1;
			if (GlideDateTime(a.createdOn) &lt; GlideDateTime(b.createdOn)) 
				return -1;
			return 0;
		});
        return notes;
    },

    /**
     * Description: Get submitted notes for given document task and
     * all previous document tasks in the hierarchy  for FILLER
     * @param {SysID} docTaskId 
     * @return {Array} notes
     */
    getSubmittedNotesForFiller: function(docTaskId) {
        var notes = [];
        var note;
        var docTaskNoteGr;
        var triggeredString = "task_retriggered_by";
        var docTaskGr = new GlideRecord("sn_doc_task");
        docTaskGr.get(docTaskId);
        var documentTaskId = docTaskGr.getElement(triggeredString);
        while (!gs.nil(documentTaskId)) {
            docTaskNoteGr = new GlideRecord("sn_doc_task_note");
            docTaskNoteGr.addQuery("source_document_task", documentTaskId);
            docTaskNoteGr.addQuery("state", "submitted");
			docTaskNoteGr.orderBy("sys_created_on");
            docTaskNoteGr.query();
            while (docTaskNoteGr.next()) {
                note = this._constructNoteObj(docTaskNoteGr);
                notes.push(note);
            }
            triggeredString = triggeredString + ".task_retriggered_by";
            documentTaskId = docTaskGr.getElement(triggeredString);
        }
		notes.sort(function(a, b){
			if (GlideDateTime(a.createdOn) &gt; GlideDateTime(b.createdOn)) 
				return 1;
			if (GlideDateTime(a.createdOn) &lt; GlideDateTime(b.createdOn)) 
				return -1;
			return 0;
		});
        return notes;
    },

    /**
     * Description: Constructs a note object from TaskNote GlideRecord
     * @param {GlideRecord} docTaskNoteGr 
     * @return {Object} note
     */
    _constructNoteObj: function(docTaskNoteGr) {
        var note = {};
        note.noteId = docTaskNoteGr.getUniqueValue();
        note.fieldId = docTaskNoteGr.getValue("field");
        if (docTaskNoteGr.field)
            note.fieldName = docTaskNoteGr.field.getRefRecord().getValue("document_field_label");
        note.pageNumber = docTaskNoteGr.getValue("page_number");
        note.note = docTaskNoteGr.getValue("note");
        note.state = docTaskNoteGr.getValue("state");
		note.createdOn = docTaskNoteGr.getValue("sys_created_on");
        return note;
    },

    /**
     * Description: Create task note.
     * @param {SysID} docTaskId 
     * @param {Object} note
     * @return {SysID} 
     */
    createNote: function(docTaskId, note) {
        var docTaskGr = new GlideRecord("sn_doc_task");
        docTaskGr.get(docTaskId);
        var docTaskNoteGr = new GlideRecord("sn_doc_task_note");
        docTaskNoteGr.initialize();
        docTaskNoteGr.source_document_task = docTaskId;
        docTaskNoteGr.page_number = note.pageNumber;
        docTaskNoteGr.state = note.state;
        docTaskNoteGr.note = note.note;
        docTaskNoteGr.field = note.fieldId;
        docTaskNoteGr.revised_note = note.revisedNote;
        docTaskNoteGr.participant = docTaskGr.getValue("participant");

        return docTaskNoteGr.insert();
    },

    /**
     * Description: Update the Note.
     * @param {Object} note
     * @return {SysID} 
     */
    updateNote: function(note) {
        var updateStates = ["new", "revised"];
        var docTaskNoteGr = new GlideRecord("sn_doc_task_note");
        docTaskNoteGr.get(note.noteId);
        if (!docTaskNoteGr || updateStates.indexOf(docTaskNoteGr.getValue("state")) == -1)
            return null;
        docTaskNoteGr.note = note.note;
        docTaskNoteGr.page_number = note.pageNumber;
        docTaskNoteGr.field = note.fieldId;
        return docTaskNoteGr.update();

    },

    /**
     * Description: Delete the Note.
     * @param {SysID} noteId 
     * @return {boolean} 
     */
    deleteNote: function(noteId) {
        var docTaskNoteGr = new GlideRecord("sn_doc_task_note");
        docTaskNoteGr.get(noteId);
        if (docTaskNoteGr &amp;&amp; docTaskNoteGr.state == "new")
            if (docTaskNoteGr)
                return docTaskNoteGr.deleteRecord();
        return false;
    },

    /**
     * Description: Submit Notes.
     * @param {SysID} docTaskId 
     */
    submitNotes: function(docTaskId) {
        var docTaskNoteGr = new GlideRecord("sn_doc_task_note");
        docTaskNoteGr.addQuery("source_document_task", docTaskId);
        docTaskNoteGr.addQuery("state", "IN", "new,revised");
        docTaskNoteGr.setValue("state", "submitted");
        docTaskNoteGr.updateMultiple();
    },

    /**
     * Description: Accept Notes.
     * @param {SysID} docTaskId 	 
     * @param {SysID} noteId 
     * @return {boolean} 	 
     */
    acceptNote: function(docTaskId,noteId) {
        var acceptStates = ["submitted", "revised"];
        var docTaskNoteGr = new GlideRecord("sn_doc_task_note");
        docTaskNoteGr.get(noteId);
        if (docTaskNoteGr &amp;&amp; acceptStates.indexOf(docTaskNoteGr.getValue("state")) != -1) {
            docTaskNoteGr.setValue("accepted_document_task", docTaskId);
            docTaskNoteGr.setValue("state", "accepted");
            return docTaskNoteGr.update();
        } else
            return false;
    },

    /**
     * Description: Accept All Submitted/New from Revision Notes by this participant.
     * @param {SysID} docTaskId	 
     */
    acceptAllNotes: function(docTaskId) {
        var docTaskGr = new GlideRecord("sn_doc_task");
        docTaskGr.get(docTaskId);
        var participantSysId = docTaskGr.getValue("participant");

        var docTaskNoteGr = new GlideRecord("sn_doc_task_note");
        docTaskNoteGr.addQuery("state", "IN", "submitted,revised");
        docTaskNoteGr.addQuery("participant", participantSysId);
        docTaskNoteGr.setValue("accepted_document_task", docTaskId);
        docTaskNoteGr.setValue("state", "accepted");	
        docTaskNoteGr.updateMultiple();
    },

    /**
     * Description: Update the Note.
     * @param {SysID} reviseNoteId
     * @return {boolean}
     */
    reviseNote: function(reviseNoteId) {
        var docTaskNoteGr = new GlideRecord("sn_doc_task_note");
        docTaskNoteGr.get(reviseNoteId);
        docTaskNoteGr.setValue("state", "closed_by_revision");
        return docTaskNoteGr.update();
    },

    /**
     * Description: Returns true if task has new notes otherwise false.
     * @param {SysID} docTaskId
     * @return {boolean} 
     */
    hasNewNotes: function(docTaskId) {
        var docTaskNoteGr = new GlideRecord("sn_doc_task_note");
        docTaskNoteGr.addQuery("source_document_task", docTaskId);
        docTaskNoteGr.addQuery("state", "new");
        docTaskNoteGr.setLimit(1);
        docTaskNoteGr.query();
        return docTaskNoteGr.hasNext();
    },

    /**
     * Description: Returns true if task has Open notes otherwise false.
     * @param {SysID} docTaskId
     * @return {boolean}
     */
    hasOpenNotes: function(docTaskId) { 
		var docTaskGr = new GlideRecord("sn_doc_task");
        docTaskGr.get(docTaskId);
        var participantSysId = docTaskGr.getValue("participant");
		
        var docTaskNoteGr = new GlideRecord("sn_doc_task_note");
        docTaskNoteGr.addQuery("state", "IN", "new,submitted,revised");
		docTaskNoteGr.addQuery("participant", participantSysId);
        docTaskNoteGr.setLimit(1);
        docTaskNoteGr.query();
        return docTaskNoteGr.hasNext();
    },

    /**
     * Description: updates the notes checked by the user for the document task 
     * @param {SysId} docTaskId 
     * @param {String} notesList. comma separated sysId of notes 
     * @return {SysId}
     */
    updateCheckedNotes: function(docTaskId, notesList) {
        var docTaskGr = this.docTaskGr || this._getDocTaskGr(docTaskId);
        if (docTaskGr) {
            docTaskGr.setValue("checked_notes", notesList);
            return docTaskGr.update();
        }
        return null;
    },


    _getDocTaskGr: function(docTaskId) {
        var gr = new GlideRecord("sn_doc_task");
        if (gr.get(docTaskId))
            return gr;
        return null;
    },

    type: 'DocumentTaskNoteUtilsSNC'
};]]&gt;&lt;/script&gt;
        &lt;sys_class_name&gt;sys_script_include&lt;/sys_class_name&gt;
        &lt;sys_created_by&gt;admin&lt;/sys_created_by&gt;
        &lt;sys_created_on&gt;2020-03-13 14:23:49&lt;/sys_created_on&gt;
        &lt;sys_id&gt;1cc99d9577230010195693df59106117&lt;/sys_id&gt;
        &lt;sys_mod_count&gt;110&lt;/sys_mod_count&gt;
        &lt;sys_name&gt;DocumentTaskNoteUtilsSNC&lt;/sys_name&gt;
        &lt;sys_package display_value="Document Templates" source="sn_doc"&gt;6a9ea833b763330088d9bc78ee11a88q&lt;/sys_package&gt;
        &lt;sys_policy&gt;read&lt;/sys_policy&gt;
        &lt;sys_scope display_value="Document Templates"&gt;6a9ea833b763330088d9bc78ee11a88q&lt;/sys_scope&gt;
        &lt;sys_update_name&gt;sys_script_include_1cc99d9577230010195693df59106117&lt;/sys_update_name&gt;
        &lt;sys_updated_by&gt;admin&lt;/sys_updated_by&gt;
        &lt;sys_updated_on&gt;2020-05-18 11:30:49&lt;/sys_updated_on&gt;
    &lt;/sys_script_include&gt;
&lt;/record_update&gt;
</payload>
        <sys_class_name>sys_metadata_link</sys_class_name>
        <sys_created_by>admin</sys_created_by>
        <sys_created_on>2024-09-21 08:11:27</sys_created_on>
        <sys_id>3dc0f01983b01210c6695855eeaad3f3</sys_id>
        <sys_mod_count>0</sys_mod_count>
        <sys_name>DocumentTaskNoteUtilsSNC</sys_name>
        <sys_package display_value="Now Utils" source="x_938076_now_utils">b208a7c083689e50c6695855eeaad3d2</sys_package>
        <sys_policy/>
        <sys_scope display_value="Now Utils">b208a7c083689e50c6695855eeaad3d2</sys_scope>
        <sys_update_name>sys_metadata_link_3dc0f01983b01210c6695855eeaad3f3</sys_update_name>
        <sys_updated_by>admin</sys_updated_by>
        <sys_updated_on>2024-09-21 08:11:27</sys_updated_on>
        <tablename>sys_script_include</tablename>
    </sys_metadata_link>
</record_update>
