<?xml version="1.0" encoding="UTF-8"?><record_update table="sys_metadata_link">
    <sys_metadata_link action="INSERT_OR_UPDATE">
        <directory>update</directory>
        <documentkey>564ae3b84f022110abea4a51b1ce0be3</documentkey>
        <payload>&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;record_update table="sys_script_include"&gt;
    &lt;sys_script_include action="INSERT_OR_UPDATE"&gt;
        &lt;access&gt;package_private&lt;/access&gt;
        &lt;active&gt;true&lt;/active&gt;
        &lt;api_name&gt;sn_entitlement.LicenseRoleDiscoveredDao&lt;/api_name&gt;
        &lt;caller_access/&gt;
        &lt;client_callable&gt;false&lt;/client_callable&gt;
        &lt;description/&gt;
        &lt;name&gt;LicenseRoleDiscoveredDao&lt;/name&gt;
        &lt;script&gt;&lt;![CDATA[var LicenseRoleDiscoveredDao = Class.create();

LicenseRoleDiscoveredDao.prototype = {
    initialize: function() {
		this.NEW = 'New';
		this.SYNCED = 'Synced';
		this.ERROR = 'Error';
		this.DELETED = 'Deleted';
		this.STATE_VALUE_MAP = new Map([['0', this.NEW], ['1', this.SYNCED], ['2', this.ERROR], ['3', this.DELETED]]);
		this.STATE_LABEL_MAP = new Map([[this.NEW, '0'], [this.SYNCED, '1'], [this.ERROR, '2'], [this.DELETED, '3']]);
    },

	/**
	 * Lookup discovered role information for specified roleNames
	 * 
	 * @param {array} roleNames array of names of roles
	 * @return {array} array of LicenseRoleDiscoveredData value objects with sys_id as the id
	 */
	lookupForRole: function(roleNames) {
		const gr = new GlideRecord('license_role_discovered');
		gr.addQuery('sys_user_role', roleNames);
		return this._collect(gr);
	},

	/**
	 * Lookup roles other than those in specified roleNames
	 * @param {array} array of role names
	 * @return {array} array of role names found in license_role_discovered which are not in given list
	 */
	lookupRolesOtherThan: function(roleNames) {
		const gr = new GlideRecord('license_role_discovered');
		gr.addQuery('sys_user_role', 'NOT IN', roleNames);
		gr.query();
		const names = new Set();
		while (gr.next())
			names.add(gr.name.toString());
		
		return [...names];
	},

	/**
	 * Lookup discovered role information for specified roleNames in specified states
	 * @param {array} roleNames array of roleNames
	 * @param {array} states array of enumerated values from choice list in license_role.state
	 * @return {array} array of LicenseRoleDiscoveredData value objects with sys_id as the id
	 */
	lookupForRolesByState: function(roleNames, states) {
		const gr = new GlideRecord('license_role_discovered');
		gr.addQuery('sys_user_role', roleNames);
		gr.addQuery('state', states.map(s =&gt; this.STATE_LABEL_MAP.get(s)));
		return this._collect(gr);
	},

	/**
	 * Lookup discovered role information with records in specified states
	 * @param {array} states array of enumerated values from choice list in license_role.state
	 * @return {array} array of LicenseRoleDiscoveredData value objects with sys_id as the id
	 */
	lookupByState: function(states) {
		const gr = new GlideRecord('license_role_discovered');
		gr.addQuery('state', states.map(s =&gt; this.STATE_LABEL_MAP.get(s)));
		return this._collect(gr);
	},

	/**
	 * Lookup discovered role information with records not in specified states
	 * @param {array} states array of enumerated values from choice list in license_role.state
	 * @return {array} array of LicenseRoleDiscoveredData value objects with sys_id as the id
	 */
	lookupByStateOtherThan: function(states) {
		const gr = new GlideRecord('license_role_discovered');
		gr.addQuery('state', 'NOT IN', states.map(s =&gt; this.STATE_LABEL_MAP.get(s)));
		return this._collect(gr);
	},

	/**
	 * Insert or update LicenseRoleDiscoveredData into a record in license_role_discovered table
	 * treating the id as sys_id for the record.
	 * @param {object} data an object of type LicenseRoleDiscoveredData
	 * @return {string} sys_id of record or null if there is an error
	 */
	insertOrUpdate: function(data) {
		const gr = new GlideRecord('license_role_discovered');
		// GlideRecord.insertOrUpdate is blocked in scoped apps
		let update = false;
		if (data.id) {
			if (gr.get(data.id))
				update = true;
			else
				gr.setNewGuidValue(data.id);
		}
		gr.name = data.roleName;
		gr.sys_user_role = data.roleName;
		gr.license_role_type = data.roleType;
		gr.category = data.isCustom ? 1 : 0;
		gr.state = this.STATE_LABEL_MAP.get(data.state);
		gr.reason = data.reason;
		gr.application = data.application;
		gr.scope = this._getScopeSysId(data.scope);
		if (update)
			gr.update();
		else
			gr.insert();
		return gr.getUniqueValue();
	},

	/**
	 * Delete records with specified ids
	 * @param {array} ids array of sys_ids
	 */
	deleteRecords: function(ids) {
		const gr = new GlideRecord('license_role_discovered');
		gr.addQuery('sys_id', ids);
		gr.deleteMultiple();
	},

	/**
	 * Set the state for records with specified ids to specified state
	 * @param {array} ids array of sys_ids
	 * @param {string} state one of enumerated values from choice list in license_role.state
	 */
	markState: function(ids, state) {
		const gr = new GlideRecord('license_role_discovered');
		gr.addQuery('sys_id', ids);
		gr.state = this.STATE_LABEL_MAP.get(state);
		gr.updateMultiple();
	},

	_collect: function(gr) {
		const data = [];
		gr.query();
		while (gr.next())
			data.push(this._mapToData(gr));
		return data;
	},

	_mapToData: function(gr) {
		return new LicenseRoleDiscoveredData(
			gr.getUniqueValue(),
			gr.sys_user_role.toString(),
			gr.license_role_type.toString(),
			gr.category.toString() === '1',
			this.STATE_VALUE_MAP.get(gr.state.toString()),
			gr.getDisplayValue("reason").toString(),
			gr.application.toString(),
			gr.scope.scope.toString()
		);
	},

	/**
	 * Return the sys_id of sys_scope record corresponding to specified scope if present, else return null
	 * @param {string} the scope from sys_scope.scope
	 * @return {string} sys_id if scope can be found, else null
	 */
	_getScopeSysId: function(scope) {
		const gr = new GlideRecord('sys_scope');
		if (gr.get('scope', scope))
			return gr.getUniqueValue();
		return null;
	},

	type: 'LicenseRoleDiscoveredDao'
};]]&gt;&lt;/script&gt;
        &lt;sys_class_name&gt;sys_script_include&lt;/sys_class_name&gt;
        &lt;sys_created_by&gt;admin&lt;/sys_created_by&gt;
        &lt;sys_created_on&gt;2023-04-04 23:26:30&lt;/sys_created_on&gt;
        &lt;sys_id&gt;564ae3b84f022110abea4a51b1ce0be3&lt;/sys_id&gt;
        &lt;sys_mod_count&gt;26&lt;/sys_mod_count&gt;
        &lt;sys_name&gt;LicenseRoleDiscoveredDao&lt;/sys_name&gt;
        &lt;sys_package display_value="Licensing Engine" source="sn_entitlement"&gt;bcadabf277f311109c62f5f3cb5a992a&lt;/sys_package&gt;
        &lt;sys_policy&gt;read&lt;/sys_policy&gt;
        &lt;sys_scope display_value="Licensing Engine"&gt;bcadabf277f311109c62f5f3cb5a992a&lt;/sys_scope&gt;
        &lt;sys_update_name&gt;sys_script_include_564ae3b84f022110abea4a51b1ce0be3&lt;/sys_update_name&gt;
        &lt;sys_updated_by&gt;maint&lt;/sys_updated_by&gt;
        &lt;sys_updated_on&gt;2023-09-12 20:18:59&lt;/sys_updated_on&gt;
    &lt;/sys_script_include&gt;
&lt;/record_update&gt;
</payload>
        <sys_class_name>sys_metadata_link</sys_class_name>
        <sys_created_by>admin</sys_created_by>
        <sys_created_on>2024-09-21 08:37:17</sys_created_on>
        <sys_id>9cb6b01d83f01210c6695855eeaad303</sys_id>
        <sys_mod_count>0</sys_mod_count>
        <sys_name>LicenseRoleDiscoveredDao</sys_name>
        <sys_package display_value="Now Utils" source="x_938076_now_utils">b208a7c083689e50c6695855eeaad3d2</sys_package>
        <sys_policy/>
        <sys_scope display_value="Now Utils">b208a7c083689e50c6695855eeaad3d2</sys_scope>
        <sys_update_name>sys_metadata_link_9cb6b01d83f01210c6695855eeaad303</sys_update_name>
        <sys_updated_by>admin</sys_updated_by>
        <sys_updated_on>2024-09-21 08:37:17</sys_updated_on>
        <tablename>sys_script_include</tablename>
    </sys_metadata_link>
</record_update>
