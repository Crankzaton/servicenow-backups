<?xml version="1.0" encoding="UTF-8"?><record_update table="sys_metadata_link">
    <sys_metadata_link action="INSERT_OR_UPDATE">
        <directory>update</directory>
        <documentkey>2104d6eeb79b330063e1c386ee11a951</documentkey>
        <payload>&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;record_update table="sys_script_include"&gt;
    &lt;sys_script_include action="INSERT_OR_UPDATE"&gt;
        &lt;access&gt;package_private&lt;/access&gt;
        &lt;active&gt;true&lt;/active&gt;
        &lt;api_name&gt;global.ADTScriptInitiator&lt;/api_name&gt;
        &lt;caller_access/&gt;
        &lt;client_callable&gt;false&lt;/client_callable&gt;
        &lt;description&gt;Checks if there is an existing execution, 
if present returns it.
else 
1. Create a new Execution log record with hs_tests_context filled,
2. Initiates a trigger with a call to new HealthScanExecutor.execute(sys_id of #1).
3. Updates ( creates if doesn't exist )  the execution_status of execution table's record as executing, and hs_execution_log's value with sys_id of #2.
4. Return the hs_execution_log's sys_id and worker id.

&lt;/description&gt;
        &lt;name&gt;ADTScriptInitiator&lt;/name&gt;
        &lt;script&gt;&lt;![CDATA[var ADTScriptInitiator = Class.create();
ADTScriptInitiator.prototype = {
    initialize: function() {},

    triggerHealthScan: function(diagnosticSysID, input) {
        var healthScanRecord = ADTCRUDHelper.fetchSingleRecordWithSysID(ADTConstants.DIAG_TABLE, diagnosticSysID);
        var accessibleRoles = healthScanRecord.getValue(ADTConstants.DIAG_COL_ROLE);
        if(!gs.nil(accessibleRoles) &amp;&amp; !gs.getUser().hasRole(accessibleRoles)) {
            throw new Error(ADTConstants.ERR_MSG_DIAG_UNAUTHORIZED_ACCESS);
        }

        var existingRecord = this.getExistingHSExecution(diagnosticSysID, input);
        if (this.isExecutionRunning(existingRecord)) {
			ADTLogger.log("Found a diagnostic already running", this.type);
            return this.runningExeResult(existingRecord);
        } else {
			ADTLogger.log("Didn't found any running Diagnostic scan so triggering one", this.type);
            
            var featureRecord = ADTCRUDHelper.fetchSingleRecordWithSysID(ADTConstants.FEATURE_TABLE, healthScanRecord.getValue(ADTConstants.DIAG_COL_FEATURE));
            var executionRecord = existingRecord ? existingRecord :
                this.createAndGetNewExeRecordForHS(diagnosticSysID, input);
            var executionLogSysID = ADTCRUDHelper.createRecord(ADTConstants.EXEC_LOG_TABLE, {
                diag_context: JSON.stringify({
                    applicationSysID: featureRecord.getValue(ADTConstants.FEATURE_COL_APPLICATION),
                    featureSysID: healthScanRecord.getValue(ADTConstants.DIAG_COL_FEATURE),
                    diagnosticSysID: diagnosticSysID,
                    executionSysID: executionRecord.getValue(ADTConstants.SYS_ID),
                    input: input,
					type: ADTConstants.EXEC_TYPE_HS_RUN,
					varSpace: {}
                })
            });

            var result = this.assignHealthScanExecutionToWorker(executionLogSysID, healthScanRecord.getValue(ADTConstants.NAME));
            result.executionLogSysID = executionLogSysID;
            this.updateStatusAndResultToExeRecord(executionRecord, result);
            return result;
        }
    },

    assignHealthScanExecutionToWorker: function(executionLogSysID, healthScanName) {
        return this.assignExecutionLogToWorker(executionLogSysID, ADTConstants.PREFIX_HS + healthScanName, ADTConstants.HS_EXECUTOR);
    },

    assignExecutionLogToWorker: function(executionLogSysID, name, executorName) {
        var worker = new GlideScriptedHierarchicalWorker();
        worker.setProgressName(name);
        worker.setScriptIncludeName(executorName);
        worker.setScriptIncludeMethod(ADTConstants.EXECUTOR_METHOD);
        worker.putMethodArg(ADTConstants.EXECUTOR_METHOD_ARG, executionLogSysID);
        worker.setBackground(true);
        worker.start();
		ADTLogger.log("Assigned execution of " +  executionLogSysID + " to " + worker.getProgressID(), this.type);
        return {
            sysExecutionTrackerSysID: worker.getProgressID()
        };
    },


    getExistingHSExecution: function(diagnosticSysID, currentInput) {
        return this.getExistingExecutionRecord(ADTConstants.EXEC_TYPE_HS_RUN, diagnosticSysID, currentInput);
    },

    getExistingFSExecution: function(diagnosticSysID, currentInput) {
        return this.getExistingExecutionRecord(ADTConstants.EXEC_TYPE_FS_RUN, diagnosticSysID, currentInput);
    },

    getExistingExecutionRecord: function(type, diagnosticSysID, input) {
        var criteria = {};
		criteria[ADTConstants.EXEC_COL_TYPE] = type;
        criteria[ADTConstants.EXEC_COL_SCAN] = diagnosticSysID;
        criteria[ADTConstants.EXEC_COL_ENTITY_ID] = this.calculateEntityIDs(diagnosticSysID, input);
        var executionFetcher = ADTCRUDHelper.fetchRecordsWithCriteria(ADTConstants.EXEC_TABLE, criteria);
		
        return (executionFetcher.next()) ? executionFetcher : null;
    },

	calculateEntityIDs: function(diagnosticSysID, input) {
		var featureSysID = ADTCRUDHelper.fetchSingleRecordWithSysID(ADTConstants.DIAG_TABLE, diagnosticSysID).getValue(ADTConstants.DIAG_COL_FEATURE);
		ADTLogger.log("Calculating entityID for feature with sys_id: " + featureSysID, this.type);
		var featureInputFetcher = new GlideRecord(ADTConstants.FTR_INPUTS_TABLE);
		featureInputFetcher.addQuery(ADTConstants.FTR_INPUTS_COL_FTR, featureSysID);
		featureInputFetcher.orderBy(ADTConstants.ORDER);
		featureInputFetcher.query();
		
		var entityID = "";
		while(featureInputFetcher.next()) {
			entityID += featureInputFetcher.getValue(ADTConstants.FTR_INPUTS_COL_KEY_NAME);
			entityID += ":";
			if(!gs.nil(input[featureInputFetcher.getValue(ADTConstants.FTR_INPUTS_COL_KEY_NAME)])) {
				entityID += input[featureInputFetcher.getValue(ADTConstants.FTR_INPUTS_COL_KEY_NAME)];
			}
		}
		entityID = entityID.substring(0, 1000);
		ADTLogger.log("Calculated entity_ids as " + entityID, this.type);
		return entityID;
	},
	
    triggerFixScript: function(diagnosticSysID, input, failedParentSysID) {

        var failureParentRecord = ADTCRUDHelper.fetchSingleRecordWithSysID(ADTConstants.EXEC_LOG_TABLE, failedParentSysID);

        var parentsContext = JSON.parse(failureParentRecord.getValue(ADTConstants.EXEC_LOG_COL_CONTEXT));

        var fixScriptAccessRoles = ADTCRUDHelper.fetchSingleRecordWithSysID(ADTConstants.SCRIPT_TABLE, parentsContext.failureData.scriptSysID).getValue(ADTConstants.SCRIPT_COL_FIX_ACCESS_ROLES);

        if(!gs.nil(fixScriptAccessRoles) &amp;&amp; !gs.getUser().hasRole(fixScriptAccessRoles)) {
            throw new Error(ADTConstants.ERR_MSG_FIX_SCRIPT_UNAUTHORIZED_ACCESS);
        }


        //overriding the current input with diagnostic input
        input = parentsContext.input;

        var existingRecord = this.getExistingFSExecution(diagnosticSysID, input);
        if (this.isExecutionRunning(existingRecord)) {
			ADTLogger.log("Found an already running execution record", this.type);
            return this.runningExeResult(existingRecord);
        } else {
			ADTLogger.log("Didn't find an running execution record", this.type);

            var executionRecord = !gs.nil(existingRecord) ? existingRecord :
                this.createAndGetExeRecordForFS(diagnosticSysID, parentsContext, failedParentSysID, input);

			ADTLogger.log("Copying the context parameters from parent context " + JSON.stringify(parentsContext), this.type);
			
            var executionLogSysID = ADTCRUDHelper.createRecord(ADTConstants.EXEC_LOG_TABLE, {
                diag_context: JSON.stringify({
                    applicationSysID: parentsContext.applicationSysID,
                    featureSysID: parentsContext.featureSysID,
                    executionSysID: executionRecord.getValue(ADTConstants.SYS_ID),
                    parentSysID: failedParentSysID,
					diagnosticSysID: diagnosticSysID,
                    input: input,
					type: ADTConstants.EXEC_TYPE_FS_RUN,
					failedScriptSysID: parentsContext.failureData.scriptSysID,
					varSpace: parentsContext.varSpace
                })
            });

            var result = this.assignFixScriptExecutionToWorker(executionLogSysID, diagnosticSysID);
            result.executionLogSysID = executionLogSysID;

            executionRecord.setValue(ADTConstants.EXEC_COL_PARENT_FAILURE, failedParentSysID);
            this.updateStatusAndResultToExeRecord(executionRecord, result);

            return result;

        }
    },

    assignFixScriptExecutionToWorker: function(executionLogSysID, diagnosticSysID) {
        return this.assignExecutionLogToWorker(executionLogSysID, ADTConstants.PREFIX_FS + diagnosticSysID, ADTConstants.FS_EXECUTOR);
    },

    createAndGetNewExeRecordForHS: function(diagnosticSysID, input) {
        var record = {};
        record[ADTConstants.EXEC_COL_TYPE] = ADTConstants.EXEC_TYPE_HS_RUN;
        record[ADTConstants.EXEC_COL_SCAN] = diagnosticSysID;
        record[ADTConstants.EXEC_COL_ENTITY_ID] = this.calculateEntityIDs(diagnosticSysID, input);
        return ADTCRUDHelper.createAndGetRecord(ADTConstants.EXEC_TABLE, record);
    },

    isExecutionRunning: function(executionRecord) {
        return executionRecord &amp;&amp;
            ADTConstants.STATUS_EXECUTING === executionRecord.getValue(ADTConstants.EXEC_STATUS);
    },

    runningExeResult: function(existingRecord) {
        return {
            executionLogSysID: existingRecord.getValue(ADTConstants.EXEC_COL_EXECUTION_LOG),
            sysExecutionTrackerSysID: existingRecord.getValue(ADTConstants.EXEC_COL_SYS_EXE_TRACKER)
        };
    },

    createAndGetExeRecordForFS: function(diagnosticSysID, parentsContext, failedParentSysID, input) {
        var record = {};
        record[ADTConstants.EXEC_COL_TYPE] = ADTConstants.EXEC_TYPE_FS_RUN;
        record[ADTConstants.EXEC_COL_SCAN] = diagnosticSysID;
        record[ADTConstants.EXEC_COL_ENTITY_ID] = this.calculateEntityIDs(diagnosticSysID, input);
        record[ADTConstants.EXEC_COL_PARENT_FAILURE] = failedParentSysID;

        return ADTCRUDHelper.createAndGetRecord(ADTConstants.EXEC_TABLE, record);
    },

    updateStatusAndResultToExeRecord: function(executionRecord, result) {
        executionRecord.setValue(ADTConstants.EXEC_STATUS, ADTConstants.STATUS_EXECUTING);
        executionRecord.setValue(ADTConstants.EXEC_COL_EXECUTION_LOG, result.executionLogSysID);
        executionRecord.setValue(ADTConstants.EXEC_COL_SYS_EXE_TRACKER, result.sysExecutionTrackerSysID);
		ADTLogger.log("Updating status of execution as " + JSON.stringify(result), this.type);
        executionRecord.update();
    },



    type: 'ADTScriptInitiator'
};]]&gt;&lt;/script&gt;
        &lt;sys_class_name&gt;sys_script_include&lt;/sys_class_name&gt;
        &lt;sys_created_by&gt;admin&lt;/sys_created_by&gt;
        &lt;sys_created_on&gt;2019-08-19 09:44:51&lt;/sys_created_on&gt;
        &lt;sys_id&gt;2104d6eeb79b330063e1c386ee11a951&lt;/sys_id&gt;
        &lt;sys_mod_count&gt;88&lt;/sys_mod_count&gt;
        &lt;sys_name&gt;ADTScriptInitiator&lt;/sys_name&gt;
        &lt;sys_package display_value="Application Diagnostics Tool" source="com.snc.app_diagnostics_tool"&gt;822052ab47e64210cd4e1ce4316d4382&lt;/sys_package&gt;
        &lt;sys_policy/&gt;
        &lt;sys_scope display_value="Global"&gt;global&lt;/sys_scope&gt;
        &lt;sys_update_name&gt;sys_script_include_2104d6eeb79b330063e1c386ee11a951&lt;/sys_update_name&gt;
        &lt;sys_updated_by&gt;admin&lt;/sys_updated_by&gt;
        &lt;sys_updated_on&gt;2019-09-24 19:03:56&lt;/sys_updated_on&gt;
    &lt;/sys_script_include&gt;
&lt;/record_update&gt;
</payload>
        <sys_class_name>sys_metadata_link</sys_class_name>
        <sys_created_by>admin</sys_created_by>
        <sys_created_on>2024-09-21 08:11:57</sys_created_on>
        <sys_id>d9e03c1983b01210c6695855eeaad379</sys_id>
        <sys_mod_count>0</sys_mod_count>
        <sys_name>ADTScriptInitiator</sys_name>
        <sys_package display_value="Now Utils" source="x_938076_now_utils">b208a7c083689e50c6695855eeaad3d2</sys_package>
        <sys_policy/>
        <sys_scope display_value="Now Utils">b208a7c083689e50c6695855eeaad3d2</sys_scope>
        <sys_update_name>sys_metadata_link_d9e03c1983b01210c6695855eeaad379</sys_update_name>
        <sys_updated_by>admin</sys_updated_by>
        <sys_updated_on>2024-09-21 08:11:57</sys_updated_on>
        <tablename>sys_script_include</tablename>
    </sys_metadata_link>
</record_update>
