<?xml version="1.0" encoding="UTF-8"?><record_update table="sys_metadata_link">
    <sys_metadata_link action="INSERT_OR_UPDATE">
        <directory>update</directory>
        <documentkey>3c06c468eb243110da1861c59c5228cb</documentkey>
        <payload>&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;record_update table="sys_script_include"&gt;
    &lt;sys_script_include action="INSERT_OR_UPDATE"&gt;
        &lt;access&gt;public&lt;/access&gt;
        &lt;active&gt;true&lt;/active&gt;
        &lt;api_name&gt;sn_nowassist_admin.NowAssistSkillConfig&lt;/api_name&gt;
        &lt;caller_access/&gt;
        &lt;client_callable&gt;false&lt;/client_callable&gt;
        &lt;description/&gt;
        &lt;name&gt;NowAssistSkillConfig&lt;/name&gt;
        &lt;script&gt;&lt;![CDATA[var NowAssistSkillConfig = Class.create();
NowAssistSkillConfig.prototype = {
    initialize: function() {
        this.SKILL_CONFIG = "sn_nowassist_skill_config";
        this.SKILL_CONFIG_VAR_SET = "sn_nowassist_skill_config_var_set";
        this.SKILL_CONFIG_VAR_SET_UI = "sn_ns_skill_config_var_set_ui";
        this.SKILL_VAR_SET_TEMPLATE = "sn_nowassist_skill_config_type";
        this.SKILL_CONFIG_APPLICABILITY = "sn_nowassist_skill_config_applicability";
        this.GEN_AI_SKILL_APPLICABILITY = "sys_gen_ai_skill_applicability";
        this.NS_ADMIN_INTERNAL_FILTER_KEYS = ['__applicable_for_extended_tables__'];
        this.CACHE_UTIL = new NowAssistCacheUtil();
        this.domainId = gs.getSession().getCurrentDomainID() || "global";
        this.SKILL_CONFIG_CACHE_STORE = 'CONFIG';
        this.APPLICABILITY_CACHE_STORE = 'APPLICABILITY';
        this.CONFIG_TO_SKILL_M2M = 'sn_ns_config_m2m_skill';
    },

    /**
     * This method retrieves the details of a skill configuration record along with its associated skill config variables. 
     * The skill config variables can be nested to represent a hierarchical structure. The hierarchical structure of skill config
     * variables represent an override behavior.
     *
     * @param {String} skillConfigId(sn_nowassist_skill_config)
     * 
     * @return An object of type {@link SkillConfigDetails} that contains the details of the skill configuration record 
     * and its associated skill config variables.
     */
    getSkillConfiguration: function(skillConfigId) {
        var result = this.CACHE_UTIL.getNACache(this.SKILL_CONFIG_CACHE_STORE, this.domainId, skillConfigId);
        if (!result) {
            var skillConfigGr = new GlideRecord(this.SKILL_CONFIG);
            if (skillConfigGr.get(skillConfigId)) {
                result = this._getSkillConfigInfo(skillConfigGr);
                this.CACHE_UTIL.setNACache(this.SKILL_CONFIG_CACHE_STORE, this.domainId, skillConfigId, result);
            }
        }
        return result;
    },

    /**
     * This method retrieves the skill configurations for all the records that are associated with the given skillId.
     * The returned array contains objects of individual skill configurations. Every such object contains details of a skill configuration
     * and its associated variables. 
     * 
     *
     * @param {String} skillConfigId(sn_nowassist_skill_config)
     * 
     * @return {Array} Contains array of objects where each object represents details of a skill configuration.
     */
    getSkillConfigurationsBySkillId: function(skillId) {
        var configM2MSkill = new GlideRecord(this.CONFIG_TO_SKILL_M2M);
        configM2MSkill.addQuery('skill_id', skillId);
        configM2MSkill.query();

        var skillConfigIds = [];
        while (configM2MSkill.next()) {
            skillConfigIds.push(configM2MSkill.getValue('skill_config'));
        }

        var skillConfigGr = new GlideRecord(this.SKILL_CONFIG);
        skillConfigGr.addQuery('skill_id', skillId).addOrCondition('sys_id', 'IN', skillConfigIds.join(','));
        skillConfigGr.query();

        var skillConfigurations = [];
        while (skillConfigGr.next()) {
            var skillConfiguration = this.CACHE_UTIL.getNACache(this.SKILL_CONFIG_CACHE_STORE, this.domainId, skillConfigGr.getValue('sys_id'));
            if (!skillConfiguration) {
                skillConfiguration = this._getSkillConfigInfo(skillConfigGr);
                this.CACHE_UTIL.setNACache(this.SKILL_CONFIG_CACHE_STORE, this.domainId, skillConfigGr.sys_id, skillConfiguration);
            }
            skillConfigurations.push(skillConfiguration);
        }

        return skillConfigurations;
    },

    /**
     * This method retrieves the details of all skill variables for the given skillConfigId. If the 'shouldIncludeVariableOverrides' flag is true,
     * it includes the variables override sets for all the variable sets. 
     * 
     *
     * @param {String} skillConfigId(sn_nowassist_skill_config)
     * @param {Boolean} shouldIncludeVariableOverrides - Indicates whether override sets should be included for the variables.
     * 
     * @return {Array} Contains array of variable set objects.
     */
    getSkillConfigurationVariables: function(skillConfigId, shouldIncludeVariableOverrides) {
        // Get from cache
        var configData = this.CACHE_UTIL.getNACache(this.SKILL_CONFIG_CACHE_STORE, this.domainId, skillConfigId);
        if (configData) {
            return configData.variable_sets;
        }

        // Get from DB
        var skillConfigVarSetGr = new GlideRecord(this.SKILL_CONFIG_VAR_SET);
        skillConfigVarSetGr.addQuery('skill_config', skillConfigId);
        skillConfigVarSetGr.addNullQuery('parent');
        skillConfigVarSetGr.orderBy('order');
        skillConfigVarSetGr.query();

        var skillConfigVariables = [];

        while (skillConfigVarSetGr.next()) {
            skillConfigVariables.push(this._getVariableSetInfo(skillConfigVarSetGr, shouldIncludeVariableOverrides));
        }

        return skillConfigVariables;
    },

    /**
     * Checks if the given skillConfigId record is active.
     *
     * @param {String} skillConfigId(sn_nowassist_skill_config)
     * @return {Boolean}
     */
    isSkillConfigurationActive: function(skillConfigId) {
        var configData = this.CACHE_UTIL.getNACache(this.SKILL_CONFIG_CACHE_STORE, this.domainId, skillConfigId);
        if (configData) {
            return configData.active;
        }

        var skillConfigGr = new GlideRecord(this.SKILL_CONFIG);
        if (skillConfigGr.get(skillConfigId)) {
            return skillConfigGr.getDisplayValue('active') === "true";
        }
        return false;
    },

    /**
     * Checks if the skill configuration with the given record ID is enabled in product.
     *
     * @param {String} skillConfigId(sn_nowassist_skill_config)
     * @return {Boolean}
     */
    isSkillConfigurationEnabledInProduct: function(skillConfigId) {
        var configData = this.CACHE_UTIL.getNACache(this.SKILL_CONFIG_CACHE_STORE, this.domainId, skillConfigId);
        if (configData) {
            return configData.in_product_active;
        }

        var skillConfigGr = new GlideRecord(this.SKILL_CONFIG);
        if (skillConfigGr.get(skillConfigId)) {
            return skillConfigGr.in_product_active.toString() == "true";
        }
        return false;
    },

    /**
     * Checks if the skill configuration with the given record ID is enabled in Now Assist Panel.
     *
     * @param {String} skillConfigId(sn_nowassist_skill_config)
     * @return {Boolean}
     */
    isSkillConfigurationEnabledInNowAssistPanel: function(skillConfigId) {
        var configData = this.CACHE_UTIL.getNACache(this.SKILL_CONFIG_CACHE_STORE, this.domainId, skillConfigId);
        if (configData) {
            return configData.nap_active;
        }

        var skillConfigGr = new GlideRecord(this.SKILL_CONFIG);
        if (skillConfigGr.get(skillConfigId)) {
            var nap_skill_applicability = this._getNAPSkillApplicabilities(skillConfigGr);
            return this._getNowAssistPanelActiveStatus(nap_skill_applicability);
        }
        return false;
    },

    /**
     * Retrieves and returns the first matching skill configuration based on specific criteria.
     *
     * This method retrieves the first matching skill configuration by following these steps:
     *
     * 1. It searches for `sn_nowassist_skill_config_applicability` records whose `skill_config.skill_id` matches the provided `skillId`.
     * 2. Among the matching records, it evaluates each `applicabilityGR.filter_parameters` to check if it is 
     *	a subset of the provided `filter` or exactly matches based on the provided `strictMatch` flag.
     *	-&gt; If `strictMatch` is false and the `filter_parameters` is a subset of the given `filter`, it's considered a match.
     *	-&gt; If `strictMatch` is true and the `filter_parameters` is exactly deeply similar to `filter`, itâ€™s considered a match.
     *
     * @param {String} skillId - The ID of the skill.
     * @param {Object} filter - A filter to match against.
     * @param {boolean} strictMatch - decides whether the comparison between filter_parameters and filter is a subset match or a strict match.
     * 
     * @returns {Object|null} The skill configuration that matches the criteria, or `null` if no match is found.
     */
    getSkillConfigBySkillIdAndFilter: function(skillId, filter, strictMatch = true) {
        return this.getSkillConfigBySkillIdAndFilters(skillId, [filter], strictMatch);
    },

    /**
     * Retrieves and returns the first matching skill configuration based on specific criteria.
     *
     * This method retrieves the first matching skill configuration by following these steps:
     *
     * 1. It searches for `sn_nowassist_skill_config_applicability` records whose `skill_config.skill_id` matches the provided `skillId`.
     * 2. Among the matching records, it evaluates each `applicabilityGR.filter_parameters` to check 
     *    if it is a subset of any of the provided filter objects in the `filters` array or if it is an 
     *    exact match based on the provided `strictMatch` flag. 
     *    -&gt; If `strictMatch` is false and the `filter_parameters` is a subset of either of the given filter Objects in the `filters` array, it's considered a match.
     *    -&gt; If `strictMatch` is true and the `filter_parameters` is exactly deeply similar to either of the given filter Objects in the `filter` array, itâ€™s considered a match.
     *
     * @param {String} skillId - The ID of the skill.
     * @param {Object} filters - A set of filters to match against.
     * @param {boolean} strictMatch - decides whether the comparison between filter_parameters and filter is a subset match or a strict match.
     * 
     * @returns {Object|null} The skill configuration that matches the criteria, or `null` if no match is found.
     */
    getSkillConfigBySkillIdAndFilters: function(skillId, filters, strictMatch = true) {
        if (gs.nil(skillId)) {
            return [];
        }
        var skillConfigApplicabilityRecordsInfo = this._getSkillConfigApplicabilityRecordsInfo(skillId);
        return this._getSkillConfigByFilters(filters, strictMatch, skillConfigApplicabilityRecordsInfo);
    },

    /**
     * Retrieves and returns the first matching skill configuration based on specific criteria.
     *
     * This method retrieves the first matching skill configuration by following these steps:
     *
     * 1. It searches for `sn_nowassist_skill_config_applicability` records whose `skill_config.skill_id` matches the provided `skillId`.
     * 2. Among the matching records, it evaluates each `applicabilityGR.filter_parameters` to check if it 
     * 	  is a subset/exact match of the provided `filters` object/array.
     * 	  -&gt; If `strictMatch` is false and the `filter_parameters` is a subset of the any filter in `filters` array or a subset of the filters object, it's considered a match.
     *    -&gt; If `strictMatch` is true and the `filter_parameters` is an exact key to key and key to value match of either of the filter objects in the `filters` array or with the `filters` object, itâ€™s considered a match.
     * 
     * 3. Additionally, as a specific use-case, if the provided `filters` contain a key named `table` and no matches are found for that table name, the method extends its search to the parent table.
     * 4. If a valid record is found for the base table that satisfies the filters, it checks if that applicability record is applicable
     *    for its extended tables based on the `__applicable_for_extended_tables__` filter parameter.
     * 		- Only if the `__applicable_for_extended_tables__` key is declared and set to false will the record be considered in-applicable.
     *
     * @param {String} skillId - The ID of the skill.
     * @param {Object|Array} filters - A single filter object or an array of filters to match against.
     * @param {boolean} strictMatch - decides whether the comparison between filter_parameters and filter is a subset match or a strict match.
     * 
     * @returns {Object|null} The skill configuration that matches the criteria, or `null` if no match is found.
     */
    getSkillConfigurationWithBaseTableFallback: function(skillId, filters, strictMatch = true) {
        if (gs.nil(skillId))
            return {};

        var skillConfigApplicabilityRecordsInfo = this._getSkillConfigApplicabilityRecordsInfo(skillId);
        var filterContext = Array.isArray(filters) ? filters : [filters];
        return this._getSkillConfigurationWithBaseTableFallback(filterContext, strictMatch, false, skillConfigApplicabilityRecordsInfo);
    },

    /**
     * Internal util method. Compiles a collection of skill config applicability records. If skillId is passed, then it
     * returns only the applicability records whose skill_config.skill_id is equal to skillId.
     */
    _getSkillConfigApplicabilityRecordsInfo: function(skillId) {
        var cachedApplicabilityRecordsInfo = this.CACHE_UTIL.getNACache(this.APPLICABILITY_CACHE_STORE, this.domainId, skillId);
        if (cachedApplicabilityRecordsInfo) {
            return cachedApplicabilityRecordsInfo;
        }

        var skillConfigApplicabilityGr = new GlideRecord(this.SKILL_CONFIG_APPLICABILITY);
        skillConfigApplicabilityGr.orderBy('order');
        skillConfigApplicabilityGr.query();

        try {
            var skillConfigApplicabilityRecordsInfo = [];
            while (skillConfigApplicabilityGr.next()) {
                var skillConfig = skillConfigApplicabilityGr.skill_config;
                var isActive = skillConfig &amp;&amp; skillConfig.active;
                var isSkillIdMappedToSkillConfig = this._isSkillConfigMappedToSkill(skillConfig, skillId) || skillConfig.skill_id.toString() == skillId
                if (!isActive || !isSkillIdMappedToSkillConfig) {
                    continue;
                }
                skillConfigApplicabilityRecordsInfo.push({
                    sysId: skillConfigApplicabilityGr.getValue('sys_id'),
                    filterParameters: JSON.parse(skillConfigApplicabilityGr.getValue('filter_parameters')),
                    skillConfig: skillConfigApplicabilityGr.getValue('skill_config'),
                    skillId: skillId
                });
            }

            // set into cache
            if (skillConfigApplicabilityRecordsInfo.length) {
                var applicabilityRecordId = skillConfigApplicabilityRecordsInfo[0].sysId;
                this.CACHE_UTIL.setNACache(this.APPLICABILITY_CACHE_STORE, this.domainId, applicabilityRecordId, skillConfigApplicabilityRecordsInfo, skillId);
            }
            return skillConfigApplicabilityRecordsInfo;
        } catch (e) {
            gs.error('NowAssistSkillConfig: Unable to fetch skill configurations for filters: ' + e.toString());
            return [];
        }
    },

    _isSkillConfigMappedToSkill: function(skillConfig, skillId) {
        var configAndSkillM2MGr = new GlideRecord(this.CONFIG_TO_SKILL_M2M);
        configAndSkillM2MGr.addQuery('skill_config', skillConfig);
        configAndSkillM2MGr.addQuery('skill_id', skillId);
        configAndSkillM2MGr.query();

        return configAndSkillM2MGr.getRowCount() &gt; 0;
    },

    _getVariables: function(glideRecord) {
        var variables = {};
        var vars = glideRecord.vars;
        for (var item in vars) {
            variables[item] = gs.nil(vars[item]) ? "" : vars[item].toString();
        }
        return variables;
    },

    _getVariableOverrides: function(variableSetId) {
        var skillConfigVarSetGr = new GlideRecord(this.SKILL_CONFIG_VAR_SET);
        skillConfigVarSetGr.addQuery('parent', variableSetId);
        skillConfigVarSetGr.orderBy('order');
        skillConfigVarSetGr.query();

        var overrideSet = [];
        while (skillConfigVarSetGr.next()) {
            overrideSet.push(this._getVariableSetInfo(skillConfigVarSetGr, true));
        }

        return overrideSet;
    },

    _getVariableSetInfo: function(skillConfigVarSetGr, shouldIncludeVariableOverrides) {
        var step_details = {};
        step_details.name = skillConfigVarSetGr.getValue('name');
        step_details.order = skillConfigVarSetGr.getValue('order');

        //props for skill var set
        step_details.props = this._getVariables(skillConfigVarSetGr);
        if (shouldIncludeVariableOverrides) {
            step_details.override_sets = this._getVariableOverrides(skillConfigVarSetGr.getValue('sys_id'));
        }

        return step_details;
    },

    /**
     * Checks if a set of filter parameters matches against a set of filters to be matched.
     *
     * This method compares provided filter parameters against specified filters in a systematic manner:
     *
     * - For each filter parameter key, the method checks if there is a corresponding filter in the given `filtersToMatch`.
     * - If a matching filter exists, it evaluates whether the filter parameter's value matches the filter value.
     *   - If the filter parameter's value includes the special string '^OR', the method checks if any of the options
     *     separated by '^OR' match the filter value.
     *   - If not using '^OR', the method performs an exact equality comparison.
     * - If the filter parameter key does not exist in `filtersToMatch`, it's considered a mismatch.
     * - If all filter parameters match their corresponding filters, the method returns true; otherwise, it returns false.
     *
     * @param {Object} filterParams - The set of filter parameters to be checked.
     * @param {Object} filtersToMatch - The set of filters to match against.
     * @returns {boolean} `true` if all filter parameters match their corresponding filters; otherwise, `false`.
     */
    _isMatchWithFilters: function(filterParams, filtersToMatch) {
        var self = this;
        for (var filterIdx = 0; filterIdx &lt; filtersToMatch.length; filterIdx++) {
            var match = Object.keys(filterParams).every(function(key) {
                return self._compareKeyValue(key, filterParams, filtersToMatch[filterIdx]);
            });
            if (match) {
                return true;
            }
        }
        return false;
    },

    /**
     * Checks if the provided filter parameters strictly match against any of the given array of filters.
     *
     * This method iterates through each filter in the `filtersToMatch` array and compares it to the
     * provided `filterParams`. It checks if at least one filter in the array strictly matches the parameters,
     * meaning that both the number of keys and the values should be exactly the same.
     *
     * @param {Object} filterParams - The set of filter parameters to be checked.
     * @param {Object[]} filtersToMatch - The array offilters to match against.
     * @returns {boolean} `true` if any filter in the array strictly matches the filter parameters; otherwise, `false`.
     */
    _isStrictMatchWithFilters: function(filterParams, filtersToMatch) {
        var self = this;
        var filterParameters = this._copyObjectWithExclusions(filterParams, this.NS_ADMIN_INTERNAL_FILTER_KEYS);
        for (var filterIdx = 0; filterIdx &lt; filtersToMatch.length; filterIdx++) {
            var filter = filtersToMatch[filterIdx];
            var match = Object.keys(filterParameters).length == Object.keys(filter).length &amp;&amp;
                Object.keys(filterParameters).every(function(key) {
                    return self._compareKeyValue(key, filterParameters, filter);
                });
            if (match) {
                return true;
            }
        }
        return false;
    },

    _copyObjectWithExclusions: function(sourceObject, exclusionKeys) {
        var copiedObject = {};
        for (var key in sourceObject) {
            if (!exclusionKeys.includes(key)) {
                copiedObject[key] = sourceObject[key];
            }
        }
        return copiedObject;
    },

    _compareKeyValue: function(key, sourceObject, targetObject) {
        // Check if the key is in the list of internal filter keys
        if (this.NS_ADMIN_INTERNAL_FILTER_KEYS.includes(key))
            return true;

        // Check if the key exists in the targetObject
        if (targetObject.hasOwnProperty(key)) {
            // Handle special comparison cases
            if (sourceObject[key].includes('^OR')) {
                var options = sourceObject[key].split('^OR');
                return options.includes(targetObject[key]);
            } else if (sourceObject[key] === 'ISEMPTY') {
                return !targetObject[key];
            } else if (sourceObject[key] === 'ISNOTEMPTY') {
                return !!targetObject[key];
            }

            // Standard comparison
            return sourceObject[key] === targetObject[key];
        }

        // Key doesn't exist in targetObject
        return false;
    },

    /**
     * Internal method. Retrieves and returns the first skill configuration that matches the given filters.
     */
    _getSkillConfigByFilters: function(filters, strictMatch, skillConfigApplicabilityRecordsInfo) {
        try {
            for (var skillConfigApplicabilityRecordInfoIndex = 0; skillConfigApplicabilityRecordInfoIndex &lt; skillConfigApplicabilityRecordsInfo.length; skillConfigApplicabilityRecordInfoIndex++) {
                var skillConfigApplicabilityRecordInfo = skillConfigApplicabilityRecordsInfo[skillConfigApplicabilityRecordInfoIndex];
                var filterParams = skillConfigApplicabilityRecordInfo.filterParameters;
                var isMatch = strictMatch ? this._isStrictMatchWithFilters(filterParams, filters) : this._isMatchWithFilters(filterParams, filters);
                if (isMatch) {
                    return this.getSkillConfiguration(skillConfigApplicabilityRecordInfo.skillConfig);
                }
            }
        } catch (e) {
            gs.error('NowAssistSkillConfig: Unable to fetch skill configurations for filters: ' + JSON.stringify(filters) + e.toString());
        }
    },

    _getSkillConfigurationWithBaseTableFallback: function(filters, strictMatch, isQueryForBaseTable, skillConfigApplicabilityRecordsInfo) {
        try {
            if (!filters || !filters.length)
                return;

            for (var skillConfigApplicabilityRecordInfoIndex = 0; skillConfigApplicabilityRecordInfoIndex &lt; skillConfigApplicabilityRecordsInfo.length; skillConfigApplicabilityRecordInfoIndex++) {
                var skillConfigApplicabilityRecordInfo = skillConfigApplicabilityRecordsInfo[skillConfigApplicabilityRecordInfoIndex];
                var filterParams = skillConfigApplicabilityRecordInfo.filterParameters;
                var isMatch = strictMatch ? this._isStrictMatchWithFilters(filterParams, filters) : this._isMatchWithFilters(filterParams, filters);
                var isApplicable = !isQueryForBaseTable || !filterParams.hasOwnProperty('__applicable_for_extended_tables__') ||
                    filterParams['__applicable_for_extended_tables__'] == "true";
                if (isMatch &amp;&amp; isApplicable) {
                    return this.getSkillConfiguration(skillConfigApplicabilityRecordInfo.skillConfig);
                }
            }

            // Fallback to base table lookup
            var baseTableFilters = filters.reduce(function(result, filter) {
                if (filter.hasOwnProperty('table')) {
                    var tableHierarchy = new GlideTableHierarchy(filter.table);
                    var baseTable = tableHierarchy.getBase();
                    if (baseTable != filter.table) {
                        var baseTableFilter = JSON.parse(JSON.stringify(filter));
                        baseTableFilter.table = baseTable;
                        result.push(baseTableFilter);
                    }
                }
                return result;
            }, []);
            return this._getSkillConfigurationWithBaseTableFallback(baseTableFilters, strictMatch, true, skillConfigApplicabilityRecordsInfo);
        } catch (e) {
            gs.error('NowAssistSkillConfig: Unable to fetch skill configurations for filters and base table fallback: ' + JSON.stringify(filters) + e.toString());
        }
    },

    _getSkillConfigInfo: function(skillConfigGr) {
        var result = {};
        result.name = skillConfigGr.getValue('name');
        result.active = skillConfigGr.getDisplayValue('active') === "true";
        result.in_product_active = skillConfigGr.getDisplayValue('in_product_active') === "true";
        result.variable_sets = this.getSkillConfigurationVariables(skillConfigGr.getValue('sys_id'), true);
        result.sys_id = skillConfigGr.getValue('sys_id');
        var nap_skill_applicability = this._getNAPSkillApplicabilities(skillConfigGr);
        result.nap_active = this._getNowAssistPanelActiveStatus(nap_skill_applicability);
        result.in_product_roles = skillConfigGr.getValue('in_product_roles');
        return result;
    },

    _getCurrentDomainID: function() {
        return gs.getSession().getCurrentDomainID() || "global";
    },

    _getNowAssistPanelActiveStatus: function(genAiSkillApplicabilityId) {
        if (gs.nil(genAiSkillApplicabilityId) || !gs.tableExists(this.GEN_AI_SKILL_APPLICABILITY))
            return false;

        var genAiSkillApplicabilityGr = new GlideRecord(this.GEN_AI_SKILL_APPLICABILITY);
        genAiSkillApplicabilityGr.addQuery('sys_id', 'IN', genAiSkillApplicabilityId);
        genAiSkillApplicabilityGr.query();

        while (genAiSkillApplicabilityGr.next()) {
            if (genAiSkillApplicabilityGr.active.toString() == 'true') {
                return true;
            }
        }
        return false;
    },

    _getNAPSkillApplicabilities: function(skillConfigGr) {
        var configSkillM2M = new GlideRecord(this.CONFIG_TO_SKILL_M2M);
        configSkillM2M.addQuery('skill_config', skillConfigGr.getValue('sys_id'));
        configSkillM2M.query();

        var napSkillApplicabilities = [];
        while (configSkillM2M.next()) {
            var nap_skill_applicability = configSkillM2M.getValue("nap_skill_applicability");
            if (!gs.nil(nap_skill_applicability)) {
                napSkillApplicabilities.push(nap_skill_applicability);
            }
        }
        napSkillApplicabilities.push(skillConfigGr.getValue('nap_skill_applicability'));

        return napSkillApplicabilities.join(",");
    },

    type: 'NowAssistSkillConfig'
};]]&gt;&lt;/script&gt;
        &lt;sys_class_name&gt;sys_script_include&lt;/sys_class_name&gt;
        &lt;sys_created_by&gt;admin&lt;/sys_created_by&gt;
        &lt;sys_created_on&gt;2023-08-05 18:31:34&lt;/sys_created_on&gt;
        &lt;sys_id&gt;3c06c468eb243110da1861c59c5228cb&lt;/sys_id&gt;
        &lt;sys_mod_count&gt;125&lt;/sys_mod_count&gt;
        &lt;sys_name&gt;NowAssistSkillConfig&lt;/sys_name&gt;
        &lt;sys_package display_value="Now Assist Admin Console" source="sn_nowassist_admin"&gt;7c395aaa53003110453cddeeff7b123c&lt;/sys_package&gt;
        &lt;sys_policy/&gt;
        &lt;sys_scope display_value="Now Assist Admin Console"&gt;7c395aaa53003110453cddeeff7b123c&lt;/sys_scope&gt;
        &lt;sys_update_name&gt;sys_script_include_3c06c468eb243110da1861c59c5228cb&lt;/sys_update_name&gt;
        &lt;sys_updated_by&gt;admin&lt;/sys_updated_by&gt;
        &lt;sys_updated_on&gt;2023-10-26 07:49:13&lt;/sys_updated_on&gt;
    &lt;/sys_script_include&gt;
&lt;/record_update&gt;
</payload>
        <sys_class_name>sys_metadata_link</sys_class_name>
        <sys_created_by>admin</sys_created_by>
        <sys_created_on>2024-09-21 08:36:01</sys_created_on>
        <sys_id>f566bc9983f01210c6695855eeaad303</sys_id>
        <sys_mod_count>0</sys_mod_count>
        <sys_name>NowAssistSkillConfig</sys_name>
        <sys_package display_value="Now Utils" source="x_938076_now_utils">b208a7c083689e50c6695855eeaad3d2</sys_package>
        <sys_policy/>
        <sys_scope display_value="Now Utils">b208a7c083689e50c6695855eeaad3d2</sys_scope>
        <sys_update_name>sys_metadata_link_f566bc9983f01210c6695855eeaad303</sys_update_name>
        <sys_updated_by>admin</sys_updated_by>
        <sys_updated_on>2024-09-21 08:36:01</sys_updated_on>
        <tablename>sys_script_include</tablename>
    </sys_metadata_link>
</record_update>
